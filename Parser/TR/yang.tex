%
%% This is file `squelette-rr.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% RR.dtx  (with options: `sample')
%% ********************************************************************
%% Copyright (C) 1997-1999 2004 2006 2007 INRIA/APICS by Jose' Grimm
%% This file may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2003/12/01 or later.
%% An archive of the software can be found at
%%    ftp://ftp-sop.inria.fr/apics/rr-inria

\documentclass[a4paper]{article}


\usepackage{RR}
\usepackage{hyperref}

\usepackage{alltt}
\usepackage{graphicx}

%%\usepackage[frenchb]{babel} % optionnel
%%
%% date de publication du rapport
\RRdate{Avril 2008}
%%
%% Cas d'une version deux
%% \RRversion{2}
%% date de publication de la version 2
%% \RRdater{Novembre  2006}

%%
\RRauthor{% les auteurs
 % Premier auteur, avec une note
Emmanuel Nataf\thanks{Ma\^itre de conf\'erences - Universit\'e Nancy2}%
  % note partag\'ee (optionnelle)
  \thanks[sfn]{Madynes INRIA project}%
 % \and entre chaque auteur s'il y en a plusieurs
  \and
Olivier Festor\thanks{Directeur de Recherche INRIA}%
 % r\'ef\'erence \`a la note partag\'ee
%\thanksref{sfn}
}
%%
%% Ceci apparait sur chaque page paire.
\authorhead{E. Nataf, O. Festor}
%%
\RRtitle{jYang : un analyseur yang en java}
%% English title
\RRetitle{jYang : A \y\ parser in java}
%%
\titlehead{jYang}
%%
%\RRnote{This is a note}
%\RRnote{This is a second note}
%%
\RRresume{Dans  le contexte  du  groupe de  travail administration  et
op\'eration  des r\'eseaux  de l'IETF,  le protocole  de configuration
\nc\   a   été   d\'evelopp\'e   pour   manipuler   la   configuration
d'\'equipement   r\'eseau.    \y\  est   le   langage   en  cours   de
standardisation dans  ce groupe permettant de  sp\'ecifier des modèles
de donn\'ees  utilisable dans l'approche \nc.  Ce  rapport d\'ecrit la
conc\'eption et la r\'ealisation  en java d'un analyseur syntaxique et
s\'emantique de sp\'ecifications yang}

\RRabstract{The  NETCONF configuration  protocol of  the  IETF Network
Working Group  provides mechanisms to manipulate  the configuration of
network devices. YANG is the language currently under consideration in
the IETF to specify the data models  to be used in \nc\ .  This report
describes the design and development  of a syntax and semantics parser for
\y\ in java.}
%%
\RRmotcle{parser, java, yang, netconf}
\RRkeyword{parser, java, yang, netconf}
%%
 \RRprojet{Madynes}  % cas d'un seul projet
%%\RRprojets{Apics et Op\'era}
%%
 \RRtheme{\THCom} % cas d'un seul theme
%%\RRtheme{\THCom \THCog \THSym \THNum \THBio} % cas de 5 themes
%%
 \URLorraine % pour ceux qui sont \`a l'est
%% \URRennes  % pour ceux qui sont \`a l'ouest
%% \URRhoneAlpes % pour ceux qui sont dans les montagnes
%% \URRocq % pour ceux qui sont au centre de la France
%% there is the network that has this statement :
%% \URFuturs % pour ceux qui sont dans le virtuel
%% \URSophia % pour ceux qui sont au Sud.
%%
%% \RCBordeaux % centre de recherche Bordeaux - Sud Ouest
%% \RCLille % centre de recherche Lille Nord Europe
%% \RCParis % Paris Rocquencourt
%% \RCSaclay % Saclay \^Ile de France
%% \RCGrenoble % Grenoble - Rh\^one-Alpes
 \RCNancy % Nancy - Grand Est
%% \RCRennes % Rennes - Bretagne Atlantique
%%\RCSophia % Sophia Antipolis M\'editerran\'ee
%%

\newcommand{\jyang}{{\sl jYang}}
\newcommand{\nc}{NETCONF}
\newcommand{\y}{YANG}
\begin{document}
%%
%% \makeRR   % cas d'un rapport de recherche
\makeRT  % cas d'un rapport technique.
%% a partir d'ici, chacun fait comme il le souhaite

\section{Introduction}

It is frequent  in the network management world that  a protocol and a
data model are  separated even if jointly designed,  as it was already
the case in the  SNMP\cite{rfc1157} protocol and its SMI\cite{rfc1155}
data   modeling,CO\-PS\cite{rfc2748}   and  SP\-PI\cite{rfc3159},   or
SMI\-nG\cite{rfc3780} (GDMO and CMIS or  WBEM and CIM outside the IETF
scope).

\nc\ \cite{rfc4741} is the IETF standard that emerged from the netconf
working     group    to     configure     network    devices.      The
netmod\footnote{http://www.ietf.org/html.charters/netmod-charter.html}
working  group defines  \y\ as  a candidate  language to  specify data
models of values  carried by \nc.  This report  describes a YANG parser
called  \jyang\ that provides  a syntaxic  and semantic  validation of
YANG specifications (called modules or sub-modules).

This  report first  provides a  short description  of \nc\  where some
parts  are referenced  by  \y.  The part  \ref{yang}  details the  \y\
language  concepts   and  the  last   part  details  the   design  and
implementation of the \jyang parser.


\section{NETCONF protocol}

The \nc\ is a client/server  protocol where the server is a network
device  and the  client a  management framework  that  runs management
applications. Protocol requests  and responses focus on configuration
manipulation such as  getting the current configuration,  update, create or
delete it  or some  part of  it. Configurations are  represented in XML
document that contains two sort of data :
\begin{itemize}
\item
configuration  data   that  is  writable   and  that  describes
configuration parameters of the \nc\  agent.
\item
state data that is read-only and that describes operational data such
as counter or statistics.
\end{itemize}

Figure  \ref{netconfarchi}  extracted  from \cite{rfc4741}  shows  the
layered protocol architecture of NETCONF.  The protocol mainly defines
operations and how they are carried by rpc mechanisms.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .7]{netconfarchi.eps}
\end{center}
\caption{NETCONF protocol layers}
\label{netconfarchi}
\end{figure}

\subsection{Transport protocol}

The   specification  language   described  in   this  report   has  no
relationship with the transport protocol used with NETCONF.

\subsection{RPC}

The Remote  Procedure Call  on wich the  \nc\ operations are  built is
described  by two  XML\cite{Bray:00:EML}  elements :  {\tt <rpc>}  for
requests and {\tt <rpc-reply>} for responses.  This latter can contain
a {\tt <rpc-error>} element when an error occurs during the process of
a request inside the NETCONF agent.

\subsection{Operations}

Basic operations are defined as XML elements :

\begin{itemize}
\item
{\tt <get>} : to retrieve all or part of a configuration;
\item
{\tt <get-config>} : to retrieve all or part of configuration data;
\item
{\tt <edit-config>} : to update configuration data;
\item
{\tt <copy-config>} : to copy existing configuration data in place of
current configuration;
\item
{\tt <delete-config>} : to delete a configuration (but not the current one);
\item
{\tt <lock>} : to lock any configuration operations;
\item
{\tt <unlock>} : to unlock a locked configuration;
\item
{\tt  <close-session>}  : to  stop  the  NETCONG  agent accepting  any
request but achieves operation in progress;
\item
{\tt <kill-session>} : to stop  the NETCONF agent without achieving any
operations in progress.
\end{itemize}

All these operations are in  {\tt <rpc>} elements. A common element of
get, edit  or delete operations  is a filter element  ({\tt <filter>})
that allows some filtering on data by using the hierarchical structure
of XML documents.

\subsection{Capabilities}

Accepted operations (basics and  news operations) and data are defined
by capabilities.  A \nc\ agent  can provide more than one capabilities
and  an  unique  URI  reference each  capabilities.  Capabilities  are
excanged between entities at session establishement time.


\section{\y}
\label{yang}

The  \y\ Internet-Draft\cite{yang01}  defines \y\  as a  data modeling
language used to describe \nc\  configuration and state data. The \nc\
standard does  not define  such a language  for its content  layer (cf
fig.\ref{netconfarchi}).       The      netmod      working      group
charter\footnote{http://www.ietf.org/html.charters/netmod-charter.html}
explains why  a more hight  level that XML language  is  needed (An old
draft          can           be          seen          at          :
http://www.yang-central.org/twiki/pub/Main/Yang\-Do\-cu\-ments/draft-lengyel-why-yang-00.txt).


\subsection{\y\ specifications}

\y\ specifications are organized in modules and submodules
that contain data definitions. 

\subsection{\y\ module and submodule headers}

\y\  modules  and submodules  have  some  headers  that are  informations
related to the module or submodule itself.

\subsubsection{Module header}
\label{spec:module}

A module has mandatory headers and one optional header. The mandatory
ones are the {\tt name space} and {\tt prefix}.  For example :

\begin{verbatim}
module router {
  namespace ``urn:madynes:xml:ns:yang:router'';
  prefix router;
...
\end{verbatim}

The name  space is for all data  defined in the module  and the prefix
could be used inside the  module (when confusion is possible) to refer
some data. A \y\ {\tt version} header is optional.

\subsubsection{Submodule header}
\label{spec:submodule}

A submodule has one or two headers. It must have a {\tt belongs
to} statement and may have the \y\ {\tt version} statement. A
submodule belongs to one and only one module. For example :

\begin{verbatim}
submodule routing-policies {
  belongs-to router;
...
\end{verbatim}


\subsubsection{Yang specification meta statements}

Meta  statements  give some  general  information  on  the module  or
submodule.  These  informations  concern  the  organization  that
defines the module, the contact,  the description and the reference of
the  \y\ specification.   There  could be at most four meta statements.
A meta statement of a  specification must not be duplicated (i.e. two
contact meta statement in a module).

\subsubsection{Yang linkage statements}

A  yang  specification  can   have  {\tt  import}  and  {\tt  include}
statements.

\paragraph{Import statement}

The syntax  allows to identify an  other module and associate  to it a
prefix. For example :

\begin{verbatim}
module router {
...
import yang-types { prefix yang;}
...
\end{verbatim}

The module {\tt yang-types} is imported so that any type or data
defined in this module can be used in the {\tt router} module. In
order to use them without conflict, the prefix {\tt yang} must be
used. For example (again in the {\tt router} module):

\begin{verbatim}
...
leaf network {
  type yang:counter32;
}
...
\end{verbatim}

where {\tt counter32}  is defined in the {\tt  yang-types} module. The
prefix  used must  be the  same than  the one  defined in  the prefix
statement of the imported  module (see section \ref{spec:module}). 

 There can be several import statements but each prefix must be unique
in the  module.  The prefix  defined in a  module can be used  in this
module. A submodule can import modules but no submodules.


\paragraph{Include statement}
\label{spec:include}

The syntax allows to refer to a submodule. For example :

\begin{verbatim}
module router {
...
include routing-policies;
...
\end{verbatim}

The {\tt router} module  includes the {\tt routing-policies} submodule
so any type or  data defined in the submodule can be  used in that {\tt
router} module.

An included submodule must have  a {\tt belongs-to} statement with the
reference of the  including module (see section \ref{spec:submodule}).
A submodule can  include other submodules but they  must all belong to
the same module.



\subsubsection{Yang revision statement}

Any yang specification should  contain revision statements.  There is
one YANG\_Re\-vi\-si\-on  instance for each yang  revision statement and
each one can contain none or one description statement.




\y\ specifications describes data as a tree of nodes. There are two
main node types; leaf nodes that contain data values and 
nodes that contain (in the hierarchical meaning) other nodes.

\subsection{Leaf nodes}

There are two classes of leaf nodes~:
\begin{itemize}
\item
({\tt leaf}) that contains one value;
\item
({\tt leaf-list}) that contains a list of values of the same
type.
\end{itemize}

\subsection{Construct nodes}

Three containing nodes are defined : 
\begin{itemize}
\item
{\tt container} that contains other nodes
\item
{\tt list} that contains a list  of other nodes and where there can be
several instances of  the list of nodes.  A list can be seen  as a two
dimensional array  and a {\tt key}  parameter of the  {\tt list} allows
the reference of one instance of the list of node (an entry);
\item
{\tt  choice} that  contains  {\tt case}  constructs containing  other
nodes;
\item
{\tt rpc} that  contains other nodes and is used  in the rpc mechanism
of \nc.
\item
{\tt  notification} that  contains other  nodes  and is  used by  \nc\
notifications.
\end{itemize}

Following is an example of  a part of a \y\ specification\footnote{All
example in  this report are  inspired from the  draft\cite{yang01}} that
describes  a table  of network  interfaces, a  conceptual view  of two
entries and the XML document of this configuration:

\noindent
\begin{tabular}{lcl}
\begin{minipage}{.25\textwidth}
\begin{verbatim}
list interfaces {
   key index;
   leaf index {
     type int8;
   }
   leaf name {
     type string;
   }
   leaf type {
     type string;
   }
   leaf speed {
     type int64;
   }
}
\end{verbatim}
\end{minipage}
&
\begin{minipage}{.55\textwidth}
\includegraphics[scale=.6]{listinterface.eps}
\end{minipage}
&
\begin{minipage}{.2\textwidth}
\begin{small}
\begin{verbatim}
<list>
  <index>
     1
  </index>
  <name>
     loopback
  </name>
  <type>
     software-loopback
  </type>
  <speed>
     100000000
  </speed>
  <index>
     2
  </index>
  <name>
     ethernet
  </name>
  <type>
     ethernet-csmacd
  </type>
  <speed>
     100000000
  </speed>
</list>
\end{verbatim}
\end{small}
\end{minipage}
\end{tabular}

\subsection{Typedef}

\y\ defines  a set  of base types  (integer, float,  string\ldots) and
allows  the definition  of  new types  from  existing ones  by a  {\tt
typedef} construct.  For example below  is the definition of a 32 bits
counter from the basic unsigned integer {\tt uint32}.

\begin{verbatim}
 typedef counter32 {
        type uint32;
        description
           "The counter32 type represents...
        reference
           "RFC 2578 (STD 58)";
    }
\end{verbatim}

New  types can  be used  in  data nodes  and in  other {\tt  typedef}.
Depending on the base type  used in a {\tt typedef}, some restrictions
can be  added like  a range  restriction on numerical  values or  as a
string  pattern on  string derived  types. When  defining a  new type,
restrictions must  only restrict the value  set of the  base type. The
new type is a sub-type of the base type.

\subsection{Grouping and Uses}

\y\ provides a reusability concept  with {\tt grouping} and {\tt uses}
statements. A  grouping is a  set of definitions (leafs  and construct
nodes, typedef, grouping\ldots) that  can be used in other definitions
with the {\tt uses} statement.  For example below is the definition of
the grouping  {\tt address} with two  leaf nodes and its  usage in the
{\tt http-container} container.

\noindent
\begin{tabular}{lr}
\begin{minipage}{.5\textwidth}
\begin{verbatim}

grouping address {
    leaf ip {
      type bits (32);
    }
    leaf port {
      type uint32;
    }
}
\end{verbatim}
\end{minipage}
&
\begin{minipage}{.5\textwidth}
\begin{verbatim}
container http-server {
  leaf name { 
    type string; 
  }
  uses address;
}
\end{verbatim}
\end{minipage}
\end{tabular}

This construct is equivalent to :

\noindent
\begin{verbatim}

container http-server {
  leaf name { 
    type string; 
  }
  leaf ip {
    type bits (32);
  }
  leaf port {
    type uint32;
  }
}
\end{verbatim}

\subsection{Augmenting}

The {\tt augment}  statement contains nodes and is  used to add theses
nodes to  an existing  construct node. In  the specification  below, a
container {\tt  login} contains a leaf  {\tt message} and  a list {\tt
user} having several  leaf nodes (just {\tt name}  is shown). The {\tt
augment} statement  refers to the  list {\tt user}  and add to  it the
leaf {\tt uid}.

\noindent
\begin{tabular}{lr}
\begin{minipage}{.5\textwidth}
\begin{verbatim}

  container login {
    leaf message {
      type string;
      }
    list user {
      key ``name'';
      leaf name { 
         type string;
      }
      ...
    }
\end{verbatim}
\end{minipage}
&
\begin{minipage}{.5\textwidth}
\begin{verbatim}
augment login/user {
  leaf uid {
    type uint16;
  }
}
\end{verbatim}
\end{minipage}
\end{tabular}

Note that augmenting is not the  same as grouping. Grouping is used to
reduce the  size of  a specification by  using several times  the same
construct  while  augmenting  allows  to  add  nodes  to  an  existing
one.  Augmenting  is useful  when  an  equimement has  vendor-specific
parameters added to standard ones.

\subsection{Rpc}

As  a  \nc\  agent  can  provide capabilities  with  new  rpc  embeded
operations, \y\ allows the specification of such operation. For example
the {\tt  activate-software} operation below defines data  sended in a
{\tt <rpc>} message with {\tt  input} statement and data returned in a
{\tt <rpc-reply>} with the {\tt ouput} statement.

\begin{verbatim}
rpc activate-software-image {
    input {
       leaf image-name {
         type string;
       }
    }
    output {
       leaf status {
         type string;
       }
    }
}
\end{verbatim}

\subsection{Notification}

A \nc\ agent can send notifications  that can be specified with \y\ by
the  {\tt   notification}  statement.   Nodes  contained   in  a  {\tt
specification} statement  model data sent  by the agent.  Below  is an
example where the index of a failed interface will be sent.

\begin{verbatim} 
notification link-failure {
  description "A link failure has been detected";
  leaf if-index {
      type int32 { range "1 .. max"; }
  }
}
\end{verbatim}

\subsection{Extensions}

\y\ allows  the definition of  new statements when  specific processes
requires  it. The  content of  an extention  is to  be  interpreted by
specific  implementation.   Extensions can  be  used  anywhere in  \y\
specification. In  the example below, the extension  {\tt c-define} is
specified and  used with one name  argument (use of  extension must be
prefixed).

\begin{verbatim}
extension c-define {
         description
           "Takes as argument a name string.
           Makes the code generator use the given name in the
           #define.";
         argument "name";
       }
\end{verbatim}

\begin{verbatim}
 myext:c-define "MY_INTERFACES";
\end{verbatim}




\section{\jyang}

\jyang\ is  a java  parser for \y\  specifications and  an application
programming interface  offering a programmatic  access in java  to \y\
specifications.

\subsection{\y\ Parser}

The    java    parser    is    built   with    JJTree    and    JavaCC
\footnote{https://javacc.dev.java.net}  but  no  external  library  is
needed to use it.

\begin{itemize}
\item
lexical and syntax  checks are conformant to the  ABNF grammar given in
\cite{yang01}
\item
semantical check covers following features :
\begin{itemize}
\item
name scoping and accessibility for typedef, grouping, extension, uses,
leaf and  leaflist, inside  a module  or submodule  and with  imported and
included specifications.
\item
type restriction  for any type (integer,  boolean, bits, float,\ldots)
and typedef
\item
default value and restriction
\item
augment existing node
\item
Xpath for schema node in augment, leaf (of key ref type) and list (for
unique statement)
\end{itemize}
\end{itemize}

\subsection{\jyang\ tool}

\subsubsection{\jyang\ use}

\jyang\ is distributed  as a java jar file  called {\tt jyang.jar} and
configured to be executable. The synoptic is :

\begin{verbatim}
java -jar jyang.jar [-h] [-f format] [-o outputfile] [-p paths] file [file]*
\end{verbatim}

\begin{itemize}
\item
{\tt -h} print the synoptic
\item
{\tt  -f format}  specifies the  format for  a translated  output (yin
format for example)
\item
{\tt -o outputfile} the name of the translated output (standard output
if not given) ignored if no format are given
\item
{\tt -p  paths} a path where  to find other \y\  specifications. It is
needed   if  import  or   include  statements   are  in   the  checked
specification or  if the environement variable {\tt  YANG\_PATH} is not
set.
\item
{\tt file  [file]*} specifies  files containing \y\  specification. It
must be  one specification ({\tt  module} or {\tt submodule}  for each
file.
\end{itemize}

\subsubsection{Errors}

Errors  in  \y\  specifications  are  printed on  the  standard  error
output.  \jyang\ stops  checking at  the first  lexical  or syntaxical
error  but   try  to   check  after  a   first  semantical   error  is
encountered. When such an error is detected the current bloc statement
is escaped and \jyang\ passes to the next statement.

\section{\jyang\ API}

\subsection{UML class diagram}

Following sections  contain UML class  diagrams of the \jyang\  API. UML
classes (abstacts or not) are java classes and UML interfaces are java
interfaces.  Inheritance   relations  are  directly   mapped  to the java
inheritance  mechanism  (we   have  limited  multiple  inheritance  to
interfaces only).

For relationships other than inheritance the API follows theses rules :
\begin{itemize}
\item
when  the cardinality  is {\tt  0-1} there  is a  getter and  a setter
method  with  the name  of  the related  class  in  the other  related
class. For example in figure  \ref{extension} there is a method called
{\tt  getArgument} in the  {\tt YANG\_Extension}  java class  and this
method  returns   an  instance   of  the  {\tt   YANG\_Argument}  java
class. Such method returns {\tt  null} if there is no related instance
(but some relations have no {\tt 0} lower bound and so must not return
null).      There     is     also     a     method     called     {\tt
setArgument(YANG\_Argument)}.
\item
when  the cardinality  is {\tt  0-n} the  getter returns  a  java {\tt
Vector} instance containing related instances. The getter has an extra
's', for  example in  the figure \ref{spec}  there is a  method called
{\tt getLinkages()}  in the  {\tt YANG\_Specification} java  class. If
there is  no related instance, the  method returns an  empty java {\tt
Vector}. For the setter, as it  is often used during parsing, there is
a  method   called  {\tt   add}{\sl  Class-Name}  (for   example  {\tt
addLinkage(YANG\_Linkage}).
\end{itemize}
 
\subsection{\y\ specifications}

The figure  \ref{spec} shows the  top level of classes  and interfaces
hierarchy.  On top is the  YANG\_Specification interface that can be a
YANG\_Module  for  a  yang  module  or a  YANG\_SubModule  for  a  \y\
submodule.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{yspec.eps}
\end{center}
\caption{Module and SubModule}
\label{spec}
\end{figure}

\subsection{Yang body statements}

Data definitions  are in body  statements that can be  extension, type
definition,  grouping,  data  definition,  rpc or  notification.   The
YANG\_Body interface is the common  interface for all bodies in a yang
specification.

\subsection{Bodies}

\subsubsection{Extension statement}
\label{extension:section:global}

An extension  statement (fig.  \ref{extension}) can be  stand alone or
could contains  other statement  as argument, status,  description and
reference.  Each  of these  statement can occur  at most  once.  Their
description is detailed in section \ref{extension:section:detail}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{extension.eps}
\end{center}
\caption{Extension statement classes}
\label{extension}
\end{figure}

\subsubsection{TypeDef statement}
\label{typedef:section:global}

A  typedef  statement  (fig.    \ref{typedef})  must  contain  a  type
statement  and can  contain  units, default,  status, description  and
reference statement.  Each of these  statement can occur at most once.
Their description is detailed in section \ref{typedef:section:detail}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{typedef.eps}
\end{center}
\caption{TypeDef statement classes}
\label{typedef}
\end{figure}

\subsubsection{Grouping statement}
\label{grouping:section:global}

A grouping statement (fig.  \ref{grouping})  can be stand alone or can
contain status,  description and reference statements.   Each of these
statements can occur at most one time. A grouping statement can also
contains  several  other  grouping,  typedef and  datadef  statements.
Their       description       is       detailed      in       section
\ref{grouping:section:detail}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{grouping.eps}
\end{center}
\caption{Grouping statement classes}
\label{grouping}
\end{figure}

\subsubsection{DataDef statement}
\label{datadef:section:global}

A datadef  statement (fig. \ref{datadef}) is either  a leaf, leaflist,
list, choice,  anyxml, uses or augment  statement. Their description is
detailed in section \ref{datadef:section:detail}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{datadef.eps}
\end{center}
\caption{DataDef statement classes}
\label{datadef}
\end{figure}

\subsubsection{Rpc statement}

A rpc  statement (fig.  \ref{rpc}) can be  stand alone or  can contain
status, description, reference, input  and output statements.  Each of
these statements  can occur  at most once.   A rpc statement  can also
contain several other grouping, typedef and datadef statements.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{rpc.eps}
\end{center}
\caption{Rpc statement classes}
\label{rpc}
\end{figure}

\subsubsection{Notification statement}

A  notification  statement (fig.  \ref{notification})  could be  stand
alone or  could contains status, description  and reference statement.
Each of these statement could  occurs at most one time. A notification
statement  could also  contains  several other  grouping, typedef  and
datadef statements.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{notification.eps}
\end{center}
\caption{Notification statement classes}
\label{notification}
\end{figure}

\subsection{Extension detail}
\label{extension:section:detail}

This section refers  to the section \ref{extension:section:global}. It
details all statements that could occurs in an extension statement.

\subsubsection{Argument statement}

An  argument (fig.   \ref{argument}) is  composed of  at most  one yin
statement. A yin  statement could contains either the  ``true'' or the
``false'' string.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{argument.eps}
\end{center}
\caption{Argument statement classes}
\label{argument}
\end{figure}

There is no more syntax checking needed by other extension
substatements (description, status and reference).

\subsection{Typedef detail}
\label{typedef:section:detail}

This  section refers to  the section  \ref{typedef:section:global}. It
details all statement that could occurs in a typedef statement.

\subsubsection{Type statement}
\label{type:section:global}

 A  type (fig.  \ref{type}) is  composed of  either one  or  more enum
 statement or only one of the specification or restriction statement.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{type.eps}
\end{center}
\caption{Type statement classes}
\label{type}
\end{figure}

There  is   no  more  syntax   checking  needed  by   other  typedef
substatements  (description, status, default  and units).  Default and
units statements are subject to semantical checking.

\subsection{Grouping detail}
\label{grouping:section:detail}

This section  refers to the  section \ref{grouping:section:global}. It
does not  details any statement  as status, description  and reference
does  not need more  syntax checking  and typedef  is detailed  in the
section  \ref{typedef:section:detail}.   The  data-def  statement  are
detailed on the section \ref{datadef:section:detail}.

\subsection{Data def detail}
\label{datadef:section:detail}

This  section refers to  the section  \ref{datadef:section:global}. It
details statements that could be a data-def statement.

\subsubsection{Container statement}

A  container  (fig.  \ref{container})  could  contains  several  must,
typedef,  grouping and data-def  statement. Presence,  config, status,
description and reference statement are optional.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{container.eps}
\end{center}
\caption{Container statement classes}
\label{container}
\end{figure}

\subsubsection{Leaf statement}

A leaf (fig. \ref{leaf}) must contains one type statement (see section
\ref{type:section:global}),  several must  statement.  Units, default,
config, mandatory, status, reference and description are optional.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{leaf.eps}
\end{center}
\caption{Leaf statement classes}
\label{leaf}
\end{figure}

\subsubsection{Leaf List statement}

A leaf  list (fig.  \ref{leaflist})  must contains one  type statement
(see  section   \ref{type:section:global}),  several  must  statement.
Units, default,  config, min element, max  element, mandatory, status,
reference and description are optional.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{leaflist.eps}
\end{center}
\caption{Leaf list statement classes}
\label{leaflist}
\end{figure}

\subsubsection{List statement}

A list (fig. \ref{list})  could contains several must, unique, typedef
and  grouping  statements and  must  contains  at  least one  data-def
statement.  Key,   min  element,  max   element,  ordered-by,  status,
description and reference are optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{list.eps}
\end{center}
\caption{List statement classes}
\label{list}
\end{figure}

\subsubsection{Choice statement}
\label{cases:section:global}
A choice (fig. \ref{choice}) could contains several short-case or case
statements       that        are       detailed       in       section
\ref{cases:section:detail}.  Default,  mandatory, status,  description
and reference are optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{choice.eps}
\end{center}
\caption{Choice statement classes}
\label{choice}
\end{figure}

\subsubsection{Any-xml statement}

An  any-xml (fig.  \ref{anyxml}) could  contains a  config, mandatory,
status, descrition and reference statement.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{anyxml.eps}
\end{center}
\caption{Any-xml statement classes}
\label{anyxml}
\end{figure}

\subsubsection{Uses statement}
\label{uses:section:global}

An  uses  (fig.  \ref{uses})  could  contains  a status,  description,
reference  and refinement  statement.  The refinement  is detailed  in
section \ref{refinement:section:detail}
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{uses.eps}
\end{center}
\caption{Uses statement classes}
\label{uses}
\end{figure}

\subsubsection{Augment statement}

An augment (fig. \ref{augment}) could contains at least one datadef or
case statement  or one  input or output  statement. It depends  on the
augmented node. When, status, description and reference statements are
optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{augment.eps}
\end{center}
\caption{Augment statement classes}
\label{augment}
\end{figure}

\subsection{Case and Short Case statements}
\label{cases:section:detail}

Case and short case use are described in section \ref{cases:section:global}.

\subsubsection{Case statement}
\label{casedatadef:section:global}

A  case  (fig.    \ref{case})  could  contains  several  case-data-def
statements.     Status,      description     and     reference     are
optionals.      Case-data-def     is      detailed      in     section
\ref{casedatadef:section:detail}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{case.eps}
\end{center}
\caption{Case statement classes}
\label{case}
\end{figure}

\subsubsection{Short Case statement}
A short case (fig. \ref{shortcase}) could be either a container, leaf,
leaf-list, list or any-xml statement.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{shortcase.eps}
\end{center}
\caption{Short Case statement classes}
\label{shortcase}
\end{figure}


\subsubsection{Case Data Def statement}
\label{casedatadef:section:detail}

A case data def (fig.  \ref{casedatadef}) could be either a container,
leaf, leaf-list,  list, any-xml, uses or augment  statement. Case data
def use is described in section \ref{casedatadef:section:global}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{casedatadef.eps}
\end{center}
\caption{Case Data Def  statement classes}
\label{casedatadef}
\end{figure}



\subsection{Refinement statement}
\label{refinement:section:detail}

The  refinement (fig.  \ref{refinement})  could be  a refinement  of a
container,  leaf, leaf-list, choice  or any-xml  statement. Refinement
use is described in section \ref{uses:section:global}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{refinement.eps}
\end{center}
\caption{Refinement statement classes}
\label{refinement}
\end{figure}

\subsubsection{Refine Container statement}

A refine container (fig. \ref{refinecontainer}) could contains several
must  and  refinement  statements.  Presence, config,  description  and
reference are optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{refinecontainer.eps}
\end{center}
\caption{Refine Container statement classes}
\label{refinecontainer}
\end{figure}

\subsubsection{Refine Leaf statement}

A  refine leaf  (fig.  \ref{refineleaf}) could  contains several  must
statements.  Default, config, description and reference are optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{refineleaf.eps}
\end{center}
\caption{Refine Leaf statement classes}
\label{refineleaf}
\end{figure}

\subsubsection{Refine Leaf List statement}

A refine leaf list  (fig. \ref{refineleaflist}) could contains several
must  statements. Config,  min-element,  max-element, description  and
reference are optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{refineleaflist.eps}
\end{center}
\caption{Refine Leaf List statement classes}
\label{refineleaflist}
\end{figure}

\subsubsection{Refine List statement}

A refine  list (fig. \ref{refinelist})  ) could contains  several must
and   refinement   statements.   Config,   min-element,   max-element,
description and reference are optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{refinelist.eps}
\end{center}
\caption{Refine List statement classes}
\label{refinelist}
\end{figure}

\subsubsection{Refine Choice statement}

A refine case (fig.  \ref{refinechoice}) could contains several refine
case  statements. Default,  mandatory, description  and  reference are
optionals.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{refinechoice.eps}
\end{center}
\caption{Refine Choice statement classes}
\label{refinechoice}
\end{figure}

\subsubsection{Refine Any-xml statement}

A refine any-xml (fig. \ref{refineanyxml}) optionaly contains a config,
mandatory, description and reference statement.
\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = .3]{refineanyxml.eps}
\end{center}
\caption{Refine Any-xml statement classes}
\label{refineanyxml}
\end{figure}

\subsection{Global view}

The  figure  \ref{global}  shows  all classes  and  their  inheritance
relationships.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale = 1]{SimpleNodeHierarchy.eps}
\end{center}
\caption{YANG Classes and Interfaces}
\label{global}
\end{figure}


\bibliographystyle{plain}
\bibliography{../bibtex/RFC/rfc,../bibtex/RFC/draft,../bibtex/W3C/w3c}
\end{document}
\endinput
%%
%% End of file `squelette-rr.tex'.
