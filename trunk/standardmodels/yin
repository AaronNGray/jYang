<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="AGENTX-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:AGENTX-MIB"/>
  <prefix value="agentx-mib"/>
  <import module="SNMP-FRAMEWORK-MIB">
    <prefix value="snmp-framework"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    AgentX Working Group
    </info>
  </organization>
  <contact>
  <info>
  WG-email:   agentx@dorothy.bmc.com
      Subscribe:  agentx-request@dorothy.bmc.com
      WG-email Archive:  ftp://ftp.peer.com/pub/agentx/archives
      FTP repository:  ftp://ftp.peer.com/pub/agentx
      http://www.ietf.org/html.charters/agentx-charter.html
      
      Chair:      Bob Natale
                  ACE*COMM Corporation
      Email:      bnatale@acecomm.com
      
      WG editor:  Mark Ellison
                  Ellison Software Consulting, Inc.
      Email:      ellison@world.std.com
      
      Co-author:  Lauren Heintz
                  Cisco Systems,
      EMail:      lheintz@cisco.com
      
      Co-author:  Smitha Gudur
                  Independent Consultant
      Email:      sgudur@hotmail.com
    </info>
  </contact>
  <description>
    <text>
      This is the MIB module for the SNMP Agent Extensibility
      Protocol (AgentX).  This MIB module will be implemented by
      the master agent.
    </text>
  </description>
  <revision date="2000-01-10">
    <description>
      <text>
        Initial version published as RFC 2742.
      </text>
    </description>
  </revision>
  <typedef name="AgentxTAddress">
    <type name="binary">
      <length value="0..255"/>
    </type>
    <description>
      <text>
        Denotes a transport service address.  This is identical to
         the TAddress textual convention (SNMPv2-SMI) except that
         zero-length values are permitted.
      </text>
    </description>
  </typedef>

  <container name="agentxGeneral">
    <leaf name="agentxDefaultTimeout">
      <type name="int32">
        <range value="0..255"/>
      </type>
      <units name ="seconds"/>
      <config value="false"/>
      <description>
        <text>
          The default length of time, in seconds, that the master
            agent should allow to elapse after dispatching a message
            to a session before it regards the subagent as not
            responding.  This is a system-wide value that may
            override the timeout value associated with a particular
            session (agentxSessionTimeout) or a particular registered
            MIB region (agentxRegTimeout).  If the associated value of
            agentxSessionTimeout and agentxRegTimeout are zero, or
            impractical in accordance with implementation-specific
            procedure of the master agent, the value represented by
            this object will be the effective timeout value for the
            
            master agent to await a response to a dispatch from a
            given subagent.
        </text>
      </description>
    </leaf>
    <leaf name="agentxMasterAgentXVer">
      <type name="int32">
        <range value="1..255"/>
      </type>
      <config value="false"/>
      <description>
        <text>
          The AgentX protocol version supported by this master agent.
            The current protocol version is 1.  Note that the master agent
            must also allow interaction with earlier version subagents.
        </text>
      </description>
    </leaf>
  </container>

  <container name="agentxConnection">
    <leaf name="agentxConnTableLastChange">
      <type name="yang:timestamp"/>
      <config value="false"/>
      <description>
        <text>
          The value of sysUpTime when the last row creation or deletion
            occurred in the agentxConnectionTable.
        </text>
      </description>
    </leaf>
    <list name="agentxConnectionEntry">
      <key value="agentxConnIndex"/>
      <description>
        <text>
          An agentxConnectionEntry contains information describing a
            single AgentX transport connection.  A connection may be
            
            used to support zero or more AgentX sessions.  An entry is
            created when a new transport connection is established,
            and is destroyed when the transport connection is terminated.
        </text>
      </description>
      <leaf name="agentxConnIndex">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <description>
          <text>
            agentxConnIndex contains the value that uniquely identifies
               an open transport connection used by this master agent
               to provide AgentX service.  Values of this index should
               not be re-used.  The value assigned to a given transport
               connection is constant for the lifetime of that connection.
          </text>
        </description>
      </leaf>
      <leaf name="agentxConnOpenTime">
        <type name="yang:timestamp"/>
        <config value="false"/>
        <description>
          <text>
            The value of sysUpTime when this connection was established
               and, therefore, its value when this entry was added to the table.
          </text>
        </description>
      </leaf>
      <leaf name="agentxConnTransportDomain">
        <type name="smiv2:TDomain"/>
        <config value="false"/>
        <description>
          <text>
            The transport protocol in use for this connection to the
               subagent.
          </text>
        </description>
      </leaf>
      <leaf name="agentxConnTransportAddress">
        <type name="agentx-mib:AgentxTAddress"/>
        <config value="false"/>
        <description>
          <text>
            The transport address of the remote (subagent) end of this
               connection to the master agent.  This object may be zero-length
               for unix-domain sockets (and possibly other types of transport
               addresses) since the subagent need not bind a filename to its
               local socket.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="agentxSession">
    <leaf name="agentxSessionTableLastChange">
      <type name="yang:timestamp"/>
      <config value="false"/>
      <description>
        <text>
          The value of sysUpTime when the last row creation or deletion
            occurred in the agentxSessionTable.
        </text>
      </description>
    </leaf>
    <list name="agentxSessionEntry">
      <key value="agentxConnIndex agentxSessionIndex"/>
      <description>
        <text>
          Information about a single open session between the AgentX
            master agent and a subagent is contained in this entry.  An
            entry is created when a new session is successfully established
            and is destroyed either when the subagent transport connection
            has terminated or when the subagent session is closed.
        </text>
      </description>
      <leaf name="agentxConnIndex">
        <type name="leafref">
          <path value="/agentx-mib:agentxConnection/agentx-mib:agentxConnectionEntry/agentx-mib:agentxConnIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionIndex">
        <type name="uint32">
          <range value="0..4294967295"/>
        </type>
        <description>
          <text>
            A unique index for the subagent session.  It is the same as
               h.sessionID defined in the agentx header.  Note that if
               a subagent's session with the master agent is closed for
               any reason its index should not be re-used.
               A value of zero(0) is specifically allowed in order
               to be compatible with the definition of h.sessionId.
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionObjectID">
        <type name="yang:object-identifier"/>
        <config value="false"/>
        <description>
          <text>
            This is taken from the o.id field of the agentx-Open-PDU.
               This attribute will report a value of '0.0' for subagents
               not supporting the notion of an AgentX session object
               identifier.
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            A textual description of the session.  This is analogous to
               sysDescr defined in the SNMPv2-MIB in RFC 1907 [19] and is
               taken from the o.descr field of the agentx-Open-PDU.
               This attribute will report a zero-length string value for
               subagents not supporting the notion of a session description.
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionAdminStatus">
        <type name="enumeration">
          <enum name="up">
            <value value="1"/>
          </enum>
          <enum name="down">
            <value value="2"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The administrative (desired) status of the session.  Setting
               the value to 'down(2)' closes the subagent session (with c.reason
               set to 'reasonByManager').
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionOpenTime">
        <type name="yang:timestamp"/>
        <config value="false"/>
        <description>
          <text>
            The value of sysUpTime when this session was opened and,
               therefore, its value when this entry was added to the table.
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionAgentXVer">
        <type name="int32">
          <range value="1..255"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The version of the AgentX protocol supported by the
               session.  This must be less than or equal to the value of
               agentxMasterAgentXVer.
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionTimeout">
        <type name="int32">
          <range value="0..255"/>
        </type>
        <units name ="seconds"/>
        <config value="false"/>
        <description>
          <text>
            The length of time, in seconds, that a master agent should
               allow to elapse after dispatching a message to this session
               before it regards the subagent as not responding.  This value
               is taken from the o.timeout field of the agentx-Open-PDU.
               This is a session-specific value that may be overridden by
               values associated with the specific registered MIB regions
               (see agentxRegTimeout). A value of zero(0) indicates that
               the master agent's default timeout value should be used
               
               (see agentxDefaultTimeout).
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="agentxRegistration">
    <leaf name="agentxRegistrationTableLastChange">
      <type name="yang:timestamp"/>
      <config value="false"/>
      <description>
        <text>
          The value of sysUpTime when the last row creation or deletion
            occurred in the agentxRegistrationTable.
        </text>
      </description>
    </leaf>
    <list name="agentxRegistrationEntry">
      <key value="agentxConnIndex agentxSessionIndex agentxRegIndex"/>
      <description>
        <text>
          Contains information for a single registered region.  An
            entry is created when a session  successfully registers a
            region and is destroyed for any of three reasons: this region
            is unregistered by the session, the session is closed,
            or the subagent connection is closed.
        </text>
      </description>
      <leaf name="agentxConnIndex">
        <type name="leafref">
          <path value="/agentx-mib:agentxConnection/agentx-mib:agentxConnectionEntry/agentx-mib:agentxConnIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="agentxSessionIndex">
        <type name="leafref">
          <path value="/agentx-mib:agentxSession/agentx-mib:agentxSessionEntry/agentx-mib:agentxSessionIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegIndex">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <description>
          <text>
            agentxRegIndex uniquely identifies a registration entry.
               This value is constant for the lifetime of an entry.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegContext">
        <type name="binary"/>
        <config value="false"/>
        <description>
          <text>
            The context in which the session supports the objects in this
               region.  A zero-length context indicates the default context.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegStart">
        <type name="yang:object-identifier"/>
        <config value="false"/>
        <description>
          <text>
            The starting OBJECT IDENTIFIER of this registration entry.  The
               session identified by agentxSessionIndex implements objects
               starting at this value (inclusive).  Note that this value could
               identify an object type, an object instance, or a partial object
               instance.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegRangeSubId">
        <type name="uint32"/>
        <config value="false"/>
        <description>
          <text>
            agentxRegRangeSubId is used to specify the range.  This is
               taken from r.region_subid in the registration PDU.  If the value
               of this object is zero, no range is specified.  If it is non-zero,
               it identifies the `nth' sub-identifier in r.region for which
               this entry's agentxRegUpperBound value is substituted in the
               OID for purposes of defining the region's upper bound.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegUpperBound">
        <type name="uint32"/>
        <config value="false"/>
        <description>
          <text>
            agentxRegUpperBound represents the upper-bound sub-identifier in
               a registration.  This is taken from the r.upper_bound in the
               registration PDU.  If agentxRegRangeSubid (r.region_subid) is
               zero, this value is also zero and is not used to define an upper
               bound for this registration.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegPriority">
        <type name="uint32"/>
        <config value="false"/>
        <description>
          <text>
            The registration priority.  Lower values have higher priority.
               This value is taken from r.priority in the register PDU.
               Sessions should use the value of 127 for r.priority if a
               default value is desired.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegTimeout">
        <type name="int32">
          <range value="0..255"/>
        </type>
        <units name ="seconds"/>
        <config value="false"/>
        <description>
          <text>
            The timeout value, in seconds, for responses to
               requests associated with this registered MIB region.
               A value of zero(0) indicates the default value (indicated
               by by agentxSessionTimeout or agentxDefaultTimeout) is to
               be used.  This value is taken from the r.timeout field of
               the agentx-Register-PDU.
          </text>
        </description>
      </leaf>
      <leaf name="agentxRegInstance">
        <type name="smiv2:TruthValue"/>
        <config value="false"/>
        <description>
          <text>
            The value of agentxRegInstance is `true' for
               registrations for which the INSTANCE_REGISTRATION
               was set, and is `false' for all other registrations.
          </text>
        </description>
      </leaf>
    </list>
  </container>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="DIFFSERV-CONFIG-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:DIFFSERV-CONFIG-MIB"/>
  <prefix value="diffserv-config"/>
  <import module="SNMP-FRAMEWORK-MIB">
    <prefix value="snmp-framework"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    SNMPCONF WG
    </info>
  </organization>
  <contact>
  <info>
  SNMPCONF Working Group
      http://www.ietf.org/html.charters/snmpconf-charter.html
      WG mailing list: snmpconf@snmp.com
      
      Editors:
      Harrie Hazewinkel
      I.Net
      via Darwin 85
      20019 - Settimo Milanese (MI)
      Italy
      EMail: harrie@inet.it
      
      David Partain
      Ericsson AB
      P.O. Box 1248
      SE-581 12 Linkoping
      Sweden
      E-mail: David.Partain@ericsson.com
    </info>
  </contact>
  <description>
    <text>
      This MIB module contains differentiated services
      specific managed objects to perform higher-level
      configuration management.  This MIB allows policies
      to use 'templates' to instantiate Differentiated
      Services functional datapath configurations to
      be assigned (associated with an interface and
      direction) when a policy is activated.
      
      Copyright (C) The Internet Society (2004).  This version
      of this MIB module is part of RFC 3747;  see the RFC
      itself for full legal notices.
    </text>
  </description>
  <revision date="2004-01-22">
    <description>
      <text>
        Initial version published as RFC 3747
      </text>
    </description>
  </revision>
  <container name="diffServConfigMIBObjects">
    <list name="diffServConfigEntry">
      <key value="diffServConfigId"/>
      <description>
        <text>
          An entry defining a per-hop-behavior.  Each entry in
            this table combines the various parameters (entries)
            into a specific per-hop-behavior.  Entries in this
            table might be defined by a vendor (pre-configured)
            or defined by a management application.
        </text>
      </description>
      <leaf name="diffServConfigId">
        <type name="snmp-framework:SnmpAdminString">
          <length value="1..116"/>
        </type>
        <description>
          <text>
            A unique id for the per-hop-behavior policy for at
               least the SNMP agent.  For ease of administration the
               value may be unique within an administrative domain,
               but this is not required.
               
               The range of up to 116 octets is chosen to stay within
               the SMI limit of 128 sub-identifiers in an object
               identifier.
          </text>
        </description>
      </leaf>
      <leaf name="diffServConfigDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            A human-readable description to identify this defined
               per-hop-behavior.  Note that this is an SnmpAdminString,
               which permits UTF-8 strings.  An administratively assigned
               identifier for a template that would be unique within
               an administrative domain.  It is up to the management
               applications to agree how these are assigned within the
               administrative domain.  Once a description, such as
               'EF' is assigned, that has a certain set of parameters
               that achieve 'EF' from box to box. Management
               application code or script code can then scan
               the table to find the proper template and then
               assign it.
          </text>
        </description>
      </leaf>
      <leaf name="diffServConfigOwner">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            The owner who created this entry.
          </text>
        </description>
      </leaf>
      <leaf name="diffServConfigLastChange">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when this entry was last changed.
          </text>
        </description>
      </leaf>
      <leaf name="diffServConfigStart">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            The pointer to a functional datapath configuration template as
               set up in the DIFFSERV-MIB.  This RowPointer should
               point to an instance of one of:
                 diffServClfrEntry
                 diffServMeterEntry
                 diffServActionEntry
                 diffServAlgDropEntry
                 diffServQEntry
               
               
               
               
               A value of zeroDotZero in this attribute indicates no
               further Diffserv treatment is performed on traffic of
               this functional datapath.  This also means that the
               template described by this row is not defined.
               
               If the row pointed to does not exist, the treatment
               is as if this attribute contains a value of zeroDotZero.
          </text>
        </description>
        <reference info="Differentiated Services MIB module"/>
      </leaf>
      <leaf name="diffServConfigStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The type of storage used for this row.
               
               Since an entry in this table serves as a starting
               point for a configuration, it is recommended that
               all entries comprising the configuration started by
               diffServConfigStart follow the storage type of this
               entry.  Otherwise, after agent reboots a configuration
               may differ.  It may very well be that the agent is
               not capable of detecting such changes and therefore,
               the management application should verify the correct
               configuration after a reboot.  Rows with a StorageType
               of 'permanent' do not need to allow write access to
               any of the columnar objects in that row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServConfigStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            RowStatus object used for creation and deletion of
               rows in this table.  All writable objects in this row
               may be modified at any time.
          </text>
        </description>
      </leaf>
    </list>
  </container>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="DIFFSERV-DSCP-TC">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:DIFFSERV-DSCP-TC"/>
  <prefix value="diffserv-dscp"/>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IETF Differentiated Services WG
    </info>
  </organization>
  <contact>
  <info>
         Fred Baker
      Cisco Systems
      1121 Via Del Rey
      Santa Barbara, CA 93117, USA
      E-mail: fred@cisco.com
      
      Kwok Ho Chan
      Nortel Networks
      600 Technology Park Drive
      Billerica, MA 01821, USA
      E-mail: khchan@nortelnetworks.com
      
      Andrew Smith
      Harbour Networks
      Jiuling Building
      21 North Xisanhuan Ave.
      Beijing, 100089, PRC
      E-mail: ah_smith@acm.org
      
        Differentiated Services Working Group:
        diffserv@ietf.org
    </info>
  </contact>
  <description>
    <text>
      The Textual Conventions defined in this module should be used
      whenever a Differentiated Services Code Point is used in a MIB.
    </text>
  </description>
  <revision date="2002-05-09">
    <description>
      <text>
        Initial version, published as RFC 3289.
      </text>
    </description>
  </revision>
  <typedef name="Dscp">
    <type name="int32">
      <range value="0..63"/>
    </type>
    <description>
      <text>
        A Differentiated Services Code-Point that may be used for
         marking a traffic stream.
      </text>
    </description>
  </typedef>

  <typedef name="DscpOrAny">
    <type name="int32">
      <range value="-1..63"/>
    </type>
    <description>
      <text>
        The IP header Differentiated Services Code-Point that may be
         
         
         
         used for discriminating among traffic streams. The value -1 is
         used to indicate a wild card i.e. any value.
      </text>
    </description>
  </typedef>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:diffserv-dscp="urn:ietf:params:xml:ns:yang:smiv2:DIFFSERV-DSCP-TC"
        xmlns:if-mib="urn:ietf:params:xml:ns:yang:smiv2:IF-MIB"
        xmlns:inet-address="urn:ietf:params:xml:ns:yang:smiv2:INET-ADDRESS-MIB"
        xmlns:integrated-services="urn:ietf:params:xml:ns:yang:smiv2:INTEGRATED-SERVICES-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="DIFFSERV-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:DIFFSERV-MIB"/>
  <prefix value="diffserv-mib"/>
  <import module="DIFFSERV-DSCP-TC">
    <prefix value="diffserv-dscp"/>
  </import>
  <import module="IF-MIB">
    <prefix value="if-mib"/>
  </import>
  <import module="INET-ADDRESS-MIB">
    <prefix value="inet-address"/>
  </import>
  <import module="INTEGRATED-SERVICES-MIB">
    <prefix value="integrated-services"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF Differentiated Services WG
    </info>
  </organization>
  <contact>
  <info>
         Fred Baker
      Cisco Systems
      1121 Via Del Rey
      Santa Barbara, CA 93117, USA
      E-mail: fred@cisco.com
      
      Kwok Ho Chan
      Nortel Networks
      600 Technology Park Drive
      Billerica, MA 01821, USA
      E-mail: khchan@nortelnetworks.com
      
      Andrew Smith
      Harbour Networks
      Jiuling Building
      
      
      21 North Xisanhuan Ave.
      Beijing, 100089, PRC
      E-mail: ah_smith@acm.org
      
      Differentiated Services Working Group:
      diffserv@ietf.org
    </info>
  </contact>
  <description>
    <text>
      This MIB defines the objects necessary to manage a device that
      uses the Differentiated Services Architecture described in RFC
      2475. The Conceptual Model of a Differentiated Services Router
      provides supporting information on how such a router is modeled.
    </text>
  </description>
  <revision date="2002-02-07">
    <description>
      <text>
        Initial version, published as RFC 3289.
      </text>
    </description>
  </revision>
  <typedef name="IndexInteger">
    <type name="uint32">
      <range value="1..4294967295"/>
    </type>
    <description>
      <text>
        An integer which may be used as a table index.
      </text>
    </description>
  </typedef>

  <typedef name="IndexIntegerNextFree">
    <type name="uint32">
      <range value="0..4294967295"/>
    </type>
    <description>
      <text>
        An integer which may be used as a new Index in a table.
         
         The special value of 0 indicates that no more new entries can be
         created in the relevant table.
         
         When a MIB is used for configuration, an object with this SYNTAX
         always contains a legal value (if non-zero) for an index that is
         not currently used in the relevant table. The Command Generator
         (Network Management Application) reads this variable and uses the
         (non-zero) value read when creating a new row with an SNMP SET.
         When the SET is performed, the Command Responder (agent) must
         determine whether the value is indeed still unused; Two Network
         Management Applications may attempt to create a row
         (configuration entry) simultaneously and use the same value. If
         it is currently unused, the SET succeeds and the Command
         Responder (agent) changes the value of this object, according to
         an implementation-specific algorithm.  If the value is in use,
         
         
         
         however, the SET fails.  The Network Management Application must
         then re-read this variable to obtain a new usable value.
         
         An OBJECT-TYPE definition using this SYNTAX MUST specify the
         relevant table for which the object is providing this
         functionality.
      </text>
    </description>
  </typedef>

  <typedef name="IfDirection">
    <type name="enumeration">
      <enum name="inbound">
        <value value="1"/>
      </enum>
      <enum name="outbound">
        <value value="2"/>
      </enum>
    </type>
    <description>
      <text>
        IfDirection specifies a direction of data travel on an
         interface. 'inbound' traffic is operated on during reception from
         the interface, while 'outbound' traffic is operated on prior to
         transmission on the interface.
      </text>
    </description>
  </typedef>

  <container name="diffServDataPath">
    <list name="diffServDataPathEntry">
      <key value="ifIndex diffServDataPathIfDirection"/>
      <description>
        <text>
          An entry in the data path table indicates the start of a single
            Differentiated Services Functional Data Path in this device.
            
            These are associated with individual interfaces, logical or
            physical, and therefore are instantiated by ifIndex. Therefore,
            the interface index must have been assigned, according to the
            procedures applicable to that, before it can be meaningfully
            used. Generally, this means that the interface must exist.
            
            When diffServDataPathStorage is of type nonVolatile, however,
            this may reflect the configuration for an interface whose ifIndex
            has been assigned but for which the supporting implementation is
            not currently present.
        </text>
      </description>
      <leaf name="ifIndex">
        <type name="leafref">
          <path value="/if-mib:interfaces/if-mib:ifEntry/if-mib:ifIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="diffServDataPathIfDirection">
        <type name="diffserv-mib:IfDirection"/>
        <description>
          <text>
            IfDirection specifies whether the reception or transmission path
               for this interface is in view.
          </text>
        </description>
      </leaf>
      <leaf name="diffServDataPathStart">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This selects the first Differentiated Services Functional Data
               Path Element to handle traffic for this data path. This
               RowPointer should point to an instance of one of:
                 diffServClfrEntry
                 diffServMeterEntry
                 diffServActionEntry
                 diffServAlgDropEntry
                 diffServQEntry
               
               A value of zeroDotZero in this attribute indicates that no
               Differentiated Services treatment is performed on traffic of this
               data path. A pointer with the value zeroDotZero normally
               terminates a functional data path.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServDataPathStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServDataPathStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="diffServClassifier">
    <leaf name="diffServClfrNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServClfrId, or a
            zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServClfrEntry">
      <key value="diffServClfrId"/>
      <description>
        <text>
          An entry in the classifier table describes a single classifier.
            All classifier elements belonging to the same classifier use the
            classifier's diffServClfrId as part of their index.
        </text>
      </description>
      <leaf name="diffServClfrId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the classifier entries.  Managers
               should obtain new values for row creation in this table by
               reading diffServClfrNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
    <leaf name="diffServClfrElementNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServClfrElementId,
            or a zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServClfrElementEntry">
      <key value="diffServClfrId diffServClfrElementId"/>
      <description>
        <text>
          An entry in the classifier element table describes a single
            element of the classifier.
        </text>
      </description>
      <leaf name="diffServClfrId">
        <type name="leafref">
          <path value="/diffserv-mib:diffServClassifier/diffserv-mib:diffServClfrEntry/diffserv-mib:diffServClfrId"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrElementId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Classifier Element entries.
               Managers obtain new values for row creation in this table by
               reading diffServClfrElementNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrElementPrecedence">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The relative order in which classifier elements are applied:
               higher numbers represent classifier element with higher
               precedence.  Classifier elements with the same order must be
               unambiguous i.e. they must define non-overlapping patterns, and
               are considered to be applied simultaneously to the traffic
               stream. Classifier elements with different order may overlap in
               their filters:  the classifier element with the highest order
               that matches is taken.
               
               On a given interface, there must be a complete classifier in
               place at all times in the ingress direction.  This means one or
               more filters must match any possible pattern. There is no such
               
               
               
               requirement in the egress direction.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrElementNext">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This attribute provides one branch of the fan-out functionality
               of a classifier described in the Informal Differentiated Services
               Model section 4.1.
               
               This selects the next Differentiated Services Functional Data
               Path Element to handle traffic for this data path. This
               RowPointer should point to an instance of one of:
                 diffServClfrEntry
                 diffServMeterEntry
                 diffServActionEntry
                 diffServAlgDropEntry
                 diffServQEntry
               
               A value of zeroDotZero in this attribute indicates no further
               Differentiated Services treatment is performed on traffic of this
               data path. The use of zeroDotZero is the normal usage for the
               last functional data path element of the current data path.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrElementSpecific">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            A pointer to a valid entry in another table, filter table, that
               describes the applicable classification parameters, e.g. an entry
               in diffServMultiFieldClfrTable.
               
               The value zeroDotZero is interpreted to match anything not
               matched by another classifier element - only one such entry may
               exist for each classifier.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               
               
               
               becomes inactive by other means, the element is ignored.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrElementStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServClfrElementStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
    <leaf name="diffServMultiFieldClfrNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for
            diffServMultiFieldClfrId, or a zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServMultiFieldClfrEntry">
      <key value="diffServMultiFieldClfrId"/>
      <description>
        <text>
          An IP Multi-field Classifier entry describes a single filter.
        </text>
      </description>
      <leaf name="diffServMultiFieldClfrId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the MultiField Classifier filter
               entries.  Managers obtain new values for row creation in this
               table by reading diffServMultiFieldClfrNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrAddrType">
        <type name="inet-address:InetAddressType"/>
        <config value="true"/>
        <description>
          <text>
            The type of IP address used by this classifier entry.  While
               other types of addresses are defined in the InetAddressType
               
               
               
               textual convention, and DNS names, a classifier can only look at
               packets on the wire. Therefore, this object is limited to IPv4
               and IPv6 addresses.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrDstAddr">
        <type name="inet-address:InetAddress"/>
        <config value="true"/>
        <description>
          <text>
            The IP address to match against the packet's destination IP
               address. This may not be a DNS name, but may be an IPv4 or IPv6
               prefix.  diffServMultiFieldClfrDstPrefixLength indicates the
               number of bits that are relevant.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrDstPrefixLength">
        <type name="inet-address:InetAddressPrefixLength"/>
        <units name ="bits"/>
        <config value="true"/>
        <description>
          <text>
            The length of the CIDR Prefix carried in
               diffServMultiFieldClfrDstAddr. In IPv4 addresses, a length of 0
               indicates a match of any address; a length of 32 indicates a
               match of a single host address, and a length between 0 and 32
               indicates the use of a CIDR Prefix. IPv6 is similar, except that
               prefix lengths range from 0..128.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrSrcAddr">
        <type name="inet-address:InetAddress"/>
        <config value="true"/>
        <description>
          <text>
            The IP address to match against the packet's source IP address.
               This may not be a DNS name, but may be an IPv4 or IPv6 prefix.
               diffServMultiFieldClfrSrcPrefixLength indicates the number of
               bits that are relevant.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrSrcPrefixLength">
        <type name="inet-address:InetAddressPrefixLength"/>
        <units name ="bits"/>
        <config value="true"/>
        <description>
          <text>
            The length of the CIDR Prefix carried in
               diffServMultiFieldClfrSrcAddr. In IPv4 addresses, a length of 0
               indicates a match of any address; a length of 32 indicates a
               match of a single host address, and a length between 0 and 32
               indicates the use of a CIDR Prefix. IPv6 is similar, except that
               prefix lengths range from 0..128.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrDscp">
        <type name="diffserv-dscp:DscpOrAny"/>
        <config value="true"/>
        <description>
          <text>
            The value that the DSCP in the packet must have to match this
               entry. A value of -1 indicates that a specific DSCP value has not
               been defined and thus all DSCP values are considered a match.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrFlowId">
        <type name="uint32">
          <range value="0..1048575"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The flow identifier in an IPv6 header.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrProtocol">
        <type name="uint32">
          <range value="0..255"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The IP protocol to match against the IPv4 protocol number or the
               IPv6 Next- Header number in the packet. A value of 255 means
               match all.  Note the protocol number of 255 is reserved by IANA,
               and Next-Header number of 0 is used in IPv6.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrDstL4PortMin">
        <type name="inet-address:InetPortNumber"/>
        <config value="true"/>
        <description>
          <text>
            The minimum value that the layer-4 destination port number in
               the packet must have in order to match this classifier entry.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrDstL4PortMax">
        <type name="inet-address:InetPortNumber"/>
        <config value="true"/>
        <description>
          <text>
            The maximum value that the layer-4 destination port number in
               the packet must have in order to match this classifier entry.
               This value must be equal to or greater than the value specified
               for this entry in diffServMultiFieldClfrDstL4PortMin.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrSrcL4PortMin">
        <type name="inet-address:InetPortNumber"/>
        <config value="true"/>
        <description>
          <text>
            The minimum value that the layer-4 source port number in the
               packet must have in order to match this classifier entry.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrSrcL4PortMax">
        <type name="inet-address:InetPortNumber"/>
        <config value="true"/>
        <description>
          <text>
            The maximum value that the layer-4 source port number in the
               packet must have in order to match this classifier entry. This
               value must be equal to or greater than the value specified for
               this entry in diffServMultiFieldClfrSrcL4PortMin.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMultiFieldClfrStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="diffServMeter">
    <leaf name="diffServMeterNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServMeterId, or a
            zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServMeterEntry">
      <key value="diffServMeterId"/>
      <description>
        <text>
          An entry in the meter table describes a single conformance level
            of a meter.
        </text>
      </description>
      <leaf name="diffServMeterId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Meter entries.  Managers obtain new
               values for row creation in this table by reading
               diffServMeterNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMeterSucceedNext">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            If the traffic does conform, this selects the next
               Differentiated Services Functional Data Path element to handle
               traffic for this data path. This RowPointer should point to an
               instance of one of:
                 diffServClfrEntry
                 diffServMeterEntry
                 diffServActionEntry
                 diffServAlgDropEntry
                 diffServQEntry
               
               A value of zeroDotZero in this attribute indicates that no
               further Differentiated Services treatment is performed on traffic
               of this data path. The use of zeroDotZero is the normal usage for
               the last functional data path element of the current data path.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMeterFailNext">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            If the traffic does not conform, this selects the next
               Differentiated Services Functional Data Path element to handle
               traffic for this data path. This RowPointer should point to an
               instance of one of:
                 diffServClfrEntry
                 diffServMeterEntry
               
               
               
                 diffServActionEntry
                 diffServAlgDropEntry
                 diffServQEntry
               
               A value of zeroDotZero in this attribute indicates no further
               Differentiated Services treatment is performed on traffic of this
               data path. The use of zeroDotZero is the normal usage for the
               last functional data path element of the current data path.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMeterSpecific">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This indicates the behavior of the meter by pointing to an entry
               containing detailed parameters. Note that entries in that
               specific table must be managed explicitly.
               
               For example, diffServMeterSpecific may point to an entry in
               diffServTBParamTable, which contains an instance of a single set
               of Token Bucket parameters.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the meter always succeeds.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMeterStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMeterStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="diffServTBParam">
    <leaf name="diffServTBParamNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServTBParamId, or a
            zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServTBParamEntry">
      <key value="diffServTBParamId"/>
      <description>
        <text>
          An entry that describes a single set of token bucket
            parameters.
        </text>
      </description>
      <leaf name="diffServTBParamId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Token Bucket Parameter entries.
               Managers obtain new values for row creation in this table by
               reading diffServTBParamNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServTBParamType">
        <type name="smiv2:AutonomousType"/>
        <config value="true"/>
        <description>
          <text>
            The Metering algorithm associated with the Token Bucket
               parameters.  zeroDotZero indicates this is unknown.
               
               Standard values for generic algorithms:
               diffServTBParamSimpleTokenBucket, diffServTBParamAvgRate,
               diffServTBParamSrTCMBlind, diffServTBParamSrTCMAware,
               diffServTBParamTrTCMBlind, diffServTBParamTrTCMAware, and
               diffServTBParamTswTCM are specified in this MIB as OBJECT-
               IDENTITYs; additional values may be further specified in other
               MIBs.
          </text>
        </description>
      </leaf>
      <leaf name="diffServTBParamRate">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="kilobits per second"/>
        <config value="true"/>
        <description>
          <text>
            The token-bucket rate, in kilobits per second (kbps). This
               attribute is used for:
               1. CIR in RFC 2697 for srTCM
               2. CIR and PIR in RFC 2698 for trTCM
               3. CTR and PTR in RFC 2859 for TSWTCM
               4. AverageRate in RFC 3290.
          </text>
        </description>
      </leaf>
      <leaf name="diffServTBParamBurstSize">
        <type name="integrated-services:BurstSize"/>
        <units name ="Bytes"/>
        <config value="true"/>
        <description>
          <text>
            The maximum number of bytes in a single transmission burst. This
               attribute is used for:
               1. CBS and EBS in RFC 2697 for srTCM
               2. CBS and PBS in RFC 2698 for trTCM
               3. Burst Size in RFC 3290.
          </text>
        </description>
      </leaf>
      <leaf name="diffServTBParamInterval">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="microseconds"/>
        <config value="true"/>
        <description>
          <text>
            The time interval used with the token bucket.  For:
               1. Average Rate Meter, the Informal Differentiated Services Model
                  section 5.2.1, - Delta.
               2. Simple Token Bucket Meter, the Informal Differentiated
                  Services Model section 5.1, - time interval t.
               3. RFC 2859 TSWTCM, - AVG_INTERVAL.
               4. RFC 2697 srTCM, RFC 2698 trTCM, - token bucket update time
                  interval.
          </text>
        </description>
      </leaf>
      <leaf name="diffServTBParamStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServTBParamStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="diffServAction">
    <leaf name="diffServActionNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServActionId, or a
            zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServActionEntry">
      <key value="diffServActionId"/>
      <description>
        <text>
          Each entry in the action table allows description of one
            specific action to be applied to traffic.
        </text>
      </description>
      <leaf name="diffServActionId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Action entries.  Managers obtain
               new values for row creation in this table by reading
               diffServActionNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServActionInterface">
        <type name="if-mib:InterfaceIndexOrZero"/>
        <config value="true"/>
        <description>
          <text>
            The interface index (value of ifIndex) that this action occurs
               on. This may be derived from the diffServDataPathStartEntry's
               index by extension through the various RowPointers. However, as
               this may be difficult for a network management station, it is
               placed here as well.  If this is indeterminate, the value is
               zero.
               
               This is of especial relevance when reporting the counters which
               may apply to traffic crossing an interface:
                  diffServCountActOctets,
                  diffServCountActPkts,
                  diffServAlgDropOctets,
                  diffServAlgDropPkts,
                  diffServAlgRandomDropOctets, and
                  diffServAlgRandomDropPkts.
               
               It is also especially relevant to the queue and scheduler which
               may be subsequently applied.
          </text>
        </description>
      </leaf>
      <leaf name="diffServActionNext">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This selects the next Differentiated Services Functional Data
               Path Element to handle traffic for this data path. This
               RowPointer should point to an instance of one of:
                 diffServClfrEntry
                 diffServMeterEntry
                 diffServActionEntry
                 diffServAlgDropEntry
                 diffServQEntry
               
               A value of zeroDotZero in this attribute indicates no further
               Differentiated Services treatment is performed on traffic of this
               data path. The use of zeroDotZero is the normal usage for the
               last functional data path element of the current data path.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServActionSpecific">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            A pointer to an object instance providing additional information
               for the type of action indicated by this action table entry.
               
               For the standard actions defined by this MIB module, this should
               point to either a diffServDscpMarkActEntry or a
               diffServCountActEntry. For other actions, it may point to an
               object instance defined in some other MIB.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the Meter should be treated as
               if it were not present.  This may lead to incorrect policy
               behavior.
          </text>
        </description>
      </leaf>
      <leaf name="diffServActionStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServActionStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
    <list name="diffServDscpMarkActEntry">
      <key value="diffServDscpMarkActDscp"/>
      <description>
        <text>
          An entry in the DSCP mark action table that describes a single
            DSCP used for marking.
        </text>
      </description>
      <leaf name="diffServDscpMarkActDscp">
        <type name="diffserv-dscp:Dscp"/>
        <description>
          <text>
            The DSCP that this Action will store into the DSCP field of the
               subject. It is quite possible that the only packets subject to
               this Action are already marked with this DSCP. Note also that
               Differentiated Services processing may result in packet being
               marked on both ingress to a network and on egress from it, and
               that ingress and egress can occur in the same router.
          </text>
        </description>
      </leaf>
    </list>
    <leaf name="diffServCountActNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for
            diffServCountActId, or a zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServCountActEntry">
      <key value="diffServCountActId"/>
      <description>
        <text>
          An entry in the count action table describes a single set of
            traffic counters.
        </text>
      </description>
      <leaf name="diffServCountActId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Count Action entries.  Managers
               obtain new values for row creation in this table by reading
               
               
               
               diffServCountActNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServCountActOctets">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            The number of octets at the Action data path element.
               
               Discontinuities in the value of this counter can occur at re-
               initialization of the management system and at other times as
               indicated by the value of ifCounterDiscontinuityTime on the
               relevant interface.
          </text>
        </description>
      </leaf>
      <leaf name="diffServCountActPkts">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            The number of packets at the Action data path element.
               
               Discontinuities in the value of this counter can occur at re-
               initialization of the management system and at other times as
               indicated by the value of ifCounterDiscontinuityTime on the
               relevant interface.
          </text>
        </description>
      </leaf>
      <leaf name="diffServCountActStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServCountActStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               
               
               
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="diffServAlgDrop">
    <leaf name="diffServAlgDropNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServAlgDropId, or a
            zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServAlgDropEntry">
      <key value="diffServAlgDropId"/>
      <description>
        <text>
          An entry describes a process that drops packets according to
            some algorithm. Further details of the algorithm type are to be
            found in diffServAlgDropType and with more detail parameter entry
            pointed to by diffServAlgDropSpecific when necessary.
        </text>
      </description>
      <leaf name="diffServAlgDropId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Algorithmic Dropper entries.
               Managers obtain new values for row creation in this table by
               reading diffServAlgDropNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropType">
        <type name="enumeration">
          <enum name="other">
            <value value="1"/>
          </enum>
          <enum name="tailDrop">
            <value value="2"/>
          </enum>
          <enum name="headDrop">
            <value value="3"/>
          </enum>
          <enum name="randomDrop">
            <value value="4"/>
          </enum>
          <enum name="alwaysDrop">
            <value value="5"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The type of algorithm used by this dropper. The value other(1)
               requires further specification in some other MIB module.
               
               In the tailDrop(2) algorithm, diffServAlgDropQThreshold
               represents the maximum depth of the queue, pointed to by
               diffServAlgDropQMeasure, beyond which all newly arriving packets
               will be dropped.
               
               In the headDrop(3) algorithm, if a packet arrives when the
               current depth of the queue, pointed to by
               diffServAlgDropQMeasure, is at diffServAlgDropQThreshold, packets
               currently at the head of the queue are dropped to make room for
               the new packet to be enqueued at the tail of the queue.
               
               In the randomDrop(4) algorithm, on packet arrival, an Active
               Queue Management algorithm is executed which may randomly drop a
               packet. This algorithm may be proprietary, and it may drop either
               the arriving packet or another packet in the queue.
               diffServAlgDropSpecific points to a diffServRandomDropEntry that
               describes the algorithm. For this algorithm,
               
               
               
               diffServAlgDropQThreshold is understood to be the absolute
               maximum size of the queue and additional parameters are described
               in diffServRandomDropTable.
               
               The alwaysDrop(5) algorithm is as its name specifies; always
               drop. In this case, the other configuration values in this Entry
               are not meaningful; There is no useful 'next' processing step,
               there is no queue, and parameters describing the queue are not
               useful. Therefore, diffServAlgDropNext, diffServAlgDropMeasure,
               and diffServAlgDropSpecific are all zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropNext">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This selects the next Differentiated Services Functional Data
               Path Element to handle traffic for this data path. This
               RowPointer should point to an instance of one of:
                 diffServClfrEntry
                 diffServMeterEntry
                 diffServActionEntry
                 diffServQEntry
               
               A value of zeroDotZero in this attribute indicates no further
               Differentiated Services treatment is performed on traffic of this
               data path. The use of zeroDotZero is the normal usage for the
               last functional data path element of the current data path.
               
               When diffServAlgDropType is alwaysDrop(5), this object is
               ignored.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropQMeasure">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            Points to an entry in the diffServQTable to indicate the queue
               that a drop algorithm is to monitor when deciding whether to drop
               a packet. If the row pointed to does not exist, the algorithmic
               dropper element is considered inactive.
               
               
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropQThreshold">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="Bytes"/>
        <config value="true"/>
        <description>
          <text>
            A threshold on the depth in bytes of the queue being measured at
               which a trigger is generated to the dropping algorithm, unless
               diffServAlgDropType is alwaysDrop(5) where this object is
               ignored.
               
               For the tailDrop(2) or headDrop(3) algorithms, this represents
               the depth of the queue, pointed to by diffServAlgDropQMeasure, at
               which the drop action will take place. Other algorithms will need
               to define their own semantics for this threshold.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropSpecific">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            Points to a table entry that provides further detail regarding a
               drop algorithm.
               
               Entries with diffServAlgDropType equal to other(1) may have this
               point to a table defined in another MIB module.
               
               Entries with diffServAlgDropType equal to randomDrop(4) must have
               this point to an entry in diffServRandomDropTable.
               
               For all other algorithms specified in this MIB, this should take
               the value zeroDotZero.
               
               The diffServAlgDropType is authoritative for the type of the drop
               algorithm and the specific parameters for the drop algorithm
               needs to be evaluated based on the diffServAlgDropType.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropOctets">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            The number of octets that have been deterministically dropped by
               this drop process.
               
               Discontinuities in the value of this counter can occur at re-
               initialization of the management system and at other times as
               indicated by the value of ifCounterDiscontinuityTime on the
               relevant interface.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropPkts">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            The number of packets that have been deterministically dropped
               by this drop process.
               
               Discontinuities in the value of this counter can occur at re-
               initialization of the management system and at other times as
               indicated by the value of ifCounterDiscontinuityTime on the
               relevant interface.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgRandomDropOctets">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            The number of octets that have been randomly dropped by this
               drop process.  This counter applies, therefore, only to random
               droppers.
               
               Discontinuities in the value of this counter can occur at re-
               initialization of the management system and at other times as
               indicated by the value of ifCounterDiscontinuityTime on the
               relevant interface.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgRandomDropPkts">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            The number of packets that have been randomly dropped by this
               drop process. This counter applies, therefore, only to random
               droppers.
               
               Discontinuities in the value of this counter can occur at re-
               initialization of the management system and at other times as
               indicated by the value of ifCounterDiscontinuityTime on the
               relevant interface.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServAlgDropStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
    <leaf name="diffServRandomDropNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServRandomDropId,
            or a zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServRandomDropEntry">
      <key value="diffServRandomDropId"/>
      <description>
        <text>
          An entry describes a process that drops packets according to a
            random algorithm.
        </text>
      </description>
      <leaf name="diffServRandomDropId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Random Drop entries.  Managers
               obtain new values for row creation in this table by reading
               diffServRandomDropNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropMinThreshBytes">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="bytes"/>
        <config value="true"/>
        <description>
          <text>
            The average queue depth in bytes, beyond which traffic has a
               non-zero probability of being dropped. Changes in this variable
               may or may not be reflected in the reported value of
               diffServRandomDropMinThreshPkts.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropMinThreshPkts">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="packets"/>
        <config value="true"/>
        <description>
          <text>
            The average queue depth in packets, beyond which traffic has a
               non-zero probability of being dropped. Changes in this variable
               may or may not be reflected in the reported value of
               diffServRandomDropMinThreshBytes.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropMaxThreshBytes">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="bytes"/>
        <config value="true"/>
        <description>
          <text>
            The average queue depth beyond which traffic has a probability
               indicated by diffServRandomDropProbMax of being dropped or
               marked. Note that this differs from the physical queue limit,
               which is stored in diffServAlgDropQThreshold. Changes in this
               variable may or may not be reflected in the reported value of
               diffServRandomDropMaxThreshPkts.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropMaxThreshPkts">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="packets"/>
        <config value="true"/>
        <description>
          <text>
            The average queue depth beyond which traffic has a probability
               indicated by diffServRandomDropProbMax of being dropped or
               marked. Note that this differs from the physical queue limit,
               which is stored in diffServAlgDropQThreshold. Changes in this
               variable may or may not be reflected in the reported value of
               diffServRandomDropMaxThreshBytes.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropProbMax">
        <type name="uint32">
          <range value="0..1000"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The worst case random drop probability, expressed in drops per
               thousand packets.
               
               For example, if in the worst case every arriving packet may be
               dropped (100%) for a period, this has the value 1000.
               Alternatively, if in the worst case only one percent (1%) of
               traffic may be dropped, it has the value 10.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropWeight">
        <type name="uint32">
          <range value="0..65536"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The weighting of past history in affecting the Exponentially
               Weighted Moving Average function that calculates the current
               average queue depth.  The equation uses
               diffServRandomDropWeight/65536 as the coefficient for the new
               sample in the equation, and (65536 -
               diffServRandomDropWeight)/65536 as the coefficient of the old
               value.
               
               Implementations may limit the values of diffServRandomDropWeight
               to a subset of the possible range of values, such as powers of
               two. Doing this would facilitate implementation of the
               Exponentially Weighted Moving Average using shift instructions or
               registers.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropSamplingRate">
        <type name="uint32">
          <range value="0..1000000"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The number of times per second the queue is sampled for queue
               average calculation.  A value of zero is used to mean that the
               queue is sampled approximately each time a packet is enqueued (or
               dequeued).
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServRandomDropStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="diffServQueue">
    <leaf name="diffServQNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServQId, or a zero
            to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServQEntry">
      <key value="diffServQId"/>
      <description>
        <text>
          An entry in the Queue Table describes a single queue or class of
            traffic.
        </text>
      </description>
      <leaf name="diffServQId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Queue entries.  Managers obtain new
               values for row creation in this table by reading
               diffServQNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServQNext">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This selects the next Differentiated Services Scheduler.  The
               RowPointer must point to a diffServSchedulerEntry.
               
               A value of zeroDotZero in this attribute indicates an incomplete
               diffServQEntry instance. In such a case, the entry has no
               operational effect, since it has no parameters to give it
               meaning.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServQMinRate">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This RowPointer indicates the diffServMinRateEntry that the
               scheduler, pointed to by diffServQNext, should use to service
               this queue.
               
               If the row pointed to is zeroDotZero, the minimum rate and
               priority is unspecified.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServQMaxRate">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This RowPointer indicates the diffServMaxRateEntry that the
               scheduler, pointed to by diffServQNext, should use to service
               this queue.
               
               If the row pointed to is zeroDotZero, the maximum rate is the
               line speed of the interface.
               
               
               
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServQStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServQStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="diffServScheduler">
    <leaf name="diffServSchedulerNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServSchedulerId, or
            a zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServSchedulerEntry">
      <key value="diffServSchedulerId"/>
      <description>
        <text>
          An entry in the Scheduler Table describing a single instance of
            a scheduling algorithm.
        </text>
      </description>
      <leaf name="diffServSchedulerId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Scheduler entries.  Managers obtain
               new values for row creation in this table by reading
               diffServSchedulerNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServSchedulerNext">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This selects the next Differentiated Services Functional Data
               Path Element to handle traffic for this data path. This normally
               is null (zeroDotZero), or points to a diffServSchedulerEntry or a
               diffServQEntry.
               
               However, this RowPointer may also point to an instance of:
                 diffServClfrEntry,
                 diffServMeterEntry,
                 diffServActionEntry,
                 diffServAlgDropEntry.
               
               It would point another diffServSchedulerEntry when implementing
               multiple scheduler methods for the same data path, such as having
               one set of queues scheduled by WRR and that group participating
               in a priority scheduling system in which other queues compete
               with it in that way.  It might also point to a second scheduler
               in a hierarchical scheduling system.
               
               If the row pointed to is zeroDotZero, no further Differentiated
               Services treatment is performed on traffic of this data path.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServSchedulerMethod">
        <type name="smiv2:AutonomousType"/>
        <config value="true"/>
        <description>
          <text>
            The scheduling algorithm used by this Scheduler. zeroDotZero
               indicates that this is unknown.  Standard values for generic
               algorithms: diffServSchedulerPriority, diffServSchedulerWRR, and
               diffServSchedulerWFQ are specified in this MIB; additional values
               
               
               
               may be further specified in other MIBs.
          </text>
        </description>
      </leaf>
      <leaf name="diffServSchedulerMinRate">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This RowPointer indicates the entry in diffServMinRateTable
               which indicates the priority or minimum output rate from this
               scheduler. This attribute is used only when there is more than
               one level of scheduler.
               
               When it has the value zeroDotZero, it indicates that no minimum
               rate or priority is imposed.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServSchedulerMaxRate">
        <type name="smiv2:RowPointer"/>
        <config value="true"/>
        <description>
          <text>
            This RowPointer indicates the entry in diffServMaxRateTable
               which indicates the maximum output rate from this scheduler.
               When more than one maximum rate applies (eg, when a multi-rate
               shaper is in view), it points to the first of those rate entries.
               This attribute is used only when there is more than one level of
               scheduler.
               
               When it has the value zeroDotZero, it indicates that no maximum
               rate is imposed.
               
               Setting this to point to a target that does not exist results in
               an inconsistentValue error.  If the row pointed to is removed or
               becomes inactive by other means, the treatment is as if this
               attribute contains a value of zeroDotZero.
          </text>
        </description>
      </leaf>
      <leaf name="diffServSchedulerStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServSchedulerStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
    <leaf name="diffServMinRateNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServMinRateId, or a
            zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServMinRateEntry">
      <key value="diffServMinRateId"/>
      <description>
        <text>
          An entry in the Minimum Rate Parameters Table describes a single
            set of scheduling parameters for use by one or more queues or
            schedulers.
        </text>
      </description>
      <leaf name="diffServMinRateId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Scheduler Parameter entries.
               Managers obtain new values for row creation in this table by
               reading diffServMinRateNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMinRatePriority">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The priority of this input to the associated scheduler, relative
               
               
               
               to the scheduler's other inputs. A queue or scheduler with a
               larger numeric value will be served before another with a smaller
               numeric value.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMinRateAbsolute">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="kilobits per second"/>
        <config value="true"/>
        <description>
          <text>
            The minimum absolute rate, in kilobits/sec, that a downstream
               scheduler element should allocate to this queue. If the value is
               zero, then there is effectively no minimum rate guarantee. If the
               value is non-zero, the scheduler will assure the servicing of
               this queue to at least this rate.
               
               Note that this attribute value and that of
               diffServMinRateRelative are coupled: changes to one will affect
               the value of the other. They are linked by the following
               equation, in that setting one will change the other:
               
                 diffServMinRateRelative =
                         (diffServMinRateAbsolute*1000000)/ifSpeed
               
               or, if appropriate:
               
                 diffServMinRateRelative = diffServMinRateAbsolute/ifHighSpeed
          </text>
        </description>
        <reference info="ifSpeed, ifHighSpeed, Interface MIB, RFC 2863"/>
      </leaf>
      <leaf name="diffServMinRateRelative">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The minimum rate that a downstream scheduler element should
               allocate to this queue, relative to the maximum rate of the
               interface as reported by ifSpeed or ifHighSpeed, in units of
               1/1000 of 1. If the value is zero, then there is effectively no
               minimum rate guarantee. If the value is non-zero, the scheduler
               will assure the servicing of this queue to at least this rate.
               
               Note that this attribute value and that of
               diffServMinRateAbsolute are coupled: changes to one will affect
               the value of the other. They are linked by the following
               equation, in that setting one will change the other:
               
               
               
                 diffServMinRateRelative =
                         (diffServMinRateAbsolute*1000000)/ifSpeed
               
               or, if appropriate:
               
                 diffServMinRateRelative = diffServMinRateAbsolute/ifHighSpeed
          </text>
        </description>
        <reference info="ifSpeed, ifHighSpeed, Interface MIB, RFC 2863"/>
      </leaf>
      <leaf name="diffServMinRateStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMinRateStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
    <leaf name="diffServMaxRateNextFree">
      <type name="diffserv-mib:IndexIntegerNextFree"/>
      <config value="false"/>
      <description>
        <text>
          This object contains an unused value for diffServMaxRateId, or a
            zero to indicate that none exist.
        </text>
      </description>
    </leaf>
    <list name="diffServMaxRateEntry">
      <key value="diffServMaxRateId diffServMaxRateLevel"/>
      <description>
        <text>
          An entry in the Maximum Rate Parameter Table describes a single
            set of scheduling parameters for use by one or more queues or
            schedulers.
        </text>
      </description>
      <leaf name="diffServMaxRateId">
        <type name="diffserv-mib:IndexInteger"/>
        <description>
          <text>
            An index that enumerates the Maximum Rate Parameter entries.
               Managers obtain new values for row creation in this table by
               reading diffServMaxRateNextFree.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMaxRateLevel">
        <type name="uint32">
          <range value="1..32"/>
        </type>
        <description>
          <text>
            An index that indicates which level of a multi-rate shaper is
               being given its parameters. A multi-rate shaper has some number
               of rate levels. Frame Relay's dual rate specification refers to a
               'committed' and an 'excess' rate; ATM's dual rate specification
               refers to a 'mean' and a 'peak' rate. This table is generalized
               to support an arbitrary number of rates. The committed or mean
               rate is level 1, the peak rate (if any) is the highest level rate
               configured, and if there are other rates they are distributed in
               monotonically increasing order between them.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMaxRateAbsolute">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <units name ="kilobits per second"/>
        <config value="true"/>
        <description>
          <text>
            The maximum rate in kilobits/sec that a downstream scheduler
               element should allocate to this queue. If the value is zero, then
               there is effectively no maximum rate limit and that the scheduler
               should attempt to be work conserving for this queue. If the value
               is non-zero, the scheduler will limit the servicing of this queue
               to, at most, this rate in a non-work-conserving manner.
               
               Note that this attribute value and that of
               diffServMaxRateRelative are coupled: changes to one will affect
               the value of the other. They are linked by the following
               
               
               
               equation, in that setting one will change the other:
               
                 diffServMaxRateRelative =
                         (diffServMaxRateAbsolute*1000000)/ifSpeed
               
               or, if appropriate:
               
                 diffServMaxRateRelative = diffServMaxRateAbsolute/ifHighSpeed
          </text>
        </description>
        <reference info="ifSpeed, ifHighSpeed, Interface MIB, RFC 2863"/>
      </leaf>
      <leaf name="diffServMaxRateRelative">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The maximum rate that a downstream scheduler element should
               allocate to this queue, relative to the maximum rate of the
               interface as reported by ifSpeed or ifHighSpeed, in units of
               1/1000 of 1. If the value is zero, then there is effectively no
               maximum rate limit and the scheduler should attempt to be work
               conserving for this queue. If the value is non-zero, the
               scheduler will limit the servicing of this queue to, at most,
               this rate in a non-work-conserving manner.
               
               Note that this attribute value and that of
               diffServMaxRateAbsolute are coupled: changes to one will affect
               the value of the other. They are linked by the following
               equation, in that setting one will change the other:
               
                 diffServMaxRateRelative =
                         (diffServMaxRateAbsolute*1000000)/ifSpeed
               
               or, if appropriate:
               
                 diffServMaxRateRelative = diffServMaxRateAbsolute/ifHighSpeed
          </text>
        </description>
        <reference info="ifSpeed, ifHighSpeed, Interface MIB, RFC 2863"/>
      </leaf>
      <leaf name="diffServMaxRateThreshold">
        <type name="integrated-services:BurstSize"/>
        <units name ="Bytes"/>
        <config value="true"/>
        <description>
          <text>
            The number of bytes of queue depth at which the rate of a
               
               
               
               multi-rate scheduler will increase to the next output rate. In
               the last conceptual row for such a shaper, this threshold is
               ignored and by convention is zero.
          </text>
        </description>
        <reference info="Adaptive rate Shaper, RFC 2963"/>
      </leaf>
      <leaf name="diffServMaxRateStorage">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            The storage type for this conceptual row.  Conceptual rows
               having the value 'permanent' need not allow write-access to any
               columnar objects in the row.
          </text>
        </description>
      </leaf>
      <leaf name="diffServMaxRateStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this conceptual row. All writable objects in this
               row may be modified at any time. Setting this variable to
               'destroy' when the MIB contains one or more RowPointers pointing
               to it results in destruction being delayed until the row is no
               longer used.
          </text>
        </description>
      </leaf>
    </list>
  </container>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
        xmlns:snmp-target="urn:ietf:params:xml:ns:yang:smiv2:SNMP-TARGET-MIB"
        xmlns:snmpv2-mib="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="DISMAN-EVENT-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:DISMAN-EVENT-MIB"/>
  <prefix value="disman-event"/>
  <import module="SNMP-FRAMEWORK-MIB">
    <prefix value="snmp-framework"/>
  </import>
  <import module="SNMP-TARGET-MIB">
    <prefix value="snmp-target"/>
  </import>
  <import module="SNMPv2-MIB">
    <prefix value="snmpv2-mib"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF Distributed Management Working Group
    </info>
  </organization>
  <contact>
  <info>
  Ramanathan Kavasseri
      Cisco Systems, Inc.
      170 West Tasman Drive,
      San Jose CA 95134-1706.
      Phone: +1 408 526 4527
      Email: ramk@cisco.com
    </info>
  </contact>
  <description>
    <text>
      The MIB module for defining event triggers and actions
      for network management purposes.
    </text>
  </description>
  <revision date="2000-10-16">
    <description>
      <text>
        This is the initial version of this MIB.
         Published as RFC 2981
      </text>
    </description>
  </revision>
  <typedef name="FailureReason">
    <type name="enumeration">
      <enum name="sampleOverrun">
        <value value="-6"/>
      </enum>
      <enum name="badType">
        <value value="-5"/>
      </enum>
      <enum name="noResponse">
        <value value="-4"/>
      </enum>
      <enum name="destinationUnreachable">
        <value value="-3"/>
      </enum>
      <enum name="badDestination">
        <value value="-2"/>
      </enum>
      <enum name="localResourceLack">
        <value value="-1"/>
      </enum>
      <enum name="noError">
        <value value="0"/>
      </enum>
      <enum name="tooBig">
        <value value="1"/>
      </enum>
      <enum name="noSuchName">
        <value value="2"/>
      </enum>
      <enum name="badValue">
        <value value="3"/>
      </enum>
      <enum name="readOnly">
        <value value="4"/>
      </enum>
      <enum name="genErr">
        <value value="5"/>
      </enum>
      <enum name="noAccess">
        <value value="6"/>
      </enum>
      <enum name="wrongType">
        <value value="7"/>
      </enum>
      <enum name="wrongLength">
        <value value="8"/>
      </enum>
      <enum name="wrongEncoding">
        <value value="9"/>
      </enum>
      <enum name="wrongValue">
        <value value="10"/>
      </enum>
      <enum name="noCreation">
        <value value="11"/>
      </enum>
      <enum name="inconsistentValue">
        <value value="12"/>
      </enum>
      <enum name="resourceUnavailable">
        <value value="13"/>
      </enum>
      <enum name="commitFailed">
        <value value="14"/>
      </enum>
      <enum name="undoFailed">
        <value value="15"/>
      </enum>
      <enum name="authorizationError">
        <value value="16"/>
      </enum>
      <enum name="notWritable">
        <value value="17"/>
      </enum>
      <enum name="inconsistentName">
        <value value="18"/>
      </enum>
    </type>
    <description>
      <text>
        Reasons for failures in an attempt to perform a management
         request.
         
         The first group of errors, numbered less than 0, are related
         to problems in sending the request.  The existence of a
         particular error code here does not imply that all
         implementations are capable of sensing that error and
         
         
         returning that code.
         
         The second group, numbered greater than 0, are copied
         directly from SNMP protocol operations and are intended to
         carry exactly the meanings defined for the protocol as returned
         in an SNMP response.
         
         localResourceLack       some local resource such as memory
                                 lacking or
                                 mteResourceSampleInstanceMaximum
                                 exceeded
         badDestination          unrecognized domain name or otherwise
                                 invalid destination address
         destinationUnreachable  can't get to destination address
         noResponse              no response to SNMP request
         badType                 the data syntax of a retrieved object
                                 as not as expected
         sampleOverrun           another sample attempt occurred before
                                 the previous one completed
      </text>
    </description>
  </typedef>

  <container name="mteResource">
    <leaf name="mteResourceSampleMinimum">
      <type name="int32">
        <range value="1..2147483647"/>
      </type>
      <units name ="seconds"/>
      <config value="true"/>
      <description>
        <text>
          The minimum mteTriggerFrequency this system will
            accept.  A system may use the larger values of this minimum to
            lessen the impact of constant sampling.  For larger
            sampling intervals the system samples less often and
            suffers less overhead.  This object provides a way to enforce
            such lower overhead for all triggers created after it is
            set.
            
            Unless explicitly resource limited, a system's value for
            this object SHOULD be 1, allowing as small as a 1 second
            interval for ongoing trigger sampling.
            
            Changing this value will not invalidate an existing setting
            of mteTriggerFrequency.
        </text>
      </description>
    </leaf>
    <leaf name="mteResourceSampleInstanceMaximum">
      <type name="uint32"/>
      <units name ="instances"/>
      <config value="true"/>
      <description>
        <text>
          The maximum number of instance entries this system will
            support for sampling.
            
            These are the entries that maintain state, one for each
            instance of each sampled object as selected by
            mteTriggerValueID.  Note that wildcarded objects result
            in multiple instances of this state.
            
            A value of 0 indicates no preset limit, that is, the limit
            is dynamic based on system operation and resources.
            
            Unless explicitly resource limited, a system's value for
            this object SHOULD be 0.
            
            Changing this value will not eliminate or inhibit existing
            sample state but could prevent allocation of additional state
            information.
        </text>
      </description>
    </leaf>
    <leaf name="mteResourceSampleInstances">
      <type name="yang:gauge32"/>
      <units name ="instances"/>
      <config value="false"/>
      <description>
        <text>
          The number of currently active instance entries as
            defined for mteResourceSampleInstanceMaximum.
        </text>
      </description>
    </leaf>
    <leaf name="mteResourceSampleInstancesHigh">
      <type name="yang:gauge32"/>
      <units name ="instances"/>
      <config value="false"/>
      <description>
        <text>
          The highest value of mteResourceSampleInstances that has
            occurred since initialization of the management system.
        </text>
      </description>
    </leaf>
    <leaf name="mteResourceSampleInstanceLacks">
      <type name="yang:counter32"/>
      <units name ="instances"/>
      <config value="false"/>
      <description>
        <text>
          The number of times this system could not take a new sample
            because that allocation would have exceeded the limit set by
            mteResourceSampleInstanceMaximum.
        </text>
      </description>
    </leaf>
  </container>

  <container name="mteTrigger">
    <leaf name="mteTriggerFailures">
      <type name="yang:counter32"/>
      <units name ="failures"/>
      <config value="false"/>
      <description>
        <text>
          The number of times an attempt to check for a trigger
            condition has failed.  This counts individually for each
            attempt in a group of targets or each attempt for a
            
            
            wildcarded object.
        </text>
      </description>
    </leaf>
    <list name="mteTriggerEntry">
      <key value="mteOwner mteTriggerName"/>
      <description>
        <text>
          Information about a single trigger.  Applications create and
            delete entries using mteTriggerEntryStatus.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <description>
          <text>
            The owner of this entry. The exact semantics of this
               string are subject to the security policy defined by the
               security administrator.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="1..32"/>
        </type>
        <description>
          <text>
            A locally-unique, administratively assigned name for the
               trigger within the scope of mteOwner.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerComment">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            A description of the trigger's function and use.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerTest">
        <type name="bits">
          <bit name="existence">
            <position value="0"/>
          </bit>
          <bit name="boolean">
            <position value="1"/>
          </bit>
          <bit name="threshold">
            <position value="2"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The type of trigger test to perform.  For 'boolean' and
               'threshold'  tests, the object at mteTriggerValueID MUST
               evaluate to an integer, that is, anything that ends up encoded
               for transmission (that is, in BER, not ASN.1) as an integer.
               
               For 'existence', the specific test is as selected by
               mteTriggerExistenceTest.  When an object appears, vanishes
               or changes value, the trigger fires. If the object's
               appearance caused the trigger firing, the object MUST
               vanish before the trigger can be fired again for it, and
               vice versa. If the trigger fired due to a change in the
               object's value, it will be fired again on every successive
               value change for that object.
               
               For 'boolean', the specific test is as selected by
               mteTriggerBooleanTest.  If the test result is true the trigger
               fires.  The trigger will not fire again until the value has
               become false and come back to true.
               
               For 'threshold' the test works as described below for
               
               
               mteTriggerThresholdStartup, mteTriggerThresholdRising, and
               mteTriggerThresholdFalling.
               
               Note that combining 'boolean' and 'threshold' tests on the
               same object may be somewhat redundant.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerSampleType">
        <type name="enumeration">
          <enum name="absoluteValue">
            <value value="1"/>
          </enum>
          <enum name="deltaValue">
            <value value="2"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The type of sampling to perform.
               
               An 'absoluteValue' sample requires only a single sample to be
               meaningful, and is exactly the value of the object at
               mteTriggerValueID at the sample time.
               
               A 'deltaValue' requires two samples to be meaningful and is
               thus not available for testing until the second and subsequent
               samples after the object at mteTriggerValueID is first found
               to exist.  It is the difference between the two samples.  For
               unsigned values it is always positive, based on unsigned
               arithmetic.  For signed values it can be positive or negative.
               
               For SNMP counters to be meaningful they should be sampled as a
               'deltaValue'.
               
               For 'deltaValue' mteTriggerDeltaTable contains further
               parameters.
               
               If only 'existence' is set in mteTriggerTest this object has
               no meaning.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerValueID">
        <type name="yang:object-identifier"/>
        <config value="true"/>
        <description>
          <text>
            The object identifier of the MIB object to sample to see
               if the trigger should fire.
               
               This may be wildcarded by truncating all or part of the
               instance portion, in which case the value is obtained
               as if with a GetNext function, checking multiple values
               
               
               if they exist.  If such wildcarding is applied,
               mteTriggerValueIDWildcard must be 'true' and if not it must
               be 'false'.
               
               Bad object identifiers or a mismatch between truncating the
               identifier and the value of mteTriggerValueIDWildcard result
               in operation as one would expect when providing the wrong
               identifier to a Get or GetNext operation.  The Get will fail
               or get the wrong object.  The GetNext will indeed get whatever
               is next, proceeding until it runs past the initial part of the
               identifier and perhaps many unintended objects for confusing
               results.  If the value syntax of those objects is not usable,
               that results in a 'badType' error that terminates the scan.
               
               Each instance that fills the wildcard is independent of any
               additional instances, that is, wildcarded objects operate
               as if there were a separate table entry for each instance
               that fills the wildcard without having to actually predict
               all possible instances ahead of time.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerValueIDWildcard">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            Control for whether mteTriggerValueID is to be treated as
               fully-specified or wildcarded, with 'true' indicating wildcard.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerTargetTag">
        <type name="snmp-target:SnmpTagValue"/>
        <config value="true"/>
        <description>
          <text>
            The tag for the target(s) from which to obtain the condition
               for a trigger check.
               
               A length of 0 indicates the local system.  In this case,
               access to the objects indicated by mteTriggerValueID is under
               the security credentials of the requester that set
               mteTriggerEntryStatus to 'active'.  Those credentials are the
               input parameters for isAccessAllowed from the Architecture for
               Describing SNMP Management Frameworks.
               
               Otherwise access rights are checked according to the security
               
               
               parameters resulting from the tag.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerContextName">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            The management context from which to obtain mteTriggerValueID.
               
               This may be wildcarded by leaving characters off the end.  For
               example use 'Repeater' to wildcard to 'Repeater1',
               'Repeater2', 'Repeater-999.87b', and so on.  To indicate such
               wildcarding is intended, mteTriggerContextNameWildcard must
               be 'true'.
               
               Each instance that fills the wildcard is independent of any
               additional instances, that is, wildcarded objects operate
               as if there were a separate table entry for each instance
               that fills the wildcard without having to actually predict
               all possible instances ahead of time.
               
               Operation of this feature assumes that the local system has a
               list of available contexts against which to apply the
               wildcard.  If the objects are being read from the local
               system, this is clearly the system's own list of contexts.
               For a remote system a local version of such a list is not
               defined by any current standard and may not be available, so
               this function MAY not be supported.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerContextNameWildcard">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            Control for whether mteTriggerContextName is to be treated as
               fully-specified or wildcarded, with 'true' indicating wildcard.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerFrequency">
        <type name="uint32"/>
        <units name ="seconds"/>
        <config value="true"/>
        <description>
          <text>
            The number of seconds to wait between trigger samples.  To
               encourage consistency in sampling, the interval is measured
               from the beginning of one check to the beginning of the next
               and the timer is restarted immediately when it expires, not
               when the check completes.
               
               If the next sample begins before the previous one completed the
               system may either attempt to make the check or treat this as an
               error condition with the error 'sampleOverrun'.
               
               A frequency of 0 indicates instantaneous recognition of the
               condition.  This is not possible in many cases, but may
               be supported in cases where it makes sense and the system is
               able to do so.  This feature allows the MIB to be used in
               implementations where such interrupt-driven behavior is
               possible and is not likely to be supported for all MIB objects
               even then since such sampling generally has to be tightly
               integrated into low-level code.
               
               Systems that can support this SHOULD document those cases
               where it can be used.  In cases where it can not, setting this
               object to 0 should be disallowed.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerObjectsOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerObjects, the mteOwner of a group of
               objects from mteObjectsTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerObjects">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteObjectsName of a group of objects from
               mteObjectsTable.  These objects are to be added to any
               Notification resulting from the firing of this trigger.
               
               A list of objects may also be added based on the event or on
               the value of mteTriggerTest.
               
               
               
               A length of 0 indicates no additional objects.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerEnabled">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            A control to allow a trigger to be configured but not used.
               When the value is 'false' the trigger is not sampled.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerEntryStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The control that allows creation and deletion of entries.
               Once made active an entry may not be modified except to
               delete it.
          </text>
        </description>
      </leaf>
    </list>
    <list name="mteTriggerDeltaEntry">
      <key value="mteOwner mteTriggerName"/>
      <description>
        <text>
          Information about a single trigger's delta sampling.  Entries
            automatically exist in this this table for each mteTriggerEntry
            that has mteTriggerSampleType set to 'deltaValue'.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerName">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteTriggerName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerDeltaDiscontinuityID">
        <type name="yang:object-identifier"/>
        <config value="true"/>
        <description>
          <text>
            The OBJECT IDENTIFIER (OID) of a TimeTicks, TimeStamp, or
               DateAndTime object that indicates a discontinuity in the value
               at mteTriggerValueID.
               
               The OID may be for a leaf object (e.g. sysUpTime.0) or may
               be wildcarded to match mteTriggerValueID.
               
               This object supports normal checking for a discontinuity in a
               counter.  Note that if this object does not point to sysUpTime
               discontinuity checking MUST still check sysUpTime for an overall
               discontinuity.
               
               If the object identified is not accessible the sample attempt
               is in error, with the error code as from an SNMP request.
               
               Bad object identifiers or a mismatch between truncating the
               identifier and the value of mteDeltaDiscontinuityIDWildcard
               result in operation as one would expect when providing the
               wrong identifier to a Get operation.  The Get will fail or get
               the wrong object.  If the value syntax of those objects is not
               usable, that results in an error that terminates the sample
               with a 'badType' error code.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerDeltaDiscontinuityIDWildcard">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            Control for whether mteTriggerDeltaDiscontinuityID is to be
               treated as fully-specified or wildcarded, with 'true'
               indicating wildcard. Note that the value of this object will
               be the same as that of the corresponding instance of
               mteTriggerValueIDWildcard when the corresponding
               
               
               mteTriggerSampleType is 'deltaValue'.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerDeltaDiscontinuityIDType">
        <type name="enumeration">
          <enum name="timeTicks">
            <value value="1"/>
          </enum>
          <enum name="timeStamp">
            <value value="2"/>
          </enum>
          <enum name="dateAndTime">
            <value value="3"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The value 'timeTicks' indicates the
               mteTriggerDeltaDiscontinuityID of this row is of syntax
               TimeTicks.  The value 'timeStamp' indicates syntax TimeStamp.
               The value 'dateAndTime' indicates syntax DateAndTime.
          </text>
        </description>
      </leaf>
    </list>
    <list name="mteTriggerExistenceEntry">
      <key value="mteOwner mteTriggerName"/>
      <description>
        <text>
          Information about a single existence trigger.  Entries
            automatically exist in this this table for each mteTriggerEntry
            that has 'existence' set in mteTriggerTest.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerName">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteTriggerName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerExistenceTest">
        <type name="bits">
          <bit name="present">
            <position value="0"/>
          </bit>
          <bit name="absent">
            <position value="1"/>
          </bit>
          <bit name="changed">
            <position value="2"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The type of existence test to perform.  The trigger fires
               when the object at mteTriggerValueID is seen to go from
               present to absent, from absent to present, or to have it's
               value changed, depending on which tests are selected:
               
               present(0) - when this test is selected, the trigger fires
               when the mteTriggerValueID object goes from absent to present.
               
               absent(1)  - when this test is selected, the trigger fires
               when the mteTriggerValueID object goes from present to absent.
               changed(2) - when this test is selected, the trigger fires
               the mteTriggerValueID object value changes.
               
               Once the trigger has fired for either presence or absence it
               will not fire again for that state until the object has been
               to the other state. 
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerExistenceStartup">
        <type name="bits">
          <bit name="present">
            <position value="0"/>
          </bit>
          <bit name="absent">
            <position value="1"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            Control for whether an event may be triggered when this entry
               is first set to 'active' and the test specified by
               mteTriggerExistenceTest is true.  Setting an option causes
               that trigger to fire when its test is true.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerExistenceObjectsOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerExistenceObjects, the mteOwner of a
               group of objects from mteObjectsTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerExistenceObjects">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteObjectsName of a group of objects from
               mteObjectsTable.  These objects are to be added to any
               Notification resulting from the firing of this trigger for
               this test.
               
               A list of objects may also be added based on the overall
               trigger, the event or other settings in mteTriggerTest.
               
               A length of 0 indicates no additional objects.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerExistenceEventOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerExistenceEvent, the mteOwner of an event
               entry from the mteEventTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerExistenceEvent">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteEventName of the event to invoke when mteTriggerType is
               'existence' and this trigger fires.  A length of 0 indicates no
               event.
          </text>
        </description>
      </leaf>
    </list>
    <list name="mteTriggerBooleanEntry">
      <key value="mteOwner mteTriggerName"/>
      <description>
        <text>
          Information about a single boolean trigger.  Entries
            automatically exist in this this table for each mteTriggerEntry
            that has 'boolean' set in mteTriggerTest.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerName">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteTriggerName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerBooleanComparison">
        <type name="enumeration">
          <enum name="unequal">
            <value value="1"/>
          </enum>
          <enum name="equal">
            <value value="2"/>
          </enum>
          <enum name="less">
            <value value="3"/>
          </enum>
          <enum name="lessOrEqual">
            <value value="4"/>
          </enum>
          <enum name="greater">
            <value value="5"/>
          </enum>
          <enum name="greaterOrEqual">
            <value value="6"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The type of boolean comparison to perform.
               
               The value at mteTriggerValueID is compared to
               mteTriggerBooleanValue, so for example if
               mteTriggerBooleanComparison is 'less' the result would be true
               if the value at mteTriggerValueID is less than the value of
               mteTriggerBooleanValue.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerBooleanValue">
        <type name="int32"/>
        <config value="true"/>
        <description>
          <text>
            The value to use for the test specified by
               mteTriggerBooleanTest.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerBooleanStartup">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            Control for whether an event may be triggered when this entry
               is first set to 'active' or a new instance of the object at
               mteTriggerValueID is found and the test specified by
               mteTriggerBooleanComparison is true.  In that case an event is
               triggered if mteTriggerBooleanStartup is 'true'.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerBooleanObjectsOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerBooleanObjects, the mteOwner of a group
               of objects from mteObjectsTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerBooleanObjects">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteObjectsName of a group of objects from
               mteObjectsTable.  These objects are to be added to any
               Notification resulting from the firing of this trigger for
               this test.
               
               A list of objects may also be added based on the overall
               trigger, the event or other settings in mteTriggerTest.
               
               A length of 0 indicates no additional objects.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerBooleanEventOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerBooleanEvent, the mteOwner of an event
               entry from mteEventTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerBooleanEvent">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteEventName of the event to invoke when mteTriggerType is
               'boolean' and this trigger fires.  A length of 0 indicates no
               event.
          </text>
        </description>
      </leaf>
    </list>
    <list name="mteTriggerThresholdEntry">
      <key value="mteOwner mteTriggerName"/>
      <description>
        <text>
          Information about a single threshold trigger.  Entries
            automatically exist in this table for each mteTriggerEntry
            that has 'threshold' set in mteTriggerTest.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerName">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteTriggerName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdStartup">
        <type name="enumeration">
          <enum name="rising">
            <value value="1"/>
          </enum>
          <enum name="falling">
            <value value="2"/>
          </enum>
          <enum name="risingOrFalling">
            <value value="3"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The event that may be triggered when this entry is first
               set to 'active' and a new instance of the object at
               mteTriggerValueID is found.  If the first sample after this
               instance becomes active is greater than or equal to
               mteTriggerThresholdRising and mteTriggerThresholdStartup is
               equal to 'rising' or 'risingOrFalling', then one
               mteTriggerThresholdRisingEvent is triggered for that instance.
               If the first sample after this entry becomes active is less
               than or equal to mteTriggerThresholdFalling and
               mteTriggerThresholdStartup is equal to 'falling' or
               'risingOrFalling', then one mteTriggerThresholdRisingEvent is
               triggered for that instance.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdRising">
        <type name="int32"/>
        <config value="true"/>
        <description>
          <text>
            A threshold value to check against if mteTriggerType is
               'threshold'.
               
               When the current sampled value is greater than or equal to
               this threshold, and the value at the last sampling interval
               was less than this threshold, one
               mteTriggerThresholdRisingEvent is triggered.  That event is
               also triggered if the first sample after this entry becomes
               active is greater than or equal to this threshold and
               mteTriggerThresholdStartup is equal to 'rising' or
               'risingOrFalling'.
               
               After a rising event is generated, another such event is not
               triggered until the sampled value falls below this threshold
               and reaches mteTriggerThresholdFalling.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdFalling">
        <type name="int32"/>
        <config value="true"/>
        <description>
          <text>
            A threshold value to check against if mteTriggerType is
               'threshold'.
               
               When the current sampled value is less than or equal to this
               threshold, and the value at the last sampling interval was
               greater than this threshold, one
               mteTriggerThresholdFallingEvent is triggered.  That event is
               also triggered if the first sample after this entry becomes
               active is less than or equal to this threshold and
               mteTriggerThresholdStartup is equal to 'falling' or
               'risingOrFalling'.
               
               After a falling event is generated, another such event is not
               triggered until the sampled value rises above this threshold
               and reaches mteTriggerThresholdRising.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdDeltaRising">
        <type name="int32"/>
        <config value="true"/>
        <description>
          <text>
            A threshold value to check against if mteTriggerType is
               'threshold'.
               
               When the delta value (difference) between the current sampled
               value (value(n)) and the previous sampled value (value(n-1))
               is greater than or equal to this threshold,
               and the delta value calculated at the last sampling interval
               (i.e. value(n-1) - value(n-2)) was less than this threshold,
               one mteTriggerThresholdDeltaRisingEvent is triggered. That event
               is also triggered if the first delta value calculated after this
               entry becomes active, i.e. value(2) - value(1), where value(1)
               is the first sample taken of that instance, is greater than or
               equal to this threshold.
               
               After a rising event is generated, another such event is not
               triggered until the delta value falls below this threshold and
               reaches mteTriggerThresholdDeltaFalling.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdDeltaFalling">
        <type name="int32"/>
        <config value="true"/>
        <description>
          <text>
            A threshold value to check against if mteTriggerType is
               'threshold'.
               
               When the delta value (difference) between the current sampled
               value (value(n)) and the previous sampled value (value(n-1))
               is less than or equal to this threshold,
               and the delta value calculated at the last sampling interval
               (i.e. value(n-1) - value(n-2)) was greater than this threshold,
               one mteTriggerThresholdDeltaFallingEvent is triggered. That event
               is also triggered if the first delta value calculated after this
               entry becomes active, i.e. value(2) - value(1), where value(1)
               is the first sample taken of that instance, is less than or
               equal to this threshold.
               
               After a falling event is generated, another such event is not
               triggered until the delta value falls below this threshold and
               reaches mteTriggerThresholdDeltaRising.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdObjectsOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerThresholdObjects, the mteOwner of a group
               of objects from mteObjectsTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdObjects">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteObjectsName of a group of objects from
               mteObjectsTable.  These objects are to be added to any
               Notification resulting from the firing of this trigger for
               this test.
               
               A list of objects may also be added based on the overall
               
               
               trigger, the event or other settings in mteTriggerTest.
               
               A length of 0 indicates no additional objects.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdRisingEventOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerThresholdRisingEvent, the mteOwner of an
               event entry from mteEventTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdRisingEvent">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteEventName of the event to invoke when mteTriggerType is
               'threshold' and this trigger fires based on
               mteTriggerThresholdRising.  A length of 0 indicates no event.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdFallingEventOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerThresholdFallingEvent, the mteOwner of an
               event entry from mteEventTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdFallingEvent">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteEventName of the event to invoke when mteTriggerType is
               'threshold' and this trigger fires based on
               mteTriggerThresholdFalling.  A length of 0 indicates no event.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdDeltaRisingEventOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerThresholdDeltaRisingEvent, the mteOwner
               of an event entry from mteEventTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdDeltaRisingEvent">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteEventName of the event to invoke when mteTriggerType is
               'threshold' and this trigger fires based on
               mteTriggerThresholdDeltaRising. A length of 0 indicates
               no event.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdDeltaFallingEventOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteTriggerThresholdDeltaFallingEvent, the mteOwner
               of an event entry from mteEventTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteTriggerThresholdDeltaFallingEvent">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteEventName of the event to invoke when mteTriggerType is
               'threshold' and this trigger fires based on
               mteTriggerThresholdDeltaFalling.  A length of 0 indicates
               no event.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="mteObjects">
    <list name="mteObjectsEntry">
      <key value="mteOwner mteObjectsName mteObjectsIndex"/>
      <description>
        <text>
          A group of objects.  Applications create and delete entries
            using mteObjectsEntryStatus.
            
            When adding objects to a notification they are added in the
            lexical order of their index in this table.  Those associated
            with a trigger come first, then trigger test, then event.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteObjectsName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="1..32"/>
        </type>
        <description>
          <text>
            A locally-unique, administratively assigned name for a group
               of objects.
          </text>
        </description>
      </leaf>
      <leaf name="mteObjectsIndex">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <description>
          <text>
            An arbitrary integer for the purpose of identifying
               individual objects within a mteObjectsName group.
               
               
               Objects within a group are placed in the notification in the
               numerical order of this index.
               
               Groups are placed in the notification in the order of the
               selections for overall trigger, trigger test, and event.
               Within trigger test they are in the same order as the
               numerical values of the bits defined for mteTriggerTest.
               
               Bad object identifiers or a mismatch between truncating the
               identifier and the value of mteDeltaDiscontinuityIDWildcard
               result in operation as one would expect when providing the
               wrong identifier to a Get operation.  The Get will fail or get
               the wrong object.  If the object is not available it is omitted
               from the notification.
          </text>
        </description>
      </leaf>
      <leaf name="mteObjectsID">
        <type name="yang:object-identifier"/>
        <config value="true"/>
        <description>
          <text>
            The object identifier of a MIB object to add to a
               Notification that results from the firing of a trigger.
               
               This may be wildcarded by truncating all or part of the
               instance portion, in which case the instance portion of the
               OID for obtaining this object will be the same as that used
               in obtaining the mteTriggerValueID that fired.  If such
               wildcarding is applied, mteObjectsIDWildcard must be
               'true' and if not it must be 'false'.
               
               Each instance that fills the wildcard is independent of any
               additional instances, that is, wildcarded objects operate
               as if there were a separate table entry for each instance
               that fills the wildcard without having to actually predict
               all possible instances ahead of time.
          </text>
        </description>
      </leaf>
      <leaf name="mteObjectsIDWildcard">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            Control for whether mteObjectsID is to be treated as
               fully-specified or wildcarded, with 'true' indicating wildcard.
          </text>
        </description>
      </leaf>
      <leaf name="mteObjectsEntryStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The control that allows creation and deletion of entries.
               Once made active an entry MAY not be modified except to
               delete it.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="mteEvent">
    <leaf name="mteEventFailures">
      <type name="yang:counter32"/>
      <config value="false"/>
      <description>
        <text>
          The number of times an attempt to invoke an event
            has failed.  This counts individually for each
            attempt in a group of targets or each attempt for a
            wildcarded trigger object.
        </text>
      </description>
    </leaf>
    <list name="mteEventEntry">
      <key value="mteOwner mteEventName"/>
      <description>
        <text>
          Information about a single event.  Applications create and
            delete entries using mteEventEntryStatus.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="1..32"/>
        </type>
        <description>
          <text>
            A locally-unique, administratively assigned name for the
               event.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventComment">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            A description of the event's function and use.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventActions">
        <type name="bits">
          <bit name="notification">
            <position value="0"/>
          </bit>
          <bit name="set">
            <position value="1"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The actions to perform when this event occurs.
               
               For 'notification', Traps and/or Informs are sent according
               to the configuration in the SNMP Notification MIB.
               
               For 'set', an SNMP Set operation is performed according to
               control values in this entry.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventEnabled">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            A control to allow an event to be configured but not used.
               When the value is 'false' the event does not execute even if
               
               
               triggered.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventEntryStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The control that allows creation and deletion of entries.
               Once made active an entry MAY not be modified except to
               delete it.
          </text>
        </description>
      </leaf>
    </list>
    <list name="mteEventNotificationEntry">
      <key value="mteOwner mteEventName"/>
      <description>
        <text>
          Information about a single event's notification.  Entries
            automatically exist in this this table for each mteEventEntry
            that has 'notification' set in mteEventActions.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventName">
        <type name="leafref">
          <path value="/disman-event:mteEvent/disman-event:mteEventEntry/disman-event:mteEventName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventNotification">
        <type name="yang:object-identifier"/>
        <config value="true"/>
        <description>
          <text>
            The object identifier from the NOTIFICATION-TYPE for the
               notification to use if metEventActions has 'notification' set.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventNotificationObjectsOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            To go with mteEventNotificationObjects, the mteOwner of a
               group of objects from mteObjectsTable.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventNotificationObjects">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The mteObjectsName of a group of objects from
               mteObjectsTable if mteEventActions has 'notification' set.
               These objects are to be added to any Notification generated by
               this event.
               
               Objects may also be added based on the trigger that stimulated
               the event.
               
               A length of 0 indicates no additional objects.
          </text>
        </description>
      </leaf>
    </list>
    <list name="mteEventSetEntry">
      <key value="mteOwner mteEventName"/>
      <description>
        <text>
          Information about a single event's set option.  Entries
            automatically exist in this this table for each mteEventEntry
            that has 'set' set in mteEventActions.
        </text>
      </description>
      <leaf name="mteOwner">
        <type name="leafref">
          <path value="/disman-event:mteTrigger/disman-event:mteTriggerEntry/disman-event:mteOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventName">
        <type name="leafref">
          <path value="/disman-event:mteEvent/disman-event:mteEventEntry/disman-event:mteEventName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventSetObject">
        <type name="yang:object-identifier"/>
        <config value="true"/>
        <description>
          <text>
            The object identifier from the MIB object to set if
               mteEventActions has 'set' set.
               
               This object identifier may be wildcarded by leaving
               sub-identifiers off the end, in which case
               nteEventSetObjectWildCard must be 'true'.
               
               If mteEventSetObject is wildcarded the instance used to set the
               object to which it points is the same as the instance from the
               value of mteTriggerValueID that triggered the event.
               
               Each instance that fills the wildcard is independent of any
               additional instances, that is, wildcarded objects operate
               as if there were a separate table entry for each instance
               that fills the wildcard without having to actually predict
               all possible instances ahead of time.
               
               Bad object identifiers or a mismatch between truncating the
               identifier and the value of mteSetObjectWildcard
               result in operation as one would expect when providing the
               wrong identifier to a Set operation.  The Set will fail or set
               the wrong object.  If the value syntax of the destination
               object is not correct, the Set fails with the normal SNMP
               error code.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventSetObjectWildcard">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            Control over whether mteEventSetObject is to be treated as
               fully-specified or wildcarded, with 'true' indicating wildcard
               if mteEventActions has 'set' set.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventSetValue">
        <type name="int32"/>
        <config value="true"/>
        <description>
          <text>
            The value to which to set the object at mteEventSetObject
               if mteEventActions has 'set' set.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventSetTargetTag">
        <type name="snmp-target:SnmpTagValue"/>
        <config value="true"/>
        <description>
          <text>
            The tag for the target(s) at which to set the object at
               mteEventSetObject to mteEventSetValue if mteEventActions
               has 'set' set.
               
               Systems limited to self management MAY reject a non-zero
               length for the value of this object.
               
               A length of 0 indicates the local system.  In this case,
               access to the objects indicated by mteEventSetObject is under
               the security credentials of the requester that set
               mteTriggerEntryStatus to 'active'.  Those credentials are the
               input parameters for isAccessAllowed from the Architecture for
               Describing SNMP Management Frameworks.
               
               Otherwise access rights are checked according to the security
               parameters resulting from the tag.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventSetContextName">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            The management context in which to set mteEventObjectID.
               if mteEventActions has 'set' set.
               
               This may be wildcarded by leaving characters off the end.  To
               indicate such wildcarding mteEventSetContextNameWildcard must
               be 'true'.
               
               If this context name is wildcarded the value used to complete
               the wildcarding of mteTriggerContextName will be appended.
          </text>
        </description>
      </leaf>
      <leaf name="mteEventSetContextNameWildcard">
        <type name="smiv2:TruthValue"/>
        <config value="true"/>
        <description>
          <text>
            Control for whether mteEventSetContextName is to be treated as
               fully-specified or wildcarded, with 'true' indicating wildcard
               if mteEventActions has 'set' set.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="dismanEventMIBNotificationObjects">
    <leaf name="mteHotTrigger">
      <type name="snmp-framework:SnmpAdminString"/>
      <config value="false"/>
      <description>
        <text>
          The name of the trigger causing the notification.
        </text>
      </description>
    </leaf>
    <leaf name="mteHotTargetName">
      <type name="snmp-framework:SnmpAdminString"/>
      <config value="false"/>
      <description>
        <text>
          The SNMP Target MIB's snmpTargetAddrName related to the
            notification.
        </text>
      </description>
    </leaf>
    <leaf name="mteHotContextName">
      <type name="snmp-framework:SnmpAdminString"/>
      <config value="false"/>
      <description>
        <text>
          The context name related to the notification.  This MUST be as
            fully-qualified as possible, including filling in wildcard
            information determined in processing.
        </text>
      </description>
    </leaf>
    <leaf name="mteHotOID">
      <type name="yang:object-identifier"/>
      <config value="false"/>
      <description>
        <text>
          The object identifier of the destination object related to the
            notification.  This MUST be as fully-qualified as possible,
            including filling in wildcard information determined in
            processing.
            
            For a trigger-related notification this is from
            mteTriggerValueID.
            
            For a set failure this is from mteEventSetObject.
        </text>
      </description>
    </leaf>
    <leaf name="mteHotValue">
      <type name="int32"/>
      <config value="false"/>
      <description>
        <text>
          The value of the object at mteTriggerValueID when a
            trigger fired.
        </text>
      </description>
    </leaf>
    <leaf name="mteFailedReason">
      <type name="disman-event:FailureReason"/>
      <config value="false"/>
      <description>
        <text>
          The reason for the failure of an attempt to check for a
            trigger condition or set an object in response to an event.
        </text>
      </description>
    </leaf>
  </container>











</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="DISMAN-SCHEDULE-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:DISMAN-SCHEDULE-MIB"/>
  <prefix value="disman-schedule"/>
  <import module="SNMP-FRAMEWORK-MIB">
    <prefix value="snmp-framework"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF Distributed Management Working Group
    </info>
  </organization>
  <contact>
  <info>
  WG EMail:  disman@dorothy.bmc.com
      Subscribe: disman-request@dorothy.bmc.com
      
      Chair:     Randy Presuhn
                 BMC Software, Inc.
      Postal:    Office 1-3141
                 2141 North First Street
                 San Jose,  California 95131
                 USA
      EMail:     rpresuhn@bmc.com
      Phone:     +1 408 546-1006
      
      Editor:    David B. Levi
                 Nortel Networks
      Postal:    4401 Great America Parkway
                 Santa Clara, CA 95052-8185
                 USA
      EMail:     dlevi@nortelnetworks.com
      Phone:     +1 865 686 0432
      
      Editor:    Juergen Schoenwaelder
                 TU Braunschweig
      Postal:    Bueltenweg 74/75
                 38106 Braunschweig
                 Germany
      EMail:     schoenw@ibr.cs.tu-bs.de
      Phone:     +49 531 391-3283
    </info>
  </contact>
  <description>
    <text>
      This MIB module defines a MIB which provides mechanisms to
      schedule SNMP set operations periodically or at specific
      points in time.
    </text>
  </description>
  <revision date="2002-01-07">
    <description>
      <text>
        Revised version, published as RFC 3231.
         
         This revision introduces a new object type called
         schedTriggers.  Created new conformance and compliance
         statements that take care of the new schedTriggers object.
         
         Several clarifications have been added to remove ambiguities
         that were discovered and reported by implementors.
      </text>
    </description>
  </revision>
  <revision date="1998-11-17">
    <description>
      <text>
        Initial version, published as RFC 2591.
      </text>
    </description>
  </revision>
  <typedef name="SnmpPduErrorStatus">
    <type name="enumeration">
      <enum name="noResponse">
        <value value="-1"/>
      </enum>
      <enum name="noError">
        <value value="0"/>
      </enum>
      <enum name="tooBig">
        <value value="1"/>
      </enum>
      <enum name="noSuchName">
        <value value="2"/>
      </enum>
      <enum name="badValue">
        <value value="3"/>
      </enum>
      <enum name="readOnly">
        <value value="4"/>
      </enum>
      <enum name="genErr">
        <value value="5"/>
      </enum>
      <enum name="noAccess">
        <value value="6"/>
      </enum>
      <enum name="wrongType">
        <value value="7"/>
      </enum>
      <enum name="wrongLength">
        <value value="8"/>
      </enum>
      <enum name="wrongEncoding">
        <value value="9"/>
      </enum>
      <enum name="wrongValue">
        <value value="10"/>
      </enum>
      <enum name="noCreation">
        <value value="11"/>
      </enum>
      <enum name="inconsistentValue">
        <value value="12"/>
      </enum>
      <enum name="resourceUnavailable">
        <value value="13"/>
      </enum>
      <enum name="commitFailed">
        <value value="14"/>
      </enum>
      <enum name="undoFailed">
        <value value="15"/>
      </enum>
      <enum name="authorizationError">
        <value value="16"/>
      </enum>
      <enum name="notWritable">
        <value value="17"/>
      </enum>
      <enum name="inconsistentName">
        <value value="18"/>
      </enum>
    </type>
    <description>
      <text>
        This TC enumerates the SNMPv1 and SNMPv2 PDU error status
         codes as defined in RFC 1157 and RFC 1905.  It also adds a
         pseudo error status code `noResponse' which indicates a
         timeout condition.
      </text>
    </description>
  </typedef>

  <container name="schedObjects">
    <leaf name="schedLocalTime">
      <type name="smiv2:DateAndTime">
        <length value="11"/>
      </type>
      <config value="false"/>
      <description>
        <text>
          The local time used by the scheduler.  Schedules which
            refer to calendar time will use the local time indicated
            by this object.  An implementation MUST return all 11 bytes
            of the DateAndTime textual-convention so that a manager
            may retrieve the offset from GMT time.
        </text>
      </description>
    </leaf>
    <list name="schedEntry">
      <key value="schedOwner schedName"/>
      <description>
        <text>
          An entry describing a particular scheduled action.
            
            Unless noted otherwise, writable objects of this row
            can be modified independent of the current value of
            schedRowStatus, schedAdminStatus and schedOperStatus.
            In particular, it is legal to modify schedInterval
            and the objects in the schedCalendarGroup when
            schedRowStatus is active and schedAdminStatus and
            schedOperStatus are both enabled.
        </text>
      </description>
      <leaf name="schedOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <description>
          <text>
            The owner of this scheduling entry.  The exact semantics of
               this string are subject to the security policy defined by
               
               the security administrator.
          </text>
        </description>
      </leaf>
      <leaf name="schedName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="1..32"/>
        </type>
        <description>
          <text>
            The locally-unique, administratively assigned name for this
               scheduling entry.  This object allows a schedOwner to have
               multiple entries in the schedTable.
          </text>
        </description>
      </leaf>
      <leaf name="schedDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            The human readable description of the purpose of this
               scheduling entry.
          </text>
        </description>
      </leaf>
      <leaf name="schedInterval">
        <type name="uint32"/>
        <units name ="seconds"/>
        <config value="true"/>
        <description>
          <text>
            The number of seconds between two action invocations of
               a periodic scheduler.  Implementations must guarantee
               that action invocations will not occur before at least
               schedInterval seconds have passed.
               
               The scheduler must ignore all periodic schedules that
               have a schedInterval value of 0.  A periodic schedule
               with a scheduling interval of 0 seconds will therefore
               never invoke an action.
               
               Implementations may be forced to delay invocations in the
               face of local constraints.  A scheduled management function
               should therefore not rely on the accuracy provided by the
               scheduler implementation.
               
               Note that implementations which maintain a list of pending
               activations must re-calculate them when this object is
               changed.
          </text>
        </description>
      </leaf>
      <leaf name="schedWeekDay">
        <type name="bits">
          <bit name="sunday">
            <position value="0"/>
          </bit>
          <bit name="monday">
            <position value="1"/>
          </bit>
          <bit name="tuesday">
            <position value="2"/>
          </bit>
          <bit name="wednesday">
            <position value="3"/>
          </bit>
          <bit name="thursday">
            <position value="4"/>
          </bit>
          <bit name="friday">
            <position value="5"/>
          </bit>
          <bit name="saturday">
            <position value="6"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The set of weekdays on which the scheduled action should
               take place.  Setting multiple bits will include several
               weekdays in the set of possible weekdays for this schedule.
               Setting all bits will cause the scheduler to ignore the
               weekday.
               
               Note that implementations which maintain a list of pending
               activations must re-calculate them when this object is
               changed.
          </text>
        </description>
      </leaf>
      <leaf name="schedMonth">
        <type name="bits">
          <bit name="january">
            <position value="0"/>
          </bit>
          <bit name="february">
            <position value="1"/>
          </bit>
          <bit name="march">
            <position value="2"/>
          </bit>
          <bit name="april">
            <position value="3"/>
          </bit>
          <bit name="may">
            <position value="4"/>
          </bit>
          <bit name="june">
            <position value="5"/>
          </bit>
          <bit name="july">
            <position value="6"/>
          </bit>
          <bit name="august">
            <position value="7"/>
          </bit>
          <bit name="september">
            <position value="8"/>
          </bit>
          <bit name="october">
            <position value="9"/>
          </bit>
          <bit name="november">
            <position value="10"/>
          </bit>
          <bit name="december">
            <position value="11"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The set of months during which the scheduled action should
               take place.  Setting multiple bits will include several
               months in the set of possible months for this schedule.
               
               Setting all bits will cause the scheduler to ignore the
               month.
               
               Note that implementations which maintain a list of pending
               activations must re-calculate them when this object is
               changed.
          </text>
        </description>
      </leaf>
      <leaf name="schedDay">
        <type name="bits">
          <bit name="d1">
            <position value="0"/>
          </bit>
          <bit name="d2">
            <position value="1"/>
          </bit>
          <bit name="d3">
            <position value="2"/>
          </bit>
          <bit name="d4">
            <position value="3"/>
          </bit>
          <bit name="d5">
            <position value="4"/>
          </bit>
          <bit name="d6">
            <position value="5"/>
          </bit>
          <bit name="d7">
            <position value="6"/>
          </bit>
          <bit name="d8">
            <position value="7"/>
          </bit>
          <bit name="d9">
            <position value="8"/>
          </bit>
          <bit name="d10">
            <position value="9"/>
          </bit>
          <bit name="d11">
            <position value="10"/>
          </bit>
          <bit name="d12">
            <position value="11"/>
          </bit>
          <bit name="d13">
            <position value="12"/>
          </bit>
          <bit name="d14">
            <position value="13"/>
          </bit>
          <bit name="d15">
            <position value="14"/>
          </bit>
          <bit name="d16">
            <position value="15"/>
          </bit>
          <bit name="d17">
            <position value="16"/>
          </bit>
          <bit name="d18">
            <position value="17"/>
          </bit>
          <bit name="d19">
            <position value="18"/>
          </bit>
          <bit name="d20">
            <position value="19"/>
          </bit>
          <bit name="d21">
            <position value="20"/>
          </bit>
          <bit name="d22">
            <position value="21"/>
          </bit>
          <bit name="d23">
            <position value="22"/>
          </bit>
          <bit name="d24">
            <position value="23"/>
          </bit>
          <bit name="d25">
            <position value="24"/>
          </bit>
          <bit name="d26">
            <position value="25"/>
          </bit>
          <bit name="d27">
            <position value="26"/>
          </bit>
          <bit name="d28">
            <position value="27"/>
          </bit>
          <bit name="d29">
            <position value="28"/>
          </bit>
          <bit name="d30">
            <position value="29"/>
          </bit>
          <bit name="d31">
            <position value="30"/>
          </bit>
          <bit name="r1">
            <position value="31"/>
          </bit>
          <bit name="r2">
            <position value="32"/>
          </bit>
          <bit name="r3">
            <position value="33"/>
          </bit>
          <bit name="r4">
            <position value="34"/>
          </bit>
          <bit name="r5">
            <position value="35"/>
          </bit>
          <bit name="r6">
            <position value="36"/>
          </bit>
          <bit name="r7">
            <position value="37"/>
          </bit>
          <bit name="r8">
            <position value="38"/>
          </bit>
          <bit name="r9">
            <position value="39"/>
          </bit>
          <bit name="r10">
            <position value="40"/>
          </bit>
          <bit name="r11">
            <position value="41"/>
          </bit>
          <bit name="r12">
            <position value="42"/>
          </bit>
          <bit name="r13">
            <position value="43"/>
          </bit>
          <bit name="r14">
            <position value="44"/>
          </bit>
          <bit name="r15">
            <position value="45"/>
          </bit>
          <bit name="r16">
            <position value="46"/>
          </bit>
          <bit name="r17">
            <position value="47"/>
          </bit>
          <bit name="r18">
            <position value="48"/>
          </bit>
          <bit name="r19">
            <position value="49"/>
          </bit>
          <bit name="r20">
            <position value="50"/>
          </bit>
          <bit name="r21">
            <position value="51"/>
          </bit>
          <bit name="r22">
            <position value="52"/>
          </bit>
          <bit name="r23">
            <position value="53"/>
          </bit>
          <bit name="r24">
            <position value="54"/>
          </bit>
          <bit name="r25">
            <position value="55"/>
          </bit>
          <bit name="r26">
            <position value="56"/>
          </bit>
          <bit name="r27">
            <position value="57"/>
          </bit>
          <bit name="r28">
            <position value="58"/>
          </bit>
          <bit name="r29">
            <position value="59"/>
          </bit>
          <bit name="r30">
            <position value="60"/>
          </bit>
          <bit name="r31">
            <position value="61"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The set of days in a month on which a scheduled action
               should take place.  There are two sets of bits one can
               use to define the day within a month:
               
               Enumerations starting with the letter 'd' indicate a
               day in a month relative to the first day of a month.
               The first day of the month can therefore be specified
               by setting the bit d1(0) and d31(30) means the last
               day of a month with 31 days.
               
               Enumerations starting with the letter 'r' indicate a
               day in a month in reverse order, relative to the last
               day of a month.  The last day in the month can therefore
               be specified by setting the bit r1(31) and r31(61) means
               the first day of a month with 31 days.
               
               Setting multiple bits will include several days in the set
               of possible days for this schedule.  Setting all bits will
               cause the scheduler to ignore the day within a month.
               
               Setting all bits starting with the letter 'd' or the
               letter 'r' will also cause the scheduler to ignore the
               day within a month.
               
               Note that implementations which maintain a list of pending
               activations must re-calculate them when this object is
               changed.
          </text>
        </description>
      </leaf>
      <leaf name="schedHour">
        <type name="bits">
          <bit name="h0">
            <position value="0"/>
          </bit>
          <bit name="h1">
            <position value="1"/>
          </bit>
          <bit name="h2">
            <position value="2"/>
          </bit>
          <bit name="h3">
            <position value="3"/>
          </bit>
          <bit name="h4">
            <position value="4"/>
          </bit>
          <bit name="h5">
            <position value="5"/>
          </bit>
          <bit name="h6">
            <position value="6"/>
          </bit>
          <bit name="h7">
            <position value="7"/>
          </bit>
          <bit name="h8">
            <position value="8"/>
          </bit>
          <bit name="h9">
            <position value="9"/>
          </bit>
          <bit name="h10">
            <position value="10"/>
          </bit>
          <bit name="h11">
            <position value="11"/>
          </bit>
          <bit name="h12">
            <position value="12"/>
          </bit>
          <bit name="h13">
            <position value="13"/>
          </bit>
          <bit name="h14">
            <position value="14"/>
          </bit>
          <bit name="h15">
            <position value="15"/>
          </bit>
          <bit name="h16">
            <position value="16"/>
          </bit>
          <bit name="h17">
            <position value="17"/>
          </bit>
          <bit name="h18">
            <position value="18"/>
          </bit>
          <bit name="h19">
            <position value="19"/>
          </bit>
          <bit name="h20">
            <position value="20"/>
          </bit>
          <bit name="h21">
            <position value="21"/>
          </bit>
          <bit name="h22">
            <position value="22"/>
          </bit>
          <bit name="h23">
            <position value="23"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The set of hours within a day during which the scheduled
               action should take place.
               
               Note that implementations which maintain a list of pending
               activations must re-calculate them when this object is
               changed.
          </text>
        </description>
      </leaf>
      <leaf name="schedMinute">
        <type name="bits">
          <bit name="m0">
            <position value="0"/>
          </bit>
          <bit name="m1">
            <position value="1"/>
          </bit>
          <bit name="m2">
            <position value="2"/>
          </bit>
          <bit name="m3">
            <position value="3"/>
          </bit>
          <bit name="m4">
            <position value="4"/>
          </bit>
          <bit name="m5">
            <position value="5"/>
          </bit>
          <bit name="m6">
            <position value="6"/>
          </bit>
          <bit name="m7">
            <position value="7"/>
          </bit>
          <bit name="m8">
            <position value="8"/>
          </bit>
          <bit name="m9">
            <position value="9"/>
          </bit>
          <bit name="m10">
            <position value="10"/>
          </bit>
          <bit name="m11">
            <position value="11"/>
          </bit>
          <bit name="m12">
            <position value="12"/>
          </bit>
          <bit name="m13">
            <position value="13"/>
          </bit>
          <bit name="m14">
            <position value="14"/>
          </bit>
          <bit name="m15">
            <position value="15"/>
          </bit>
          <bit name="m16">
            <position value="16"/>
          </bit>
          <bit name="m17">
            <position value="17"/>
          </bit>
          <bit name="m18">
            <position value="18"/>
          </bit>
          <bit name="m19">
            <position value="19"/>
          </bit>
          <bit name="m20">
            <position value="20"/>
          </bit>
          <bit name="m21">
            <position value="21"/>
          </bit>
          <bit name="m22">
            <position value="22"/>
          </bit>
          <bit name="m23">
            <position value="23"/>
          </bit>
          <bit name="m24">
            <position value="24"/>
          </bit>
          <bit name="m25">
            <position value="25"/>
          </bit>
          <bit name="m26">
            <position value="26"/>
          </bit>
          <bit name="m27">
            <position value="27"/>
          </bit>
          <bit name="m28">
            <position value="28"/>
          </bit>
          <bit name="m29">
            <position value="29"/>
          </bit>
          <bit name="m30">
            <position value="30"/>
          </bit>
          <bit name="m31">
            <position value="31"/>
          </bit>
          <bit name="m32">
            <position value="32"/>
          </bit>
          <bit name="m33">
            <position value="33"/>
          </bit>
          <bit name="m34">
            <position value="34"/>
          </bit>
          <bit name="m35">
            <position value="35"/>
          </bit>
          <bit name="m36">
            <position value="36"/>
          </bit>
          <bit name="m37">
            <position value="37"/>
          </bit>
          <bit name="m38">
            <position value="38"/>
          </bit>
          <bit name="m39">
            <position value="39"/>
          </bit>
          <bit name="m40">
            <position value="40"/>
          </bit>
          <bit name="m41">
            <position value="41"/>
          </bit>
          <bit name="m42">
            <position value="42"/>
          </bit>
          <bit name="m43">
            <position value="43"/>
          </bit>
          <bit name="m44">
            <position value="44"/>
          </bit>
          <bit name="m45">
            <position value="45"/>
          </bit>
          <bit name="m46">
            <position value="46"/>
          </bit>
          <bit name="m47">
            <position value="47"/>
          </bit>
          <bit name="m48">
            <position value="48"/>
          </bit>
          <bit name="m49">
            <position value="49"/>
          </bit>
          <bit name="m50">
            <position value="50"/>
          </bit>
          <bit name="m51">
            <position value="51"/>
          </bit>
          <bit name="m52">
            <position value="52"/>
          </bit>
          <bit name="m53">
            <position value="53"/>
          </bit>
          <bit name="m54">
            <position value="54"/>
          </bit>
          <bit name="m55">
            <position value="55"/>
          </bit>
          <bit name="m56">
            <position value="56"/>
          </bit>
          <bit name="m57">
            <position value="57"/>
          </bit>
          <bit name="m58">
            <position value="58"/>
          </bit>
          <bit name="m59">
            <position value="59"/>
          </bit>
        </type>
        <config value="true"/>
        <description>
          <text>
            The set of minutes within an hour when the scheduled action
               should take place.
               
               Note that implementations which maintain a list of pending
               activations must re-calculate them when this object is
               changed.
          </text>
        </description>
      </leaf>
      <leaf name="schedContextName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The context which contains the local MIB variable pointed
               to by schedVariable.
          </text>
        </description>
      </leaf>
      <leaf name="schedVariable">
        <type name="smiv2:VariablePointer"/>
        <config value="true"/>
        <description>
          <text>
            An object identifier pointing to a local MIB variable
               which resolves to an ASN.1 primitive type of INTEGER.
          </text>
        </description>
      </leaf>
      <leaf name="schedValue">
        <type name="int32"/>
        <config value="true"/>
        <description>
          <text>
            The value which is written to the MIB object pointed to by
               schedVariable when the scheduler invokes an action.  The
               implementation shall enforce the use of access control
               rules when performing the set operation on schedVariable.
               This is accomplished by calling the isAccessAllowed abstract
               service interface as defined in RFC 2571.
               
               Note that an implementation may choose to issue an SNMP Set
               message to the SNMP engine and leave the access control
               decision to the normal message processing procedure.
          </text>
        </description>
      </leaf>
      <leaf name="schedType">
        <type name="enumeration">
          <enum name="periodic">
            <value value="1"/>
          </enum>
          <enum name="calendar">
            <value value="2"/>
          </enum>
          <enum name="oneshot">
            <value value="3"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The type of this schedule.  The value periodic(1) indicates
               that this entry specifies a periodic schedule.  A periodic
               schedule is defined by the value of schedInterval.  The
               values of schedWeekDay, schedMonth, schedDay, schedHour
               and schedMinute are ignored.
               
               The value calendar(2) indicates that this entry describes a
               calendar schedule.  A calendar schedule is defined by the
               values of schedWeekDay, schedMonth, schedDay, schedHour and
               schedMinute.  The value of schedInterval is ignored.  A
               calendar schedule will trigger on all local times that
               satisfy the bits set in schedWeekDay, schedMonth, schedDay,
               schedHour and schedMinute.
               
               The value oneshot(3) indicates that this entry describes a
               one-shot schedule.  A one-shot schedule is similar to a
               calendar schedule with the additional feature that it
               disables itself by changing in the `finished'
               schedOperStatus once the schedule triggers an action.
               
               Note that implementations which maintain a list of pending
               activations must re-calculate them when this object is
               changed.
          </text>
        </description>
      </leaf>
      <leaf name="schedAdminStatus">
        <type name="enumeration">
          <enum name="enabled">
            <value value="1"/>
          </enum>
          <enum name="disabled">
            <value value="2"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The desired state of the schedule.
          </text>
        </description>
      </leaf>
      <leaf name="schedOperStatus">
        <type name="enumeration">
          <enum name="enabled">
            <value value="1"/>
          </enum>
          <enum name="disabled">
            <value value="2"/>
          </enum>
          <enum name="finished">
            <value value="3"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The current operational state of this schedule.  The state
               enabled(1) indicates this entry is active and that the
               scheduler will invoke actions at appropriate times.  The
               disabled(2) state indicates that this entry is currently
               inactive and ignored by the scheduler.  The finished(3)
               state indicates that the schedule has ended.  Schedules
               in the finished(3) state are ignored by the scheduler.
               A one-shot schedule enters the finished(3) state when it
               deactivates itself.
               
               Note that the operational state must not be enabled(1)
               when the schedRowStatus is not active.
          </text>
        </description>
      </leaf>
      <leaf name="schedFailures">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            This variable counts the number of failures while invoking
               the scheduled action.  This counter at most increments once
               for a triggered action.
          </text>
        </description>
      </leaf>
      <leaf name="schedLastFailure">
        <type name="disman-schedule:SnmpPduErrorStatus"/>
        <config value="false"/>
        <description>
          <text>
            The most recent error that occurred during the invocation of
               a scheduled action.  The value noError(0) is returned
               if no errors have occurred yet.
          </text>
        </description>
      </leaf>
      <leaf name="schedLastFailed">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when the most recent failure occurred.
               
               The value '0000000000000000'H is returned if no failure
               occurred since the last re-initialization of the scheduler.
          </text>
        </description>
      </leaf>
      <leaf name="schedStorageType">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            This object defines whether this scheduled action is kept
               in volatile storage and lost upon reboot or if this row is
               backed up by non-volatile or permanent storage.
               
               Conceptual rows having the value `permanent' must allow
               write access to the columnar objects schedDescr,
               schedInterval, schedContextName, schedVariable, schedValue,
               and schedAdminStatus.  If an implementation supports the
               schedCalendarGroup, write access must be also allowed to
               the columnar objects schedWeekDay, schedMonth, schedDay,
               schedHour, schedMinute.
          </text>
        </description>
      </leaf>
      <leaf name="schedRowStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            The status of this scheduled action.  A control that allows
               entries to be added and removed from this table.
               
               Note that the operational state must change to enabled
               when the administrative state is enabled and the row
               status changes to active(1).
               
               Attempts to destroy(6) a row or to set a row
               notInService(2) while the operational state is enabled
               result in inconsistentValue errors.
               
               The value of this object has no effect on whether other
               objects in this conceptual row can be modified.
          </text>
        </description>
      </leaf>
      <leaf name="schedTriggers">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            This variable counts the number of attempts (either
               successful or failed) to invoke the scheduled action.
          </text>
        </description>
      </leaf>
    </list>
  </container>



</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="DISMAN-SCRIPT-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:DISMAN-SCRIPT-MIB"/>
  <prefix value="disman-script"/>
  <import module="SNMP-FRAMEWORK-MIB">
    <prefix value="snmp-framework"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF Distributed Management Working Group
    </info>
  </organization>
  <contact>
  <info>
  WG EMail:  disman@dorothy.bmc.com
      Subscribe: disman-request@dorothy.bmc.com
      
      Chair:     Randy Presuhn
                 BMC Software, Inc.
      
      Postal:    Office 1-3141
                 2141 North First Street
                 San Jose,  California 95131
                 USA
      EMail:     rpresuhn@bmc.com
      Phone:     +1 408 546-1006
      
      Editor:    David B. Levi
                 Nortel Networks
      Postal:    4401 Great America Parkway
                 Santa Clara, CA 95052-8185
                 USA
      EMail:     dlevi@nortelnetworks.com
      Phone:     +1 423 686 0432
      
      Editor:    Juergen Schoenwaelder
                 TU Braunschweig
      Postal:    Bueltenweg 74/75
                 38106 Braunschweig
                 Germany
      EMail:     schoenw@ibr.cs.tu-bs.de
      Phone:     +49 531 391-3283
    </info>
  </contact>
  <description>
    <text>
      This MIB module defines a set of objects that allow to
      delegate management scripts to distributed managers.
    </text>
  </description>
  <revision date="2001-08-21">
    <description>
      <text>
        Revised version, published as RFC 3165.
         
         This revision introduces several new objects: smScriptError,
         smScriptLastChange, smLaunchError, smLaunchLastChange,
         smLaunchRowExpireTime, smRunResultTime, and smRunErrorTime.
         
         The following existing objects were updated: the maximum
         value of smRunLifeTime now disables the timer, an
         autostart value was added to the smLaunchAdminStatus
         object, and a new expired state was added to the
         smLaunchOperStatus object.
         
         A new smScriptException notification has been added to
         support runtime error notifications.
         
         Created new conformance and compliance statements that
         take care of the new objects and notifications.
         
         Clarifications have been added in several places to remove
         ambiguities or contradictions that were discovered and
         reported by implementors.
      </text>
    </description>
  </revision>
  <revision date="1999-02-22">
    <description>
      <text>
        Initial version, published as RFC 2592.
      </text>
    </description>
  </revision>
  <container name="smObjects">
    <list name="smLangEntry">
      <key value="smLangIndex"/>
      <description>
        <text>
          An entry describing a particular language.
        </text>
      </description>
      <leaf name="smLangIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            The locally arbitrary, but unique identifier associated
               with this language entry.
               
               The value is expected to remain constant at least from one
               re-initialization of the entity's network management system
               to the next re-initialization.
               
               Note that the data type and the range of this object must
               be consistent with the definition of smScriptLanguage.
          </text>
        </description>
      </leaf>
      <leaf name="smLangLanguage">
        <type name="yang:object-identifier"/>
        <config value="false"/>
        <description>
          <text>
            The globally unique identification of the language.
          </text>
        </description>
      </leaf>
      <leaf name="smLangVersion">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The version number of the language. The zero-length string
               shall be used if the language does not have a version
               number.
               
               It is suggested that the version number consist of one or
               more decimal numbers separated by dots, where the first
               number is called the major version number.
          </text>
        </description>
      </leaf>
      <leaf name="smLangVendor">
        <type name="yang:object-identifier"/>
        <config value="false"/>
        <description>
          <text>
            An object identifier which identifies the vendor who
               provides the implementation of the language. This object
               identifier SHALL point to the object identifier directly
               below the enterprise object identifier {1 3 6 1 4 1}
               allocated for the vendor. The value must be the object
               identifier {0 0} if the vendor is not known.
          </text>
        </description>
      </leaf>
      <leaf name="smLangRevision">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The version number of the language implementation.
               The value of this object must be an empty string if
               version number of the implementation is unknown.
               
               It is suggested that the value consist of one or more
               decimal numbers separated by dots, where the first
               number is called the major version number.
          </text>
        </description>
      </leaf>
      <leaf name="smLangDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            A textual description of the language.
          </text>
        </description>
      </leaf>
    </list>
    <list name="smExtsnEntry">
      <key value="smLangIndex smExtsnIndex"/>
      <description>
        <text>
          An entry describing a particular language extension.
        </text>
      </description>
      <leaf name="smLangIndex">
        <type name="leafref">
          <path value="/disman-script:smObjects/disman-script:smLangEntry/disman-script:smLangIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="smExtsnIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            The locally arbitrary, but unique identifier associated
               with this language extension entry.
               
               The value is expected to remain constant at least from one
               re-initialization of the entity's network management system
               to the next re-initialization.
          </text>
        </description>
      </leaf>
      <leaf name="smExtsnExtension">
        <type name="yang:object-identifier"/>
        <config value="false"/>
        <description>
          <text>
            The globally unique identification of the language
               extension.
          </text>
        </description>
      </leaf>
      <leaf name="smExtsnVersion">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The version number of the language extension.
               It is suggested that the version number consist of one or
               more decimal numbers separated by dots, where the first
               number is called the major version number.
          </text>
        </description>
      </leaf>
      <leaf name="smExtsnVendor">
        <type name="yang:object-identifier"/>
        <config value="false"/>
        <description>
          <text>
            An object identifier which identifies the vendor who
               provides the implementation of the extension. The
               object identifier value should point to the OID node
               directly below the enterprise OID {1 3 6 1 4 1}
               allocated for the vendor. The value must by the object
               identifier {0 0} if the vendor is not known.
          </text>
        </description>
      </leaf>
      <leaf name="smExtsnRevision">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The version number of the extension implementation.
               The value of this object must be an empty string if
               version number of the implementation is unknown.
               
               It is suggested that the value consist of one or more
               decimal numbers separated by dots, where the first
               number is called the major version number.
          </text>
        </description>
      </leaf>
      <leaf name="smExtsnDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            A textual description of the language extension.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="smScriptObjects">
    <list name="smScriptEntry">
      <key value="smScriptOwner smScriptName"/>
      <description>
        <text>
          An entry describing a particular script. Every script that
            is stored in non-volatile memory is required to appear in
            this script table.
        </text>
      </description>
      <leaf name="smScriptOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <description>
          <text>
            The manager who owns this row in the smScriptTable.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="1..32"/>
        </type>
        <description>
          <text>
            The locally-unique, administratively assigned name for this
               script. This object allows an smScriptOwner to have multiple
               entries in the smScriptTable.
               
               This value of this object may be used to derive the name
               (e.g. a file name) which is used by the Script MIB
               implementation to access the script in non-volatile
               storage. The details of this mapping are implementation
               specific. However, the mapping needs to ensure that scripts
               created by different owners with the same script name do not
               map to the same name in non-volatile storage.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="true"/>
        <description>
          <text>
            A description of the purpose of the script.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptLanguage">
        <type name="int32">
          <range value="0..2147483647"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The value of this object type identifies an entry in the
               smLangTable which is used to execute this script.
               The special value 0 may be used by hard-wired scripts
               that can not be modified and that are executed by
               internal functions.
               
               Set requests to change this object are invalid if the
               value of smScriptOperStatus is `enabled' or `compiling'
               and will result in an inconsistentValue error.
               
               Note that the data type and the range of this object must
               be consistent with the definition of smLangIndex.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptSource">
        <type name="smiv2:DisplayString"/>
        <config value="true"/>
        <description>
          <text>
            This object either contains a reference to the script
               source or an empty string. A reference must be given
               in the form of a Uniform Resource Locator (URL) as
               defined in RFC 2396. The allowed character sets and the
               encoding rules defined in RFC 2396 section 2 apply.
               
               When the smScriptAdminStatus object is set to `enabled',
               the Script MIB implementation will `pull' the script
               source from the URL contained in this object if the URL
               is not empty.
               
               An empty URL indicates that the script source is loaded
               from local storage. The script is read from the smCodeTable
               if the value of smScriptStorageType is volatile. Otherwise,
               the script is read from non-volatile storage.
               
               Note: This document does not mandate implementation of any
               specific URL scheme. An attempt to load a script from a
               nonsupported URL scheme will cause the smScriptOperStatus
               to report an `unknownProtocol' error.
               
               Set requests to change this object are invalid if the
               value of smScriptOperStatus is `enabled', `editing',
               `retrieving' or `compiling' and will result in an
               inconsistentValue error.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptAdminStatus">
        <type name="enumeration">
          <enum name="enabled">
            <value value="1"/>
          </enum>
          <enum name="disabled">
            <value value="2"/>
          </enum>
          <enum name="editing">
            <value value="3"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The value of this object indicates the desired status of
               the script. See the definition of smScriptOperStatus for
               a description of the values.
               
               When the smScriptAdminStatus object is set to `enabled' and
               the smScriptOperStatus is `disabled' or one of the error
               states, the Script MIB implementation will `pull' the script
               source from the URL contained in the smScriptSource object
               if the URL is not empty.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptOperStatus">
        <type name="enumeration">
          <enum name="enabled">
            <value value="1"/>
          </enum>
          <enum name="disabled">
            <value value="2"/>
          </enum>
          <enum name="editing">
            <value value="3"/>
          </enum>
          <enum name="retrieving">
            <value value="4"/>
          </enum>
          <enum name="compiling">
            <value value="5"/>
          </enum>
          <enum name="noSuchScript">
            <value value="6"/>
          </enum>
          <enum name="accessDenied">
            <value value="7"/>
          </enum>
          <enum name="wrongLanguage">
            <value value="8"/>
          </enum>
          <enum name="wrongVersion">
            <value value="9"/>
          </enum>
          <enum name="compilationFailed">
            <value value="10"/>
          </enum>
          <enum name="noResourcesLeft">
            <value value="11"/>
          </enum>
          <enum name="unknownProtocol">
            <value value="12"/>
          </enum>
          <enum name="protocolFailure">
            <value value="13"/>
          </enum>
          <enum name="genericError">
            <value value="14"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The actual status of the script in the runtime system. The
               value of this object is only meaningful when the value of
               the smScriptRowStatus object is `active'.
               
               The smScriptOperStatus object may have the following values:
               
               - `enabled' indicates that the script is available and can
                  be started by a launch table entry.
               
               - `disabled' indicates that the script can not be used.
               
               - `editing' indicates that the script can be modified in the
                 smCodeTable.
               
               - `retrieving' indicates that the script is currently being
                 loaded from non-volatile storage or a remote system.
               
               - `compiling' indicates that the script is currently being
                 compiled by the runtime system.
               
               - `noSuchScript' indicates that the script does not exist
                 at the smScriptSource.
               
               - `accessDenied' indicates that the script can not be loaded
                 from the smScriptSource due to a lack of permissions.
               
               - `wrongLanguage' indicates that the script can not be
                  loaded from the smScriptSource because of a language
                  mismatch.
               
               - `wrongVersion' indicates that the script can not be loaded
                 from the smScriptSource because of a language version
                 mismatch.
               
               - `compilationFailed' indicates that the compilation failed.
               
               - `noResourcesLeft' indicates that the runtime system does
                 not have enough resources to load the script.
               
               - `unknownProtocol' indicates that the script could not be
                 loaded from the smScriptSource because the requested
                 protocol is not supported.
               
               - `protocolFailure' indicates that the script could not be
                 loaded from the smScriptSource because of a protocol
                 failure.
               
               - `genericError' indicates that the script could not be
               
                 loaded due to an error condition not listed above.
               
               The `retrieving' and `compiling' states are transient states
               which will either lead to one of the error states or the
               `enabled' state. The `disabled' and `editing' states are
               administrative states which are only reached by explicit
               management operations.
               
               All launch table entries that refer to this script table
               entry shall have an smLaunchOperStatus value of `disabled'
               when the value of this object is not `enabled'.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptStorageType">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            This object defines whether this row and the script
               controlled by this row are kept in volatile storage and
               lost upon reboot or if this row is backed up by
               non-volatile or permanent storage.
               
               The storage type of this row always complies with the value
               of this entry if the value of the corresponding RowStatus
               object is `active'.
               
               However, the storage type of the script controlled by this
               row may be different, if the value of this entry is
               `non-volatile'. The script controlled by this row is written
               into local non-volatile storage if the following condition
               becomes true:
               
               (a) the URL contained in the smScriptSource object is empty
                   and
               (b) the smScriptStorageType is `nonVolatile'
                   and
               (c) the smScriptOperStatus is `enabled'
               
               Setting this object to `volatile' removes a script from
               non-volatile storage if the script controlled by this row
               has been in non-volatile storage before. Attempts to set
               this object to permanent will always fail with an
               inconsistentValue error.
               
               The value of smScriptStorageType is only meaningful if the
               value of the corresponding RowStatus object is `active'.
               
               If smScriptStorageType has the value permanent(4), then all
               objects whose MAX-ACCESS value is read-create must be
               writable, with the exception of the smScriptStorageType and
               smScriptRowStatus objects, which shall be read-only.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptRowStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            A control that allows entries to be added and removed from
               this table.
               
               Changing the smScriptRowStatus from `active' to
               `notInService' will remove the associated script from the
               runtime system.
               
               Deleting conceptual rows from this table may affect the
               deletion of other resources associated with this row. For
               example, a script stored in non-volatile storage may be
               removed from non-volatile storage.
               
               An entry may not exist in the `active' state unless all
               required objects in the entry have appropriate values. Rows
               that are not complete or not in service are not known by the
               script runtime system.
               
               Attempts to `destroy' a row or to set a row `notInService'
               while the smScriptOperStatus is `enabled' will result in an
               inconsistentValue error.
               
               Attempts to `destroy' a row or to set a row `notInService'
               where the value of the smScriptStorageType object is
               `permanent' or `readOnly' will result in an
               inconsistentValue error.
               
               The value of this object has no effect on whether other
               objects in this conceptual row can be modified.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptError">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            This object contains a descriptive error message if the
               
               transition into the operational status `enabled' failed.
               Implementations must reset the error message to a
               zero-length string when a new attempt to change the
               script status to `enabled' is started.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptLastChange">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when this script table entry was last
               modified. The value '0000000000000000'H is returned if
               the script table entry has not yet been modified.
               
               Note that the resetting of smScriptError is not considered
               a change of the script table entry.
          </text>
        </description>
      </leaf>
    </list>
    <list name="smCodeEntry">
      <key value="smScriptOwner smScriptName smCodeIndex"/>
      <description>
        <text>
          An entry describing a particular fragment of a script.
        </text>
      </description>
      <leaf name="smScriptOwner">
        <type name="leafref">
          <path value="/disman-script:smScriptObjects/disman-script:smScriptEntry/disman-script:smScriptOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="smScriptName">
        <type name="leafref">
          <path value="/disman-script:smScriptObjects/disman-script:smScriptEntry/disman-script:smScriptName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="smCodeIndex">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <description>
          <text>
            The index value identifying this code fragment.
          </text>
        </description>
      </leaf>
      <leaf name="smCodeText">
        <type name="binary">
          <length value="1..1024"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The code that makes up a fragment of a script. The format
               of this code fragment depends on the script language which
               is identified by the associated smScriptLanguage object.
          </text>
        </description>
      </leaf>
      <leaf name="smCodeRowStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            A control that allows entries to be added and removed from
               this table.
               
               The value of this object has no effect on whether other
               objects in this conceptual row can be modified.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="smRunObjects">
    <list name="smLaunchEntry">
      <key value="smLaunchOwner smLaunchName"/>
      <description>
        <text>
          An entry describing a particular executable script.
        </text>
      </description>
      <leaf name="smLaunchOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <description>
          <text>
            The manager who owns this row in the smLaunchTable. Every
               instance of a running script started from a particular entry
               in the smLaunchTable (i.e. entries in the smRunTable) will
               be owned by the same smLaunchOwner used to index the entry
               in the smLaunchTable. This owner is not necessarily the same
               as the owner of the script itself (smLaunchScriptOwner).
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="1..32"/>
        </type>
        <description>
          <text>
            The locally-unique, administratively assigned name for this
               launch table entry. This object allows an smLaunchOwner to
               have multiple entries in the smLaunchTable. The smLaunchName
               is an arbitrary name that must be different from any other
               smLaunchTable entries with the same smLaunchOwner but can be
               the same as other entries in the smLaunchTable with
               different smLaunchOwner values. Note that the value of
               smLaunchName is not related in any way to the name of the
               script being launched.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchScriptOwner">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The value of this object in combination with the value of
               smLaunchScriptName identifies the script that can be
               launched from this smLaunchTable entry. Attempts to write
               this object will fail with an inconsistentValue error if
               the value of smLaunchOperStatus is `enabled'.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchScriptName">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The value of this object in combination with the value of
               the smLaunchScriptOwner identifies the script that can be
               launched from this smLaunchTable entry. The zero-length
               string may be used to point to a non-existing script.
               
               Attempts to write this object will fail with an
               inconsistentValue error if the value of smLaunchOperStatus
               is `enabled'.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchArgument">
        <type name="binary"/>
        <config value="true"/>
        <description>
          <text>
            The argument supplied to the script. When a script is
               invoked, the value of this object is used to initialize
               the smRunArgument object.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchMaxRunning">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The maximum number of concurrently running scripts that may
               be invoked from this entry in the smLaunchTable. Lowering
               the current value of this object does not affect any scripts
               that are already executing.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchMaxCompleted">
        <type name="uint32">
          <range value="1..4294967295"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The maximum number of finished scripts invoked from this
               entry in the smLaunchTable allowed to be retained in the
               smRunTable. Whenever the value of this object is changed
               and whenever a script terminates, entries in the smRunTable
               are deleted if necessary until the number of completed
               scripts is smaller than the value of this object. Scripts
               whose smRunEndTime value indicates the oldest completion
               time are deleted first.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchLifeTime">
        <type name="smiv2:TimeInterval"/>
        <units name ="centi-seconds"/>
        <config value="true"/>
        <description>
          <text>
            The default maximum amount of time a script launched
               from this entry may run. The value of this object is used
               to initialize the smRunLifeTime object when a script is
               launched. Changing the value of an smLaunchLifeTime
               instance does not affect scripts previously launched from
               
               this entry.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchExpireTime">
        <type name="smiv2:TimeInterval"/>
        <units name ="centi-seconds"/>
        <config value="true"/>
        <description>
          <text>
            The default maximum amount of time information about a
               script launched from this entry is kept in the smRunTable
               after the script has completed execution.  The value of
               this object is used to initialize the smRunExpireTime
               object when a script is launched. Changing the value of an
               smLaunchExpireTime instance does not affect scripts
               previously launched from this entry.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchStart">
        <type name="int32">
          <range value="0..2147483647"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            This object is used to start the execution of scripts.
               When retrieved, the value will be the value of smRunIndex
               for the last script that started execution by manipulating
               this object. The value will be zero if no script started
               execution yet.
               
               A script is started by setting this object to an unused
               smRunIndex value. A new row in the smRunTable will be
               created which is indexed by the value supplied by the
               set-request in addition to the value of smLaunchOwner and
               smLaunchName. An unused value can be obtained by reading
               the smLaunchRunIndexNext object.
               
               Setting this object to the special value 0 will start
               the script with a self-generated smRunIndex value. The
               consequence is that the script invoker has no reliable
               way to determine the smRunIndex value for this script
               invocation and that the invoker has therefore no way
               to obtain the results from this script invocation. The
               special value 0 is however useful for scheduled script
               invocations.
               
               If this object is set, the following checks must be
               
               performed:
               
               1) The value of the smLaunchOperStatus object in this
                  entry of the smLaunchTable must be `enabled'.
               2) The values of smLaunchScriptOwner and
                  smLaunchScriptName of this row must identify an
                  existing entry in the smScriptTable.
               3) The value of smScriptOperStatus of this entry must
                  be `enabled'.
               4) The principal performing the set operation must have
                  read access to the script. This must be checked by
                  calling the isAccessAllowed abstract service interface
                  defined in RFC 2271 on the row in the smScriptTable
                  identified by smLaunchScriptOwner and smLaunchScriptName.
                  The isAccessAllowed abstract service interface must be
                  called on all columnar objects in the smScriptTable with
                  a MAX-ACCESS value different than `not-accessible'. The
                  test fails as soon as a call indicates that access is
                  not allowed.
               5) If the value provided by the set operation is not 0,
                  a check must be made that the value is currently not
                  in use. Otherwise, if the value provided by the set
                  operation is 0, a suitable unused value must be
                  generated.
               6) The number of currently executing scripts invoked
                  from this smLaunchTable entry must be less than
                  smLaunchMaxRunning.
               
               Attempts to start a script will fail with an
               inconsistentValue error if one of the checks described
               above fails.
               
               Otherwise, if all checks have been passed, a new entry
               in the smRunTable will be created indexed by smLaunchOwner,
               smLaunchName and the new value for smRunIndex. The value
               of smLaunchArgument will be copied into smRunArgument,
               the value of smLaunchLifeTime will be copied to
               smRunLifeTime, and the value of smLaunchExpireTime
               will be copied to smRunExpireTime.
               
               The smRunStartTime will be set to the current time and
               the smRunState will be set to `initializing' before the
               script execution is initiated in the appropriate runtime
               system.
               
               Note that the data type and the range of this object must
               be consistent with the smRunIndex object. Since this
               object might be written from the scheduling MIB, the
               
               data type Integer32 rather than Unsigned32 is used.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchControl">
        <type name="enumeration">
          <enum name="abort">
            <value value="1"/>
          </enum>
          <enum name="suspend">
            <value value="2"/>
          </enum>
          <enum name="resume">
            <value value="3"/>
          </enum>
          <enum name="nop">
            <value value="4"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            This object is used to request a state change for all
               running scripts in the smRunTable that were started from
               this row in the smLaunchTable.
               
               Setting this object to abort(1), suspend(2) or resume(3)
               will set the smRunControl object of all applicable rows
               in the smRunTable to abort(1), suspend(2) or resume(3)
               respectively. The phrase `applicable rows' means the set of
               rows which were created from this entry in the smLaunchTable
               and whose value of smRunState allows the corresponding
               state change as described in the definition of the
               smRunControl object. Setting this object to nop(4) has no
               effect.
               
               Attempts to set this object lead to an inconsistentValue
               error only if all implicated sets on all the applicable
               rows lead to inconsistentValue errors. It is not allowed
               to return an inconsistentValue error if at least one state
               change on one of the applicable rows was successful.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchAdminStatus">
        <type name="enumeration">
          <enum name="enabled">
            <value value="1"/>
          </enum>
          <enum name="disabled">
            <value value="2"/>
          </enum>
          <enum name="autostart">
            <value value="3"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The value of this object indicates the desired status of
               this launch table entry. The values enabled(1) and
               autostart(3) both indicate that the launch table entry
               
               should transition into the operational enabled(1) state as
               soon as the associated script table entry is enabled(1).
               
               The value autostart(3) further indicates that the script
               is started automatically by conceptually writing the
               value 0 into the associated smLaunchStart object during
               the transition from the `disabled' into the `enabled'
               operational state. This is useful for scripts that are
               to be launched on system start-up.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchOperStatus">
        <type name="enumeration">
          <enum name="enabled">
            <value value="1"/>
          </enum>
          <enum name="disabled">
            <value value="2"/>
          </enum>
          <enum name="expired">
            <value value="3"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The value of this object indicates the actual status of
               this launch table entry.  The smLaunchOperStatus object
               may have the following values:
               
               - `enabled' indicates that the launch table entry is
                 available and can be used to start scripts.
               
               - `disabled' indicates that the launch table entry can
                 not be used to start scripts.
               
               - `expired' indicates that the launch table entry can
                 not be used to start scripts and will disappear as
                 soon as all smRunTable entries associated with this
                 launch table entry have disappeared.
               
               The value `enabled' requires that the smLaunchRowStatus
               object is active. The value `disabled' requires that there
               are no entries in the smRunTable associated with this
               smLaunchTable entry.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchRunIndexNext">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            This variable is used for creating rows in the smRunTable.
               The value of this variable is a currently unused value
               for smRunIndex, which can be written into the smLaunchStart
               object associated with this row to launch a script.
               
               The value returned when reading this variable must be unique
               for the smLaunchOwner and smLaunchName associated with this
               row. Subsequent attempts to read this variable must return
               different values.
               
               This variable will return the special value 0 if no new rows
               can be created.
               
               Note that the data type and the range of this object must be
               consistent with the definition of smRunIndex.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchStorageType">
        <type name="smiv2:StorageType"/>
        <config value="true"/>
        <description>
          <text>
            This object defines if this row is kept in volatile storage
               and lost upon reboot or if this row is backed up by stable
               storage.
               
               The value of smLaunchStorageType is only meaningful if the
               value of the corresponding RowStatus object is active.
               
               If smLaunchStorageType has the value permanent(4), then all
               objects whose MAX-ACCESS value is read-create must be
               writable, with the exception of the smLaunchStorageType and
               smLaunchRowStatus objects, which shall be read-only.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchRowStatus">
        <type name="smiv2:RowStatus"/>
        <config value="true"/>
        <description>
          <text>
            A control that allows entries to be added and removed from
               this table.
               
               Attempts to `destroy' a row or to set a row `notInService'
               while the smLaunchOperStatus is `enabled' will result in
               an inconsistentValue error.
               
               Attempts to `destroy' a row or to set a row `notInService'
               where the value of the smLaunchStorageType object is
               `permanent' or `readOnly' will result in an
               inconsistentValue error.
               
               The value of this object has no effect on whether other
               objects in this conceptual row can be modified.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchError">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            This object contains a descriptive error message if an
               attempt to launch a script fails. Implementations must reset
               the error message to a zero-length string when a new attempt
               to launch a script is started.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchLastChange">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when this launch table entry was last
               modified. The value '0000000000000000'H is returned if
               the launch table entry has not yet been modified.
               
               Note that a change of smLaunchStart, smLaunchControl,
               smLaunchRunIndexNext, smLaunchRowExpireTime, or the
               resetting of smLaunchError is not considered a change
               of this launch table entry.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchRowExpireTime">
        <type name="smiv2:TimeInterval"/>
        <units name ="centi-seconds"/>
        <config value="true"/>
        <description>
          <text>
            The value of this object specifies how long this row remains
               in the `enabled' or `disabled' operational state. The value
               reported by this object ticks backwards. When the value
               reaches 0, it stops ticking backward and the row is
               deleted if there are no smRunTable entries associated with
               
               this smLaunchTable entry. Otherwise, the smLaunchOperStatus
               changes to `expired' and the row deletion is deferred
               until there are no smRunTable entries associated with this
               smLaunchTable entry.
               
               The smLaunchRowExpireTime will not tick backwards if it is
               set to its maximum value (2147483647). In other words,
               setting this object to its maximum value turns the timer
               off.
               
               The value of this object may be set in order to increase
               or reduce the remaining time that the launch table entry
               may be used. Setting the value to 0 will cause an immediate
               row deletion or transition into the `expired' operational
               state.
               
               It is not possible to set this object while the operational
               status is `expired'. Attempts to modify this object while
               the operational status is `expired' leads to an
               inconsistentValue error.
               
               Note that the timer ticks backwards independent of the
               operational state of the launch table entry.
          </text>
        </description>
      </leaf>
    </list>
    <list name="smRunEntry">
      <key value="smLaunchOwner smLaunchName smRunIndex"/>
      <description>
        <text>
          An entry describing a particular running or finished
            script.
        </text>
      </description>
      <leaf name="smLaunchOwner">
        <type name="leafref">
          <path value="/disman-script:smRunObjects/disman-script:smLaunchEntry/disman-script:smLaunchOwner"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="smLaunchName">
        <type name="leafref">
          <path value="/disman-script:smRunObjects/disman-script:smLaunchEntry/disman-script:smLaunchName"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="smRunIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            The locally arbitrary, but unique identifier associated
               with this running or finished script. This value must be
               unique for all rows in the smRunTable with the same
               smLaunchOwner and smLaunchName.
               
               Note that the data type and the range of this object must
               be consistent with the definition of smLaunchRunIndexNext
               and smLaunchStart.
          </text>
        </description>
      </leaf>
      <leaf name="smRunArgument">
        <type name="binary"/>
        <config value="false"/>
        <description>
          <text>
            The argument supplied to the script when it started.
          </text>
        </description>
      </leaf>
      <leaf name="smRunStartTime">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when the execution started. The value
               '0000000000000000'H is returned if the script has not
               started yet.
          </text>
        </description>
      </leaf>
      <leaf name="smRunEndTime">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when the execution terminated. The value
               '0000000000000000'H is returned if the script has not
               terminated yet.
          </text>
        </description>
      </leaf>
      <leaf name="smRunLifeTime">
        <type name="smiv2:TimeInterval"/>
        <units name ="centi-seconds"/>
        <config value="true"/>
        <description>
          <text>
            This object specifies how long the script can execute.
               This object returns the remaining time that the script
               may run. The object is initialized with the value of the
               associated smLaunchLifeTime object and ticks backwards.
               The script is aborted immediately when the value reaches 0.
               
               The value of this object may be set in order to increase or
               reduce the remaining time that the script may run. Setting
               this value to 0 will abort script execution immediately,
               and, if the value of smRunExpireTime is also 0, will remove
               this entry from the smRunTable once it has terminated.
               
               If smRunLifeTime is set to its maximum value (2147483647),
               either by a set operation or by its initialization from the
               smLaunchLifeTime object, then it will not tick backwards.
               A running script with a maximum smRunLifeTime value will
               thus never be terminated with a `lifeTimeExceeded' exit
               code.
               
               The value of smRunLifeTime reflects the real-time execution
               time as seen by the outside world. The value of this object
               will always be 0 for a script that finished execution, that
               is smRunState has the value `terminated'.
               
               The value of smRunLifeTime does not change while a script
               is suspended, that is smRunState has the value `suspended'.
               Note that this does not affect set operations. It is legal
               to modify smRunLifeTime via set operations while a script
               is suspended.
          </text>
        </description>
      </leaf>
      <leaf name="smRunExpireTime">
        <type name="smiv2:TimeInterval"/>
        <units name ="centi-seconds"/>
        <config value="true"/>
        <description>
          <text>
            The value of this object specifies how long this row can
               exist in the smRunTable after the script has terminated.
               This object returns the remaining time that the row may
               exist before it is aged out. The object is initialized with
               the value of the associated smLaunchExpireTime object and
               ticks backwards. The entry in the smRunTable is destroyed
               when the value reaches 0 and the smRunState has the value
               `terminated'.
               
               The value of this object may be set in order to increase or
               reduce the remaining time that the row may exist.  Setting
               the value to 0 will destroy this entry as soon as the
               smRunState has the value `terminated'.
          </text>
        </description>
      </leaf>
      <leaf name="smRunExitCode">
        <type name="enumeration">
          <enum name="noError">
            <value value="1"/>
          </enum>
          <enum name="halted">
            <value value="2"/>
          </enum>
          <enum name="lifeTimeExceeded">
            <value value="3"/>
          </enum>
          <enum name="noResourcesLeft">
            <value value="4"/>
          </enum>
          <enum name="languageError">
            <value value="5"/>
          </enum>
          <enum name="runtimeError">
            <value value="6"/>
          </enum>
          <enum name="invalidArgument">
            <value value="7"/>
          </enum>
          <enum name="securityViolation">
            <value value="8"/>
          </enum>
          <enum name="genericError">
            <value value="9"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The value of this object indicates the reason why a
               script finished execution. The smRunExitCode code may have
               one of the following values:
               
               - `noError', which indicates that the script completed
                  successfully without errors;
               
               - `halted', which indicates that the script was halted
                  by a request from an authorized manager;
               
               - `lifeTimeExceeded', which indicates that the script
                  exited because a time limit was exceeded;
               
               - `noResourcesLeft', which indicates that the script
                  exited because it ran out of resources (e.g. memory);
               
               - `languageError', which indicates that the script exited
                  because of a language error (e.g. a syntax error in an
                  interpreted language);
               
               - `runtimeError', which indicates that the script exited
                  due to a runtime error (e.g. a division by zero);
               
               - `invalidArgument', which indicates that the script could
                  not be run because of invalid script arguments;
               
               - `securityViolation', which indicates that the script
                  exited due to a security violation;
               
               - `genericError', which indicates that the script exited
                  for an unspecified reason.
               
               If the script has not yet begun running, or is currently
               running, the value will be `noError'.
          </text>
        </description>
      </leaf>
      <leaf name="smRunResult">
        <type name="binary"/>
        <config value="false"/>
        <description>
          <text>
            The result value produced by the running script. Note that
               the result may change while the script is executing.
          </text>
        </description>
      </leaf>
      <leaf name="smRunControl">
        <type name="enumeration">
          <enum name="abort">
            <value value="1"/>
          </enum>
          <enum name="suspend">
            <value value="2"/>
          </enum>
          <enum name="resume">
            <value value="3"/>
          </enum>
          <enum name="nop">
            <value value="4"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The value of this object indicates the desired status of the
               script execution defined by this row.
               
               Setting this object to `abort' will abort execution if the
               
               value of smRunState is `initializing', `executing',
               `suspending', `suspended' or `resuming'. Setting this object
               to `abort' when the value of smRunState is `aborting' or
               `terminated', or if the implementation can determine that
               the attempt to abort the execution would fail, will result
               in an inconsistentValue error.
               
               Setting this object to `suspend' will suspend execution
               if the value of smRunState is `executing'. Setting this
               object to `suspend' will cause an inconsistentValue error
               if the value of smRunState is not `executing' or if the
               implementation can determine that the attempt to suspend
               the execution would fail.
               
               Setting this object to `resume' will resume execution
               if the value of smRunState is `suspending' or
               `suspended'. Setting this object to `resume' will cause an
               inconsistentValue error if the value of smRunState is
               not `suspended' or if the implementation can determine
               that the attempt to resume the execution would fail.
               
               Setting this object to nop(4) has no effect.
          </text>
        </description>
      </leaf>
      <leaf name="smRunState">
        <type name="enumeration">
          <enum name="initializing">
            <value value="1"/>
          </enum>
          <enum name="executing">
            <value value="2"/>
          </enum>
          <enum name="suspending">
            <value value="3"/>
          </enum>
          <enum name="suspended">
            <value value="4"/>
          </enum>
          <enum name="resuming">
            <value value="5"/>
          </enum>
          <enum name="aborting">
            <value value="6"/>
          </enum>
          <enum name="terminated">
            <value value="7"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The value of this object indicates the script's execution
               state. If the script has been invoked but has not yet
               begun execution, the value will be `initializing'. If the
               script is running, the value will be `executing'.
               
               A running script which received a request to suspend
               execution first transitions into a temporary `suspending'
               state.  The temporary `suspending' state changes to
               `suspended' when the script has actually been suspended. The
               temporary `suspending' state changes back to `executing' if
               
               the attempt to suspend the running script fails.
               
               A suspended script which received a request to resume
               execution first transitions into a temporary `resuming'
               state. The temporary `resuming' state changes to `running'
               when the script has actually been resumed. The temporary
               `resuming' state changes back to `suspended' if the attempt
               to resume the suspended script fails.
               
               A script which received a request to abort execution but
               which is still running first transitions into a temporary
               `aborting' state.
               
               A script which has finished its execution is `terminated'.
          </text>
        </description>
      </leaf>
      <leaf name="smRunError">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            This object contains a descriptive error message if the
               script startup or execution raised an abnormal condition.
               An implementation must store a descriptive error message
               in this object if the script exits with the smRunExitCode
               `genericError'.
          </text>
        </description>
      </leaf>
      <leaf name="smRunResultTime">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when the smRunResult was last updated.
               The value '0000000000000000'H is returned if smRunResult
               has not yet been updated after the creation of this
               smRunTable entry.
          </text>
        </description>
      </leaf>
      <leaf name="smRunErrorTime">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The date and time when the smRunError was last updated.
               The value '0000000000000000'H is returned if smRunError
               
               has not yet been updated after the creation of this
               smRunTable entry.
          </text>
        </description>
      </leaf>
    </list>
  </container>







</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="ENTITY-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:ENTITY-MIB"/>
  <prefix value="entity-mib"/>
  <import module="SNMP-FRAMEWORK-MIB">
    <prefix value="snmp-framework"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF ENTMIB Working Group
    </info>
  </organization>
  <contact>
  <info>
          WG E-mail: entmib@ietf.org
      Mailing list subscription info:
        http://www.ietf.org/mailman/listinfo/entmib
      
      Andy Bierman
      ietf@andybierman.com
      
      Keith McCloghrie
      Cisco Systems Inc.
      170 West Tasman Drive
      San Jose, CA 95134
      
      
      
      +1 408-526-5260
      kzm@cisco.com
    </info>
  </contact>
  <description>
    <text>
      The MIB module for representing multiple logical
      entities supported by a single SNMP agent.
      
      Copyright (C) The Internet Society (2005).  This
      version of this MIB module is part of RFC 4133; see
      the RFC itself for full legal notices.
    </text>
  </description>
  <revision date="2005-08-10">
    <description>
      <text>
        Initial Version of Entity MIB (Version 3).
         This revision obsoletes RFC 2737.
         Additions:
           - cpu(12) enumeration added to PhysicalClass TC
           - DISPLAY-HINT clause to PhysicalIndex TC
           - PhysicalIndexOrZero TC
           - entPhysicalMfgDate object
           - entPhysicalUris object
         Changes:
           - entPhysicalContainedIn SYNTAX changed from
             INTEGER to PhysicalIndexOrZero
         
         This version published as RFC 4133.
      </text>
    </description>
  </revision>
  <revision date="1999-12-07">
    <description>
      <text>
        Initial Version of Entity MIB (Version 2).
         This revision obsoletes RFC 2037.
         This version published as RFC 2737.
      </text>
    </description>
  </revision>
  <revision date="1996-10-31">
    <description>
      <text>
        Initial version (version 1), published as
         RFC 2037.
      </text>
    </description>
  </revision>
  <typedef name="PhysicalIndex">
    <type name="int32">
      <range value="1..2147483647"/>
    </type>
    <description>
      <text>
        An arbitrary value that uniquely identifies the physical
         entity.  The value should be a small, positive integer.
         Index values for different physical entities are not
         necessarily contiguous.
      </text>
    </description>
  </typedef>

  <typedef name="PhysicalIndexOrZero">
    <type name="int32">
      <range value="0..2147483647"/>
    </type>
    <description>
      <text>
        This textual convention is an extension of the
         PhysicalIndex convention, which defines a greater than zero
         value used to identify a physical entity.  This extension
         permits the additional value of zero.  The semantics of the
         value zero are object-specific and must, therefore, be
         defined as part of the description of any object that uses
         this syntax.  Examples of the usage of this extension are
         situations where none or all physical entities need to be
         referenced.
      </text>
    </description>
  </typedef>

  <typedef name="PhysicalClass">
    <type name="enumeration">
      <enum name="other">
        <value value="1"/>
      </enum>
      <enum name="unknown">
        <value value="2"/>
      </enum>
      <enum name="chassis">
        <value value="3"/>
      </enum>
      <enum name="backplane">
        <value value="4"/>
      </enum>
      <enum name="container">
        <value value="5"/>
      </enum>
      <enum name="powerSupply">
        <value value="6"/>
      </enum>
      <enum name="fan">
        <value value="7"/>
      </enum>
      <enum name="sensor">
        <value value="8"/>
      </enum>
      <enum name="module">
        <value value="9"/>
      </enum>
      <enum name="port">
        <value value="10"/>
      </enum>
      <enum name="stack">
        <value value="11"/>
      </enum>
      <enum name="cpu">
        <value value="12"/>
      </enum>
    </type>
    <description>
      <text>
        An enumerated value which provides an indication of the
         general hardware type of a particular physical entity.
         There are no restrictions as to the number of
         entPhysicalEntries of each entPhysicalClass, which must be
         instantiated by an agent.
         
         The enumeration 'other' is applicable if the physical entity
         class is known, but does not match any of the supported
         values.
         
         The enumeration 'unknown' is applicable if the physical
         entity class is unknown to the agent.
         
         The enumeration 'chassis' is applicable if the physical
         entity class is an overall container for networking
         equipment.  Any class of physical entity, except a stack,
         may be contained within a chassis; and a chassis may only
         be contained within a stack.
         
         
         
         
         The enumeration 'backplane' is applicable if the physical
         entity class is some sort of device for aggregating and
         forwarding networking traffic, such as a shared backplane in
         a modular ethernet switch.  Note that an agent may model a
         backplane as a single physical entity, which is actually
         implemented as multiple discrete physical components (within
         a chassis or stack).
         
         The enumeration 'container' is applicable if the physical
         entity class is capable of containing one or more removable
         physical entities, possibly of different types.  For
         example, each (empty or full) slot in a chassis will be
         modeled as a container.  Note that all removable physical
         entities should be modeled within a container entity, such
         as field-replaceable modules, fans, or power supplies.  Note
         that all known containers should be modeled by the agent,
         including empty containers.
         
         The enumeration 'powerSupply' is applicable if the physical
         entity class is a power-supplying component.
         
         The enumeration 'fan' is applicable if the physical entity
         class is a fan or other heat-reduction component.
         
         The enumeration 'sensor' is applicable if the physical
         entity class is some sort of sensor, such as a temperature
         sensor within a router chassis.
         
         The enumeration 'module' is applicable if the physical
         entity class is some sort of self-contained sub-system.  If
         the enumeration 'module' is removable, then it should be
         modeled within a container entity, otherwise it should be
         modeled directly within another physical entity (e.g., a
         chassis or another module).
         
         The enumeration 'port' is applicable if the physical entity
         class is some sort of networking port, capable of receiving
         and/or transmitting networking traffic.
         
         The enumeration 'stack' is applicable if the physical entity
         class is some sort of super-container (possibly virtual),
         intended to group together multiple chassis entities.  A
         stack may be realized by a 'virtual' cable, a real
         interconnect cable, attached to multiple chassis, or may in
         fact be comprised of multiple interconnect cables.  A stack
         should not be modeled within any other physical entities,
         but a stack may be contained within another stack.  Only
         chassis entities should be contained within a stack.
         
         
         
         The enumeration 'cpu' is applicable if the physical entity
         class is some sort of central processing unit.
      </text>
    </description>
  </typedef>

  <typedef name="SnmpEngineIdOrNone">
    <type name="binary">
      <length value="0..32"/>
    </type>
    <description>
      <text>
        A specially formatted SnmpEngineID string for use with the
         Entity MIB.
         
         If an instance of an object of SYNTAX SnmpEngineIdOrNone has
         a non-zero length, then the object encoding and semantics
         are defined by the SnmpEngineID textual convention (see STD
         62, RFC 3411 [RFC3411]).
         
         If an instance of an object of SYNTAX SnmpEngineIdOrNone
         contains a zero-length string, then no appropriate
         SnmpEngineID is associated with the logical entity (i.e.,
         SNMPv3 is not supported).
      </text>
    </description>
  </typedef>

  <container name="entityPhysical">
    <list name="entPhysicalEntry">
      <key value="entPhysicalIndex"/>
      <description>
        <text>
          Information about a particular physical entity.
            
            Each entry provides objects (entPhysicalDescr,
            entPhysicalVendorType, and entPhysicalClass) to help an NMS
            identify and characterize the entry, and objects
            (entPhysicalContainedIn and entPhysicalParentRelPos) to help
            an NMS relate the particular entry to other entries in this
            table.
        </text>
      </description>
      <leaf name="entPhysicalIndex">
        <type name="entity-mib:PhysicalIndex"/>
        <description>
          <text>
            The index for this entry.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            A textual description of physical entity.  This object
               should contain a string that identifies the manufacturer's
               name for the physical entity, and should be set to a
               distinct value for each version or model of the physical
               entity.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalVendorType">
        <type name="smiv2:AutonomousType"/>
        <config value="false"/>
        <description>
          <text>
            An indication of the vendor-specific hardware type of the
               physical entity.  Note that this is different from the
               definition of MIB-II's sysObjectID.
               
               An agent should set this object to an enterprise-specific
               registration identifier value indicating the specific
               equipment type in detail.  The associated instance of
               entPhysicalClass is used to indicate the general type of
               hardware device.
               
               If no vendor-specific registration identifier exists for
               this physical entity, or the value is unknown by this agent,
               then the value { 0 0 } is returned.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalContainedIn">
        <type name="entity-mib:PhysicalIndexOrZero"/>
        <config value="false"/>
        <description>
          <text>
            The value of entPhysicalIndex for the physical entity which
               'contains' this physical entity.  A value of zero indicates
               this physical entity is not contained in any other physical
               entity.  Note that the set of 'containment' relationships
               define a strict hierarchy; that is, recursion is not
               allowed.
               
               In the event that a physical entity is contained by more
               than one physical entity (e.g., double-wide modules), this
               object should identify the containing entity with the lowest
               value of entPhysicalIndex.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalClass">
        <type name="entity-mib:PhysicalClass"/>
        <config value="false"/>
        <description>
          <text>
            An indication of the general hardware type of the physical
               entity.
               
               An agent should set this object to the standard enumeration
               value that most accurately indicates the general class of
               the physical entity, or the primary class if there is more
               than one entity.
               
               If no appropriate standard registration identifier exists
               for this physical entity, then the value 'other(1)' is
               returned.  If the value is unknown by this agent, then the
               value 'unknown(2)' is returned.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalParentRelPos">
        <type name="int32">
          <range value="-1..2147483647"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            An indication of the relative position of this 'child'
               component among all its 'sibling' components.  Sibling
               components are defined as entPhysicalEntries that share the
               same instance values of each of the entPhysicalContainedIn
               and entPhysicalClass objects.
               
               An NMS can use this object to identify the relative ordering
               for all sibling components of a particular parent
               (identified by the entPhysicalContainedIn instance in each
               sibling entry).
               
               If possible, this value should match any external labeling
               of the physical component.  For example, for a container
               (e.g., card slot) labeled as 'slot #3',
               entPhysicalParentRelPos should have the value '3'.  Note
               that the entPhysicalEntry for the module plugged in slot 3
               should have an entPhysicalParentRelPos value of '1'.
               
               If the physical position of this component does not match
               any external numbering or clearly visible ordering, then
               user documentation or other external reference material
               should be used to determine the parent-relative position.
               If this is not possible, then the agent should assign a
               consistent (but possibly arbitrary) ordering to a given set
               of 'sibling' components, perhaps based on internal
               representation of the components.
               
               
               
               
               If the agent cannot determine the parent-relative position
               for some reason, or if the associated value of
               entPhysicalContainedIn is '0', then the value '-1' is
               returned.  Otherwise, a non-negative integer is returned,
               indicating the parent-relative position of this physical
               entity.
               
               Parent-relative ordering normally starts from '1' and
               continues to 'N', where 'N' represents the highest
               positioned child entity.  However, if the physical entities
               (e.g., slots) are labeled from a starting position of zero,
               then the first sibling should be associated with an
               entPhysicalParentRelPos value of '0'.  Note that this
               ordering may be sparse or dense, depending on agent
               implementation.
               
               The actual values returned are not globally meaningful, as
               each 'parent' component may use different numbering
               algorithms.  The ordering is only meaningful among siblings
               of the same parent component.
               
               The agent should retain parent-relative position values
               across reboots, either through algorithmic assignment or use
               of non-volatile storage.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalName">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            The textual name of the physical entity.  The value of this
               object should be the name of the component as assigned by
               the local device and should be suitable for use in commands
               entered at the device's `console'.  This might be a text
               name (e.g., `console') or a simple component number (e.g.,
               port or module number, such as `1'), depending on the
               physical component naming syntax of the device.
               
               If there is no local name, or if this object is otherwise
               not applicable, then this object contains a zero-length
               string.
               
               Note that the value of entPhysicalName for two physical
               entities will be the same in the event that the console
               interface does not distinguish between them, e.g., slot-1
               and the card in slot-1.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalHardwareRev">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            The vendor-specific hardware revision string for the
               physical entity.  The preferred value is the hardware
               revision identifier actually printed on the component itself
               (if present).
               
               Note that if revision information is stored internally in a
               non-printable (e.g., binary) format, then the agent must
               convert such information to a printable format, in an
               implementation-specific manner.
               
               If no specific hardware revision string is associated with
               the physical component, or if this information is unknown to
               the agent, then this object will contain a zero-length
               string.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalFirmwareRev">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            The vendor-specific firmware revision string for the
               physical entity.
               
               Note that if revision information is stored internally in a
               non-printable (e.g., binary) format, then the agent must
               convert such information to a printable format, in an
               implementation-specific manner.
               
               If no specific firmware programs are associated with the
               physical component, or if this information is unknown to the
               agent, then this object will contain a zero-length string.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalSoftwareRev">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            The vendor-specific software revision string for the
               physical entity.
               
               Note that if revision information is stored internally in a
               
               
               
               non-printable (e.g., binary) format, then the agent must
               convert such information to a printable format, in an
               implementation-specific manner.
               
               If no specific software programs are associated with the
               physical component, or if this information is unknown to the
               agent, then this object will contain a zero-length string.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalSerialNum">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The vendor-specific serial number string for the physical
               entity.  The preferred value is the serial number string
               actually printed on the component itself (if present).
               
               On the first instantiation of an physical entity, the value
               of entPhysicalSerialNum associated with that entity is set
               to the correct vendor-assigned serial number, if this
               information is available to the agent.  If a serial number
               is unknown or non-existent, the entPhysicalSerialNum will be
               set to a zero-length string instead.
               
               Note that implementations that can correctly identify the
               serial numbers of all installed physical entities do not
               need to provide write access to the entPhysicalSerialNum
               object.  Agents which cannot provide non-volatile storage
               for the entPhysicalSerialNum strings are not required to
               implement write access for this object.
               
               Not every physical component will have a serial number, or
               even need one.  Physical entities for which the associated
               value of the entPhysicalIsFRU object is equal to 'false(2)'
               (e.g., the repeater ports within a repeater module), do not
               need their own unique serial number.  An agent does not have
               to provide write access for such entities, and may return a
               zero-length string.
               
               If write access is implemented for an instance of
               entPhysicalSerialNum, and a value is written into the
               instance, the agent must retain the supplied value in the
               entPhysicalSerialNum instance (associated with the same
               physical entity) for as long as that entity remains
               instantiated.  This includes instantiations across all
               re-initializations/reboots of the network management system,
               including those resulting in a change of the physical
               
               
               
               entity's entPhysicalIndex value.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalMfgName">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            The name of the manufacturer of this physical component.
               The preferred value is the manufacturer name string actually
               printed on the component itself (if present).
               
               Note that comparisons between instances of the
               entPhysicalModelName, entPhysicalFirmwareRev,
               entPhysicalSoftwareRev, and the entPhysicalSerialNum
               objects, are only meaningful amongst entPhysicalEntries with
               the same value of entPhysicalMfgName.
               
               If the manufacturer name string associated with the physical
               component is unknown to the agent, then this object will
               contain a zero-length string.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalModelName">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            The vendor-specific model name identifier string associated
               with this physical component.  The preferred value is the
               customer-visible part number, which may be printed on the
               component itself.
               
               If the model name string associated with the physical
               component is unknown to the agent, then this object will
               contain a zero-length string.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalAlias">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            This object is an 'alias' name for the physical entity, as
               specified by a network manager, and provides a non-volatile
               'handle' for the physical entity.
               
               On the first instantiation of a physical entity, the value
               
               
               
               of entPhysicalAlias associated with that entity is set to
               the zero-length string.  However, the agent may set the
               value to a locally unique default value, instead of a
               zero-length string.
               
               If write access is implemented for an instance of
               entPhysicalAlias, and a value is written into the instance,
               the agent must retain the supplied value in the
               entPhysicalAlias instance (associated with the same physical
               entity) for as long as that entity remains instantiated.
               This includes instantiations across all
               re-initializations/reboots of the network management system,
               including those resulting in a change of the physical
               entity's entPhysicalIndex value.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalAssetID">
        <type name="snmp-framework:SnmpAdminString">
          <length value="0..32"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            This object is a user-assigned asset tracking identifier
               (as specified by a network manager) for the physical entity,
               and provides non-volatile storage of this information.
               
               On the first instantiation of a physical entity, the value
               of entPhysicalAssetID associated with that entity is set to
               the zero-length string.
               
               Not every physical component will have an asset tracking
               identifier, or even need one.  Physical entities for which
               the associated value of the entPhysicalIsFRU object is equal
               to 'false(2)' (e.g., the repeater ports within a repeater
               module), do not need their own unique asset tracking
               identifier.  An agent does not have to provide write access
               for such entities, and may instead return a zero-length
               string.
               
               If write access is implemented for an instance of
               entPhysicalAssetID, and a value is written into the
               instance, the agent must retain the supplied value in the
               entPhysicalAssetID instance (associated with the same
               physical entity) for as long as that entity remains
               instantiated.  This includes instantiations across all
               re-initializations/reboots of the network management system,
               including those resulting in a change of the physical
               entity's entPhysicalIndex value.
               
               
               
               
               If no asset tracking information is associated with the
               physical component, then this object will contain a
               zero-length string.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalIsFRU">
        <type name="smiv2:TruthValue"/>
        <config value="false"/>
        <description>
          <text>
            This object indicates whether or not this physical entity
               is considered a 'field replaceable unit' by the vendor.  If
               this object contains the value 'true(1)' then this
               entPhysicalEntry identifies a field replaceable unit.  For
               all entPhysicalEntries that represent components
               permanently contained within a field replaceable unit, the
               value 'false(2)' should be returned for this object.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalMfgDate">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            This object contains the date of manufacturing of the
               managed entity.  If the manufacturing date is unknown or not
               supported, the object is not instantiated.  The special
               value '0000000000000000'H may also be returned in this
               case.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalUris">
        <type name="binary"/>
        <config value="true"/>
        <description>
          <text>
            This object contains additional identification information
               about the physical entity.  The object contains URIs and,
               therefore, the syntax of this object must conform to RFC
               3986, section 2.
               
               Multiple URIs may be present and are separated by white
               space characters.  Leading and trailing white space
               characters are ignored.
               
               If no additional identification information is known
               about the physical entity or supported, the object is not
               instantiated.  A zero length octet string may also be
               
               
               
               returned in this case.
          </text>
        </description>
        <reference info="RFC 3986, Uniform Resource Identifiers (URI): Generic
               Syntax, section 2, August 1998."/>
      </leaf>
    </list>
  </container>

  <container name="entityLogical">
    <list name="entLogicalEntry">
      <key value="entLogicalIndex"/>
      <description>
        <text>
          Information about a particular logical entity.  Entities
            may be managed by this agent or other SNMP agents (possibly)
            in the same chassis.
        </text>
      </description>
      <leaf name="entLogicalIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            The value of this object uniquely identifies the logical
               entity.  The value should be a small positive integer; index
               values for different logical entities are not necessarily
               contiguous.
          </text>
        </description>
      </leaf>
      <leaf name="entLogicalDescr">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            A textual description of the logical entity.  This object
               should contain a string that identifies the manufacturer's
               name for the logical entity, and should be set to a distinct
               value for each version of the logical entity.
          </text>
        </description>
      </leaf>
      <leaf name="entLogicalType">
        <type name="smiv2:AutonomousType"/>
        <config value="false"/>
        <description>
          <text>
            An indication of the type of logical entity.  This will
               typically be the OBJECT IDENTIFIER name of the node in the
               SMI's naming hierarchy which represents the major MIB
               module, or the majority of the MIB modules, supported by the
               logical entity.  For example:
                  a logical entity of a regular host/router -> mib-2
                  a logical entity of a 802.1d bridge -> dot1dBridge
                  a logical entity of a 802.3 repeater -> snmpDot3RptrMgmt
               If an appropriate node in the SMI's naming hierarchy cannot
               be identified, the value 'mib-2' should be used.
          </text>
        </description>
      </leaf>
      <leaf name="entLogicalCommunity">
        <type name="binary">
          <length value="0..255"/>
        </type>
        <config value="false"/>
        <status value="deprecated"/>
        <description>
          <text>
            An SNMPv1 or SNMPv2C community-string, which can be used to
               access detailed management information for this logical
               entity.  The agent should allow read access with this
               community string (to an appropriate subset of all managed
               objects) and may also return a community string based on the
               privileges of the request used to read this object.  Note
               that an agent may return a community string with read-only
               privileges, even if this object is accessed with a
               read-write community string.  However, the agent must take
               
               
               
               care not to return a community string that allows more
               privileges than the community string used to access this
               object.
               
               A compliant SNMP agent may wish to conserve naming scopes by
               representing multiple logical entities in a single 'default'
               naming scope.  This is possible when the logical entities,
               represented by the same value of entLogicalCommunity, have
               no object instances in common.  For example, 'bridge1' and
               'repeater1' may be part of the main naming scope, but at
               least one additional community string is needed to represent
               'bridge2' and 'repeater2'.
               
               Logical entities 'bridge1' and 'repeater1' would be
               represented by sysOREntries associated with the 'default'
               naming scope.
               
               For agents not accessible via SNMPv1 or SNMPv2C, the value
               of this object is the empty string.  This object may also
               contain an empty string if a community string has not yet
               been assigned by the agent, or if no community string with
               suitable access rights can be returned for a particular SNMP
               request.
               
               Note that this object is deprecated.  Agents which implement
               SNMPv3 access should use the entLogicalContextEngineID and
               entLogicalContextName objects to identify the context
               associated with each logical entity.  SNMPv3 agents may
               return a zero-length string for this object, or may continue
               to return a community string (e.g., tri-lingual agent
               support).
          </text>
        </description>
      </leaf>
      <leaf name="entLogicalTAddress">
        <type name="smiv2:TAddress"/>
        <config value="false"/>
        <description>
          <text>
            The transport service address by which the logical entity
               receives network management traffic, formatted according to
               the corresponding value of entLogicalTDomain.
               
               For snmpUDPDomain, a TAddress is 6 octets long: the initial
               4 octets contain the IP-address in network-byte order and
               the last 2 contain the UDP port in network-byte order.
               Consult 'Transport Mappings for the Simple Network
               Management Protocol' (STD 62, RFC 3417 [RFC3417]) for
               further information on snmpUDPDomain.
          </text>
        </description>
      </leaf>
      <leaf name="entLogicalTDomain">
        <type name="smiv2:TDomain"/>
        <config value="false"/>
        <description>
          <text>
            Indicates the kind of transport service by which the
               logical entity receives network management traffic.
               Possible values for this object are presently found in the
               Transport Mappings for Simple Network Management Protocol'
               (STD 62, RFC 3417 [RFC3417]).
          </text>
        </description>
      </leaf>
      <leaf name="entLogicalContextEngineID">
        <type name="entity-mib:SnmpEngineIdOrNone"/>
        <config value="false"/>
        <description>
          <text>
            The authoritative contextEngineID that can be used to send
               an SNMP message concerning information held by this logical
               entity, to the address specified by the associated
               'entLogicalTAddress/entLogicalTDomain' pair.
               
               This object, together with the associated
               entLogicalContextName object, defines the context associated
               with a particular logical entity, and allows access to SNMP
               engines identified by a contextEngineId and contextName
               pair.
               
               If no value has been configured by the agent, a zero-length
               string is returned, or the agent may choose not to
               instantiate this object at all.
          </text>
        </description>
      </leaf>
      <leaf name="entLogicalContextName">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            The contextName that can be used to send an SNMP message
               concerning information held by this logical entity, to the
               address specified by the associated
               'entLogicalTAddress/entLogicalTDomain' pair.
               
               This object, together with the associated
               entLogicalContextEngineID object, defines the context
               associated with a particular logical entity, and allows
               
               
               
               access to SNMP engines identified by a contextEngineId and
               contextName pair.
               
               If no value has been configured by the agent, a zero-length
               string is returned, or the agent may choose not to
               instantiate this object at all.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="entityMapping">
    <list name="entLPMappingEntry">
      <key value="entLogicalIndex entLPPhysicalIndex"/>
      <description>
        <text>
          Information about a particular logical entity to physical
            equipment association.  Note that the nature of the
            association is not specifically identified in this entry.
            It is expected that sufficient information exists in the
            MIBs used to manage a particular logical entity to infer how
            physical component information is utilized.
        </text>
      </description>
      <leaf name="entLogicalIndex">
        <type name="leafref">
          <path value="/entity-mib:entityLogical/entity-mib:entLogicalEntry/entity-mib:entLogicalIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="entLPPhysicalIndex">
        <type name="entity-mib:PhysicalIndex"/>
        <description>
          <text>
            The value of this object identifies the index value of a
               particular entPhysicalEntry associated with the indicated
               entLogicalEntity.
          </text>
        </description>
      </leaf>
    </list>
    <list name="entAliasMappingEntry">
      <key value="entPhysicalIndex entAliasLogicalIndexOrZero"/>
      <description>
        <text>
          Information about a particular physical equipment, logical
            
            
            
            entity to external identifier binding.  Each logical
            entity/physical component pair may be associated with one
            alias mapping.  The logical entity index may also be used as
            a 'wildcard' (refer to the entAliasLogicalIndexOrZero object
            DESCRIPTION clause for details.)
            
            Note that only entPhysicalIndex values that represent
            physical ports (i.e., associated entPhysicalClass value is
            'port(10)') are permitted to exist in this table.
        </text>
      </description>
      <leaf name="entPhysicalIndex">
        <type name="leafref">
          <path value="/entity-mib:entityPhysical/entity-mib:entPhysicalEntry/entity-mib:entPhysicalIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="entAliasLogicalIndexOrZero">
        <type name="int32">
          <range value="0..2147483647"/>
        </type>
        <description>
          <text>
            The value of this object identifies the logical entity
               that defines the naming scope for the associated instance
               of the 'entAliasMappingIdentifier' object.
               
               If this object has a non-zero value, then it identifies the
               logical entity named by the same value of entLogicalIndex.
               
               If this object has a value of zero, then the mapping between
               the physical component and the alias identifier for this
               entAliasMapping entry is associated with all unspecified
               logical entities.  That is, a value of zero (the default
               mapping) identifies any logical entity that does not have
               an explicit entry in this table for a particular
               entPhysicalIndex/entAliasMappingIdentifier pair.
               
               For example, to indicate that a particular interface (e.g.,
               physical component 33) is identified by the same value of
               ifIndex for all logical entities, the following instance
               might exist:
               
                       entAliasMappingIdentifier.33.0 = ifIndex.5
               
               In the event an entPhysicalEntry is associated differently
               for some logical entities, additional entAliasMapping
               entries may exist, e.g.:
               
               
               
               
                       entAliasMappingIdentifier.33.0 = ifIndex.6
                       entAliasMappingIdentifier.33.4 =  ifIndex.1
                       entAliasMappingIdentifier.33.5 =  ifIndex.1
                       entAliasMappingIdentifier.33.10 = ifIndex.12
               
               Note that entries with non-zero entAliasLogicalIndexOrZero
               index values have precedence over zero-indexed entries.  In
               this example, all logical entities except 4, 5, and 10,
               associate physical entity 33 with ifIndex.6.
          </text>
        </description>
      </leaf>
      <leaf name="entAliasMappingIdentifier">
        <type name="smiv2:RowPointer"/>
        <config value="false"/>
        <description>
          <text>
            The value of this object identifies a particular conceptual
               row associated with the indicated entPhysicalIndex and
               entLogicalIndex pair.
               
               Because only physical ports are modeled in this table, only
               entries that represent interfaces or ports are allowed.  If
               an ifEntry exists on behalf of a particular physical port,
               then this object should identify the associated 'ifEntry'.
               For repeater ports, the appropriate row in the
               'rptrPortGroupTable' should be identified instead.
               
               For example, suppose a physical port was represented by
               entPhysicalEntry.3, entLogicalEntry.15 existed for a
               repeater, and entLogicalEntry.22 existed for a bridge.  Then
               there might be two related instances of
               entAliasMappingIdentifier:
                  entAliasMappingIdentifier.3.15 == rptrPortGroupIndex.5.2
                  entAliasMappingIdentifier.3.22 == ifIndex.17
               It is possible that other mappings (besides interfaces and
               repeater ports) may be defined in the future, as required.
               
               Bridge ports are identified by examining the Bridge MIB and
               appropriate ifEntries associated with each 'dot1dBasePort',
               and are thus not represented in this table.
          </text>
        </description>
      </leaf>
    </list>
    <list name="entPhysicalContainsEntry">
      <key value="entPhysicalIndex entPhysicalChildIndex"/>
      <description>
        <text>
          A single container/'containee' relationship.
        </text>
      </description>
      <leaf name="entPhysicalIndex">
        <type name="leafref">
          <path value="/entity-mib:entityPhysical/entity-mib:entPhysicalEntry/entity-mib:entPhysicalIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="entPhysicalChildIndex">
        <type name="entity-mib:PhysicalIndex"/>
        <description>
          <text>
            The value of entPhysicalIndex for the contained physical
               entity.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="entityGeneral">
    <leaf name="entLastChangeTime">
      <type name="yang:timestamp"/>
      <config value="false"/>
      <description>
        <text>
          The value of sysUpTime at the time a conceptual row is
            created, modified, or deleted in any of these tables:
                    - entPhysicalTable
                    - entLogicalTable
                    - entLPMappingTable
                    - entAliasMappingTable
            
            
            
                    - entPhysicalContainsTable
        </text>
      </description>
    </leaf>
  </container>



</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:entity-mib="urn:ietf:params:xml:ns:yang:smiv2:ENTITY-MIB"
        xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="ENTITY-SENSOR-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:ENTITY-SENSOR-MIB"/>
  <prefix value="entity-sensor"/>
  <import module="ENTITY-MIB">
    <prefix value="entity-mib"/>
  </import>
  <import module="SNMP-FRAMEWORK-MIB">
    <prefix value="snmp-framework"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF Entity MIB Working Group
    </info>
  </organization>
  <contact>
  <info>
          Andy Bierman
      Cisco Systems, Inc.
      Tel: +1 408-527-3711
      E-mail: abierman@cisco.com
      Postal: 170 West Tasman Drive
      San Jose, CA USA 95134
      
      Dan Romascanu
      Avaya Inc.
      Tel: +972-3-645-8414
      Email: dromasca@avaya.com
      Postal: Atidim technology Park, Bldg. #3
      Tel Aviv, Israel, 61131
      
      K.C. Norseth
      L-3 Communications
      Tel: +1 801-594-2809
      Email: kenyon.c.norseth@L-3com.com
      Postal: 640 N. 2200 West.
      
      
      
      Salt Lake City, Utah 84116-0850
      
      Send comments to <entmib@ietf.org>
      Mailing list subscription info:
      http://www.ietf.org/mailman/listinfo/entmib 
    </info>
  </contact>
  <description>
    <text>
      This module defines Entity MIB extensions for physical
      sensors.
      
      Copyright (C) The Internet Society (2002). This version
      of this MIB module is part of RFC 3433; see the RFC
      itself for full legal notices.
    </text>
  </description>
  <revision date="2002-12-16">
    <description>
      <text>
        Initial version of the Entity Sensor MIB module, published
         as RFC 3433.
      </text>
    </description>
  </revision>
  <typedef name="EntitySensorDataType">
    <type name="enumeration">
      <enum name="other">
        <value value="1"/>
      </enum>
      <enum name="unknown">
        <value value="2"/>
      </enum>
      <enum name="voltsAC">
        <value value="3"/>
      </enum>
      <enum name="voltsDC">
        <value value="4"/>
      </enum>
      <enum name="amperes">
        <value value="5"/>
      </enum>
      <enum name="watts">
        <value value="6"/>
      </enum>
      <enum name="hertz">
        <value value="7"/>
      </enum>
      <enum name="celsius">
        <value value="8"/>
      </enum>
      <enum name="percentRH">
        <value value="9"/>
      </enum>
      <enum name="rpm">
        <value value="10"/>
      </enum>
      <enum name="cmm">
        <value value="11"/>
      </enum>
      <enum name="truthvalue">
        <value value="12"/>
      </enum>
    </type>
    <description>
      <text>
        An object using this data type represents the Entity Sensor
         measurement data type associated with a physical sensor
         value. The actual data units are determined by examining an
         object of this type together with the associated
         EntitySensorDataScale object.
         
         An object of this type SHOULD be defined together with
         objects of type EntitySensorDataScale and
         EntitySensorPrecision.  Together, associated objects of
         these three types are used to identify the semantics of an
         object of type EntitySensorValue.
         
         
         
         
         
         
         Valid values are:
         
            other(1):        a measure other than those listed below
            unknown(2):      unknown measurement, or arbitrary,
                             relative numbers
            voltsAC(3):      electric potential
            voltsDC(4):      electric potential
            amperes(5):      electric current
            watts(6):        power
            hertz(7):        frequency
            celsius(8):      temperature
            percentRH(9):    percent relative humidity
            rpm(10):         shaft revolutions per minute
            cmm(11),:        cubic meters per minute (airflow)
            truthvalue(12):  value takes { true(1), false(2) }
      </text>
    </description>
  </typedef>

  <typedef name="EntitySensorDataScale">
    <type name="enumeration">
      <enum name="yocto">
        <value value="1"/>
      </enum>
      <enum name="zepto">
        <value value="2"/>
      </enum>
      <enum name="atto">
        <value value="3"/>
      </enum>
      <enum name="femto">
        <value value="4"/>
      </enum>
      <enum name="pico">
        <value value="5"/>
      </enum>
      <enum name="nano">
        <value value="6"/>
      </enum>
      <enum name="micro">
        <value value="7"/>
      </enum>
      <enum name="milli">
        <value value="8"/>
      </enum>
      <enum name="units">
        <value value="9"/>
      </enum>
      <enum name="kilo">
        <value value="10"/>
      </enum>
      <enum name="mega">
        <value value="11"/>
      </enum>
      <enum name="giga">
        <value value="12"/>
      </enum>
      <enum name="tera">
        <value value="13"/>
      </enum>
      <enum name="exa">
        <value value="14"/>
      </enum>
      <enum name="peta">
        <value value="15"/>
      </enum>
      <enum name="zetta">
        <value value="16"/>
      </enum>
      <enum name="yotta">
        <value value="17"/>
      </enum>
    </type>
    <description>
      <text>
        An object using this data type represents a data scaling
         factor, represented with an International System of Units
         (SI) prefix.  The actual data units are determined by
         examining an object of this type together with the
         associated EntitySensorDataType object.
         
         An object of this type SHOULD be defined together with
         objects of type EntitySensorDataType and
         EntitySensorPrecision.  Together, associated objects of
         these three types are used to identify the semantics of an
         object of type EntitySensorValue.
      </text>
    </description>
  </typedef>

  <typedef name="EntitySensorPrecision">
    <type name="int32">
      <range value="-8..9"/>
    </type>
    <description>
      <text>
        An object using this data type represents a sensor
         precision range.
         
         An object of this type SHOULD be defined together with
         objects of type EntitySensorDataType and
         EntitySensorDataScale.  Together, associated objects of
         these three types are used to identify the semantics of an
         object of type EntitySensorValue.
         
         If an object of this type contains a value in the range 1 to
         9, it represents the number of decimal places in the
         fractional part of an associated EntitySensorValue fixed-
         point number.
         
         If an object of this type contains a value in the range -8
         to -1, it represents the number of accurate digits in the
         associated EntitySensorValue fixed-point number.
         
         The value zero indicates the associated EntitySensorValue
         object is not a fixed-point number.
         
         Agent implementors must choose a value for the associated
         EntitySensorPrecision object so that the precision and
         
         
         
         accuracy of the associated EntitySensorValue object is
         correctly indicated.
         
         For example, a physical entity representing a temperature
         sensor that can measure 0 degrees to 100 degrees C in 0.1
         degree increments, +/- 0.05 degrees, would have an
         EntitySensorPrecision value of '1', an EntitySensorDataScale
         value of 'units(9)', and an EntitySensorValue ranging from
         '0' to '1000'.  The EntitySensorValue would be interpreted
         as 'degrees C * 10'.
      </text>
    </description>
  </typedef>

  <typedef name="EntitySensorValue">
    <type name="int32">
      <range value="-1000000000..1000000000"/>
    </type>
    <description>
      <text>
        An object using this data type represents an Entity Sensor
         value.
         An object of this type SHOULD be defined together with
         objects of type EntitySensorDataType, EntitySensorDataScale
         and EntitySensorPrecision.  Together, associated objects of
         those three types are used to identify the semantics of an
         object of this data type.
         
         The semantics of an object using this data type are
         determined by the value of the associated
         EntitySensorDataType object.
         
         If the associated EntitySensorDataType object is equal to
         'voltsAC(3)', 'voltsDC(4)', 'amperes(5)', 'watts(6),
         'hertz(7)', 'celsius(8)', or 'cmm(11)', then an object of
         this type MUST contain a fixed point number ranging from
         -999,999,999 to +999,999,999.  The value -1000000000
         indicates an underflow error. The value +1000000000
         indicates an overflow error.  The EntitySensorPrecision
         indicates how many fractional digits are represented in the
         associated EntitySensorValue object.
         
         If the associated EntitySensorDataType object is equal to
         'percentRH(9)', then an object of this type MUST contain a
         number ranging from 0 to 100.
         
         If the associated EntitySensorDataType object is equal to
         'rpm(10)', then an object of this type MUST contain a number
         ranging from -999,999,999 to +999,999,999.
         
         If the associated EntitySensorDataType object is equal to
         'truthvalue(12)', then an object of this type MUST contain
         either the value 'true(1)' or the value 'false(2)'.
         
         
         
         If the associated EntitySensorDataType object is equal to
         'other(1)' or unknown(2)', then an object of this type MUST
         contain a number ranging from -1000000000 to 1000000000.
      </text>
    </description>
  </typedef>

  <typedef name="EntitySensorStatus">
    <type name="enumeration">
      <enum name="ok">
        <value value="1"/>
      </enum>
      <enum name="unavailable">
        <value value="2"/>
      </enum>
      <enum name="nonoperational">
        <value value="3"/>
      </enum>
    </type>
    <description>
      <text>
        An object using this data type represents the operational
         status of a physical sensor.
         
         The value 'ok(1)' indicates that the agent can obtain the
         sensor value.
         
         The value 'unavailable(2)' indicates that the agent
         presently cannot obtain the sensor value.
         
         The value 'nonoperational(3)' indicates that the agent
         believes the sensor is broken.  The sensor could have a hard
         failure (disconnected wire), or a soft failure such as out-
         of-range, jittery, or wildly fluctuating readings.
      </text>
    </description>
  </typedef>

  <container name="entitySensorObjects">
    <list name="entPhySensorEntry">
      <key value="entPhysicalIndex"/>
      <description>
        <text>
          Information about a particular physical sensor.
            
            
            
            
            
            An entry in this table describes the present reading of a
            sensor, the measurement units and scale, and sensor
            operational status.
            
            Entries are created in this table by the agent.  An entry
            for each physical sensor SHOULD be created at the same time
            as the associated entPhysicalEntry.  An entry SHOULD be
            destroyed if the associated entPhysicalEntry is destroyed.
        </text>
      </description>
      <leaf name="entPhysicalIndex">
        <type name="leafref">
          <path value="/entity-mib:entityPhysical/entity-mib:entPhysicalEntry/entity-mib:entPhysicalIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorType">
        <type name="entity-sensor:EntitySensorDataType"/>
        <config value="false"/>
        <description>
          <text>
            The type of data returned by the associated
               entPhySensorValue object.
               
               This object SHOULD be set by the agent during entry
               creation, and the value SHOULD NOT change during operation.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorScale">
        <type name="entity-sensor:EntitySensorDataScale"/>
        <config value="false"/>
        <description>
          <text>
            The exponent to apply to values returned by the associated
               entPhySensorValue object.
               
               This object SHOULD be set by the agent during entry
               creation, and the value SHOULD NOT change during operation.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorPrecision">
        <type name="entity-sensor:EntitySensorPrecision"/>
        <config value="false"/>
        <description>
          <text>
            The number of decimal places of precision in fixed-point
               sensor values returned by the associated entPhySensorValue
               object.
               
               This object SHOULD be set to '0' when the associated
               entPhySensorType value is not a fixed-point type: e.g.,
               'percentRH(9)', 'rpm(10)', 'cmm(11)', or 'truthvalue(12)'.
               
               This object SHOULD be set by the agent during entry
               creation, and the value SHOULD NOT change during operation.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorValue">
        <type name="entity-sensor:EntitySensorValue"/>
        <config value="false"/>
        <description>
          <text>
            The most recent measurement obtained by the agent for this
               sensor.
               
               To correctly interpret the value of this object, the
               associated entPhySensorType, entPhySensorScale, and
               entPhySensorPrecision objects must also be examined.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorOperStatus">
        <type name="entity-sensor:EntitySensorStatus"/>
        <config value="false"/>
        <description>
          <text>
            The operational status of the sensor.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorUnitsDisplay">
        <type name="snmp-framework:SnmpAdminString"/>
        <config value="false"/>
        <description>
          <text>
            A textual description of the data units that should be used
               in the display of entPhySensorValue.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorValueTimeStamp">
        <type name="yang:timestamp"/>
        <config value="false"/>
        <description>
          <text>
            The value of sysUpTime at the time the status and/or value
               of this sensor was last obtained by the agent.
          </text>
        </description>
      </leaf>
      <leaf name="entPhySensorValueUpdateRate">
        <type name="uint32"/>
        <units name ="milliseconds"/>
        <config value="false"/>
        <description>
          <text>
            An indication of the frequency that the agent updates the
               associated entPhySensorValue object, representing in
               milliseconds.
               
               The value zero indicates:
               
                   - the sensor value is updated on demand (e.g.,
                     when polled by the agent for a get-request),
                   - the sensor value is updated when the sensor
                     value changes (event-driven),
                   - the agent does not know the update rate.
          </text>
        </description>
      </leaf>
    </list>
  </container>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:entity-mib="urn:ietf:params:xml:ns:yang:smiv2:ENTITY-MIB"
        xmlns:entity-state="urn:ietf:params:xml:ns:yang:smiv2:ENTITY-STATE-TC-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="ENTITY-STATE-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:ENTITY-STATE-MIB"/>
  <prefix value="entity-state-mib"/>
  <import module="ENTITY-MIB">
    <prefix value="entity-mib"/>
  </import>
  <import module="ENTITY-STATE-TC-MIB">
    <prefix value="entity-state"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IETF Entity MIB Working Group
    </info>
  </organization>
  <contact>
  <info>
   General Discussion: entmib@ietf.org
      To Subscribe:
      http://www.ietf.org/mailman/listinfo/entmib
      
      http://www.ietf.org/html.charters/entmib-charter.html
      
      Sharon Chisholm
      Nortel Networks
      PO Box 3511 Station C
      Ottawa, Ont.  K1Y 4H7
      Canada
      schishol@nortel.com
      
      David T. Perkins
      548 Qualbrook Ct
      San Jose, CA 95110
      USA
      Phone: 408 394-8702
      dperkins@snmpinfo.com
    </info>
  </contact>
  <description>
    <text>
      This MIB defines a state extension to the Entity MIB.
      
      Copyright (C) The Internet Society 2005.  This version
      of this MIB module is part of RFC 4268; see the RFC
      itself for full legal notices.
    </text>
  </description>
  <revision date="2005-11-22">
    <description>
      <text>
        Initial version, published as RFC 4268.
      </text>
    </description>
  </revision>
  <container name="entStateObjects">
    <list name="entStateEntry">
      <key value="entPhysicalIndex"/>
      <description>
        <text>
          State information about this physical entity.
        </text>
      </description>
      <leaf name="entPhysicalIndex">
        <type name="leafref">
          <path value="/entity-mib:entityPhysical/entity-mib:entPhysicalEntry/entity-mib:entPhysicalIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="entStateLastChanged">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The value of this object is the date and
               time when the value of any of entStateAdmin,
               entStateOper, entStateUsage, entStateAlarm,
               or entStateStandby changed for this entity.
               
               If there has been no change since
               the last re-initialization of the local system,
               this object contains the date and time of
               local system initialization.  If there has been
               no change since the entity was added to the
               local system, this object contains the date and
               time of the insertion.
          </text>
        </description>
      </leaf>
      <leaf name="entStateAdmin">
        <type name="entity-state:EntityAdminState"/>
        <config value="true"/>
        <description>
          <text>
            The administrative state for this entity.
               
               
               
               This object refers to an entities administrative
               permission to service both other entities within
               its containment hierarchy as well other users of
               its services defined by means outside the scope
               of this MIB.
               
               Setting this object to 'notSupported' will result
               in an 'inconsistentValue' error.  For entities that
               do not support administrative state, all set
               operations will result in an 'inconsistentValue'
               error.
               
               Some physical entities exhibit only a subset of the
               remaining administrative state values.  Some entities
               cannot be locked, and hence this object exhibits only
               the 'unlocked' state.  Other entities cannot be shutdown
               gracefully, and hence this object does not exhibit the
               'shuttingDown' state.  A value of 'inconsistentValue'
               will be returned if attempts are made to set this
               object to values not supported by its administrative
               model.
          </text>
        </description>
      </leaf>
      <leaf name="entStateOper">
        <type name="entity-state:EntityOperState"/>
        <config value="false"/>
        <description>
          <text>
            The operational state for this entity.
               
               Note that unlike the state model used within the
               Interfaces MIB [RFC2863], this object does not follow
               the administrative state.  An administrative state of
               down does not predict an operational state
               of disabled.
               
               A value of 'testing' means that entity currently being
               tested and cannot therefore report whether it is
               operational or not.
               
               A value of 'disabled' means that an entity is totally
               inoperable and unable to provide service both to entities
               within its containment hierarchy, or to other receivers
               of its service as defined in ways outside the scope of
               this MIB.
               
               A value of 'enabled' means that an entity is fully or
               partially operable and able to provide service both to
               
               
               entities within its containment hierarchy, or to other
               receivers of its service as defined in ways outside the
               scope of this MIB.
               
               Note that some implementations may not be able to
               accurately report entStateOper while the
               entStateAdmin object has a value other than 'unlocked'.
               In these cases, this object MUST have a value
               of 'unknown'.
          </text>
        </description>
      </leaf>
      <leaf name="entStateUsage">
        <type name="entity-state:EntityUsageState"/>
        <config value="false"/>
        <description>
          <text>
            The usage state for this entity.
               
               This object refers to an entity's ability to service more
               physical entities in a containment hierarchy.  A value
               of 'idle' means this entity is able to contain other
               entities but that no other entity is currently
               contained within this entity.
               
               A value of 'active' means that at least one entity is
               contained within this entity, but that it could handle
               more.  A value of 'busy' means that the entity is unable
               to handle any additional entities being contained in it.
               
               Some entities will exhibit only a subset of the
               usage state values.  Entities that are unable to ever
               service any entities within a containment hierarchy will
               always have a usage state of 'busy'.  Some entities will
               only ever be able to support one entity within its
               containment hierarchy and will therefore only exhibit
               values of 'idle' and 'busy'.
          </text>
        </description>
      </leaf>
      <leaf name="entStateAlarm">
        <type name="entity-state:EntityAlarmStatus"/>
        <config value="false"/>
        <description>
          <text>
            The alarm status for this entity.  It does not include
               the alarms raised on child components within its
               containment hierarchy.
               
               A value of 'unknown' means that this entity is
               
               
               
               unable to report alarm state.  Note that this differs
               from 'indeterminate', which means that alarm state
               is supported and there are alarms against this entity,
               but the severity of some of the alarms is not known.
               
               If no bits are set, then this entity supports reporting
               of alarms, but there are currently no active alarms
               against this entity.
          </text>
        </description>
      </leaf>
      <leaf name="entStateStandby">
        <type name="entity-state:EntityStandbyStatus"/>
        <config value="false"/>
        <description>
          <text>
            The standby status for this entity.
               
               Some entities will exhibit only a subset of the
               remaining standby state values.  If this entity
               cannot operate in a standby role, the value of this
               object will always be 'providingService'.
          </text>
        </description>
      </leaf>
    </list>
  </container>





</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="ENTITY-STATE-TC-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:ENTITY-STATE-TC-MIB"/>
  <prefix value="entity-state"/>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IETF Entity MIB Working Group
    </info>
  </organization>
  <contact>
  <info>
  General Discussion: entmib@ietf.org
      To Subscribe:
      http://www.ietf.org/mailman/listinfo/entmib
      
      http://www.ietf.org/html.charters/entmib-charter.html
      
      Sharon Chisholm
      Nortel Networks
      PO Box 3511 Station C
      Ottawa, Ont.  K1Y 4H7
      Canada
      schishol@nortel.com
      
      David T. Perkins
      548 Qualbrook Ct
      San Jose, CA 95110
      USA
      Phone: 408 394-8702
      dperkins@snmpinfo.com
    </info>
  </contact>
  <description>
    <text>
      This MIB defines state textual conventions.
      
      Copyright (C) The Internet Society 2005.  This version
      of this MIB module is part of RFC 4268;  see the RFC
      itself for full legal notices.
    </text>
  </description>
  <revision date="2005-11-22">
    <description>
      <text>
        Initial version, published as RFC 4268.
      </text>
    </description>
  </revision>
  <typedef name="EntityAdminState">
    <type name="enumeration">
      <enum name="unknown">
        <value value="1"/>
      </enum>
      <enum name="locked">
        <value value="2"/>
      </enum>
      <enum name="shuttingDown">
        <value value="3"/>
      </enum>
      <enum name="unlocked">
        <value value="4"/>
      </enum>
    </type>
    <description>
      <text>
         Represents the various possible administrative states.
         
         
         
         
         
         A value of 'locked' means the resource is administratively
         prohibited from use.  A value of 'shuttingDown' means that
         usage is administratively limited to current instances of
         use.  A value of 'unlocked' means the resource is not
         administratively prohibited from use.  A value of
         'unknown' means that this resource is unable to
         report administrative state.
      </text>
    </description>
  </typedef>

  <typedef name="EntityOperState">
    <type name="enumeration">
      <enum name="unknown">
        <value value="1"/>
      </enum>
      <enum name="disabled">
        <value value="2"/>
      </enum>
      <enum name="enabled">
        <value value="3"/>
      </enum>
      <enum name="testing">
        <value value="4"/>
      </enum>
    </type>
    <description>
      <text>
         Represents the possible values of operational states.
         
         A value of 'disabled' means the resource is totally
         inoperable.  A value of 'enabled' means the resource
         is partially or fully operable.  A value of 'testing'
         means the resource is currently being tested
         and cannot therefore report whether it is operational
         or not.  A value of 'unknown' means that this
         resource is unable to report operational state.
      </text>
    </description>
  </typedef>

  <typedef name="EntityUsageState">
    <type name="enumeration">
      <enum name="unknown">
        <value value="1"/>
      </enum>
      <enum name="idle">
        <value value="2"/>
      </enum>
      <enum name="active">
        <value value="3"/>
      </enum>
      <enum name="busy">
        <value value="4"/>
      </enum>
    </type>
    <description>
      <text>
         Represents the possible values of usage states.
         A value of 'idle' means the resource is servicing no
         users.  A value of 'active' means the resource is
         currently in use and it has sufficient spare capacity
         to provide for additional users.  A value of 'busy'
         means the resource is currently in use, but it
         currently has no spare capacity to provide for
         additional users.  A value of 'unknown' means
         that this resource is unable to report usage state.
      </text>
    </description>
  </typedef>

  <typedef name="EntityAlarmStatus">
    <type name="bits">
      <bit name="unknown">
        <position value="0"/>
      </bit>
      <bit name="underRepair">
        <position value="1"/>
      </bit>
      <bit name="critical">
        <position value="2"/>
      </bit>
      <bit name="major">
        <position value="3"/>
      </bit>
      <bit name="minor">
        <position value="4"/>
      </bit>
      <bit name="warning">
        <position value="5"/>
      </bit>
      <bit name="indeterminate">
        <position value="6"/>
      </bit>
    </type>
    <description>
      <text>
         Represents the possible values of alarm status.
         An Alarm [RFC3877] is a persistent indication
         of an error or warning condition.
         
         When no bits of this attribute are set, then no active
         alarms are known against this entity and it is not under
         repair.
         
         When the 'value of underRepair' is set, the resource is
         currently being repaired, which, depending on the
         implementation, may make the other values in this bit
         string not meaningful.
         
         When the value of 'critical' is set, one or more critical
         alarms are active against the resource.  When the value
         of 'major' is set, one or more major alarms are active
         against the resource.  When the value of 'minor' is set,
         one or more minor alarms are active against the resource.
         When the value of 'warning' is set, one or more warning
         alarms are active against the resource.  When the value
         of 'indeterminate' is set, one or more alarms of whose
         perceived severity cannot be determined are active
         against this resource.
         
         A value of 'unknown' means that this resource is
         unable to report alarm state.
      </text>
    </description>
  </typedef>

  <typedef name="EntityStandbyStatus">
    <type name="enumeration">
      <enum name="unknown">
        <value value="1"/>
      </enum>
      <enum name="hotStandby">
        <value value="2"/>
      </enum>
      <enum name="coldStandby">
        <value value="3"/>
      </enum>
      <enum name="providingService">
        <value value="4"/>
      </enum>
    </type>
    <description>
      <text>
         Represents the possible values of standby status.
         
         A value of 'hotStandby' means the resource is not
         providing service, but it will be immediately able to
         take over the role of the resource to be backed up,
         without the need for initialization activity, and will
         contain the same information as the resource to be
         backed up.  A value of 'coldStandy' means that the
         resource is to back up another resource, but will not
         be immediately able to take over the role of a resource
         to be backed up, and will require some initialization
         activity.  A value of 'providingService' means the
         resource is providing service.  A value of
         'unknown' means that this resource is unable to
         report standby state.
      </text>
    </description>
  </typedef>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:if-mib="urn:ietf:params:xml:ns:yang:smiv2:IF-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="EtherLike-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:EtherLike-MIB"/>
  <prefix value="etherlike-mib"/>
  <import module="IF-MIB">
    <prefix value="if-mib"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF Ethernet Interfaces and Hub MIB
      Working Group
    </info>
  </organization>
  <contact>
  <info>
  WG E-mail: hubmib@ietf.org
      To subscribe: hubmib-request@ietf.org
      
             Chair: Dan Romascanu
            Postal: Avaya Inc.
                    Atidum Technology Park, Bldg. 3
                    Tel Aviv 61131
                    Israel
               Tel: +972 3 645 8414
            E-mail: dromasca@avaya.com
      
           Editor: John Flick
           Postal: Hewlett-Packard Company
                   8000 Foothills Blvd. M/S 5557
                   Roseville, CA 95747-5557
                   USA
              Tel: +1 916 785 4018
              Fax: +1 916 785 1199
           E-mail: johnf@rose.hp.com
    </info>
  </contact>
  <description>
    <text>
      The MIB module to describe generic objects for
      ethernet-like network interfaces.
      
      The following reference is used throughout this
      MIB module:
      
      [IEEE 802.3 Std] refers to:
         IEEE Std 802.3, 2002 Edition: 'IEEE Standard
      
         for Information technology -
         Telecommunications and information exchange
         between systems - Local and metropolitan
         area networks - Specific requirements -
         Part 3: Carrier sense multiple access with
         collision detection (CSMA/CD) access method
         and physical layer specifications', as
         amended by IEEE Std 802.3ae-2002:
         'Amendment: Media Access Control (MAC)
         Parameters, Physical Layer, and Management
         Parameters for 10 Gb/s Operation', August,
         2002.
      
      Of particular interest is Clause 30, '10 Mb/s,
      100 Mb/s, 1000 Mb/s, and 10 Gb/s Management'.
      
      Copyright (C) The Internet Society (2003).  This
      version of this MIB module is part of RFC 3635;
      see the RFC itself for full legal notices.
    </text>
  </description>
  <revision date="2003-09-19">
    <description>
      <text>
        Updated to include support for 10 Gb/sec
         interfaces.  This resulted in the following
         revisions:
         
         - Updated dot3StatsAlignmentErrors and
           dot3StatsSymbolErrors DESCRIPTIONs to
           reflect behaviour at 10 Gb/s
         - Added dot3StatsRateControlAbility and
           dot3RateControlStatus for management
           of the Rate Control function in 10 Gb/s
           WAN applications
         - Added 64-bit versions of all counters
           that are used on high-speed ethernet
           interfaces
         - Added object groups to contain the new
           objects
         - Deprecated etherStatsBaseGroup and
           split into etherStatsBaseGroup2 and
           etherStatsHalfDuplexGroup, so that
           interfaces which can only operate at
           full-duplex do not need to implement
           half-duplex-only statistics
         - Deprecated dot3Compliance and replaced
           it with dot3Compliance2, which includes
           the compliance information for the new
           object groups
         
         In addition, the dot3Tests and dot3Errors
         object identities have been deprecated,
         since there is no longer a standard method
         for using them.
         
         This version published as RFC 3635.
      </text>
    </description>
  </revision>
  <revision date="1999-08-24">
    <description>
      <text>
        Updated to include support for 1000 Mb/sec
         interfaces and full-duplex interfaces.
         This version published as RFC 2665.
      </text>
    </description>
  </revision>
  <revision date="1998-06-03">
    <description>
      <text>
        Updated to include support for 100 Mb/sec
         interfaces.
         This version published as RFC 2358.
      </text>
    </description>
  </revision>
  <revision date="1994-02-03">
    <description>
      <text>
        Initial version, published as RFC 1650.
      </text>
    </description>
  </revision>
  <container name="dot3">
    <list name="dot3StatsEntry">
      <key value="dot3StatsIndex"/>
      <description>
        <text>
          Statistics for a particular interface to an
            ethernet-like medium.
        </text>
      </description>
      <leaf name="dot3StatsIndex">
        <type name="if-mib:InterfaceIndex"/>
        <description>
          <text>
            An index value that uniquely identifies an
               interface to an ethernet-like medium.  The
               interface identified by a particular value of
               this index is the same interface as identified
               by the same value of ifIndex.
          </text>
        </description>
        <reference info="RFC 2863, ifIndex"/>
      </leaf>
      <leaf name="dot3StatsAlignmentErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames received on a particular
               interface that are not an integral number of
               octets in length and do not pass the FCS check.
               
               The count represented by an instance of this
               object is incremented when the alignmentError
               status is returned by the MAC service to the
               LLC (or other MAC user). Received frames for
               which multiple error conditions pertain are,
               according to the conventions of IEEE 802.3
               Layer Management, counted exclusively according
               
               to the error status presented to the LLC.
               
               This counter does not increment for group
               encoding schemes greater than 4 bits per group.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCStatsAlignmentErrors object for 10 Gb/s
               or faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.7,
               aAlignmentErrors"/>
      </leaf>
      <leaf name="dot3StatsFCSErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames received on a particular
               interface that are an integral number of octets
               in length but do not pass the FCS check.  This
               count does not include frames received with
               frame-too-long or frame-too-short error.
               
               The count represented by an instance of this
               object is incremented when the frameCheckError
               status is returned by the MAC service to the
               LLC (or other MAC user). Received frames for
               which multiple error conditions pertain are,
               according to the conventions of IEEE 802.3
               Layer Management, counted exclusively according
               to the error status presented to the LLC.
               
               Note:  Coding errors detected by the physical
               layer for speeds above 10 Mb/s will cause the
               frame to fail the FCS check.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCStatsFCSErrors object for 10 Gb/s or
               faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.6,
               aFrameCheckSequenceErrors."/>
      </leaf>
      <leaf name="dot3StatsSingleCollisionFrames">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames that are involved in a single
               collision, and are subsequently transmitted
               successfully.
               
               A frame that is counted by an instance of this
               object is also counted by the corresponding
               instance of either the ifOutUcastPkts,
               ifOutMulticastPkts, or ifOutBroadcastPkts,
               and is not counted by the corresponding
               instance of the dot3StatsMultipleCollisionFrames
               object.
               
               This counter does not increment when the
               interface is operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.3,
               aSingleCollisionFrames."/>
      </leaf>
      <leaf name="dot3StatsMultipleCollisionFrames">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames that are involved in more
               
               than one collision and are subsequently
               transmitted successfully.
               
               A frame that is counted by an instance of this
               object is also counted by the corresponding
               instance of either the ifOutUcastPkts,
               ifOutMulticastPkts, or ifOutBroadcastPkts,
               and is not counted by the corresponding
               instance of the dot3StatsSingleCollisionFrames
               object.
               
               This counter does not increment when the
               interface is operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.4,
               aMultipleCollisionFrames."/>
      </leaf>
      <leaf name="dot3StatsSQETestErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of times that the SQE TEST ERROR
               is received on a particular interface. The
               SQE TEST ERROR is set in accordance with the
               rules for verification of the SQE detection
               mechanism in the PLS Carrier Sense Function as
               described in IEEE Std. 802.3, 2000 Edition,
               section 7.2.4.6.
               
               This counter does not increment on interfaces
               operating at speeds greater than 10 Mb/s, or on
               interfaces operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 7.2.4.6, also 30.3.2.1.4,
               aSQETestErrors."/>
      </leaf>
      <leaf name="dot3StatsDeferredTransmissions">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames for which the first
               transmission attempt on a particular interface
               is delayed because the medium is busy.
               
               The count represented by an instance of this
               object does not include frames involved in
               collisions.
               
               This counter does not increment when the
               interface is operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.9,
               aFramesWithDeferredXmissions."/>
      </leaf>
      <leaf name="dot3StatsLateCollisions">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            The number of times that a collision is
               detected on a particular interface later than
               one slotTime into the transmission of a packet.
               
               A (late) collision included in a count
               represented by an instance of this object is
               also considered as a (generic) collision for
               purposes of other collision-related
               statistics.
               
               This counter does not increment when the
               interface is operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.10,
               aLateCollisions."/>
      </leaf>
      <leaf name="dot3StatsExcessiveCollisions">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames for which transmission on a
               particular interface fails due to excessive
               collisions.
               
               This counter does not increment when the
               interface is operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.11,
               aFramesAbortedDueToXSColls."/>
      </leaf>
      <leaf name="dot3StatsInternalMacTransmitErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames for which transmission on a
               particular interface fails due to an internal
               MAC sublayer transmit error. A frame is only
               counted by an instance of this object if it is
               not counted by the corresponding instance of
               either the dot3StatsLateCollisions object, the
               dot3StatsExcessiveCollisions object, or the
               dot3StatsCarrierSenseErrors object.
               
               The precise meaning of the count represented by
               an instance of this object is implementation-
               specific.  In particular, an instance of this
               object may represent a count of transmission
               errors on a particular interface that are not
               otherwise counted.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCStatsInternalMacTransmitErrors object for
               10 Gb/s or faster interfaces.
               
               Discontinuities in the value of this counter can
               
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.12,
               aFramesLostDueToIntMACXmitError."/>
      </leaf>
      <leaf name="dot3StatsCarrierSenseErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            The number of times that the carrier sense
               condition was lost or never asserted when
               attempting to transmit a frame on a particular
               interface.
               
               The count represented by an instance of this
               object is incremented at most once per
               transmission attempt, even if the carrier sense
               condition fluctuates during a transmission
               attempt.
               
               This counter does not increment when the
               interface is operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.13,
               aCarrierSenseErrors."/>
      </leaf>
      <leaf name="dot3StatsFrameTooLongs">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames received on a particular
               interface that exceed the maximum permitted
               frame size.
               
               The count represented by an instance of this
               object is incremented when the frameTooLong
               status is returned by the MAC service to the
               LLC (or other MAC user). Received frames for
               which multiple error conditions pertain are,
               according to the conventions of IEEE 802.3
               Layer Management, counted exclusively according
               to the error status presented to the LLC.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 80 minutes if
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCStatsFrameTooLongs object for 10 Gb/s
               or faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.25,
               aFrameTooLongErrors."/>
      </leaf>
      <leaf name="dot3StatsInternalMacReceiveErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames for which reception on a
               particular interface fails due to an internal
               MAC sublayer receive error. A frame is only
               counted by an instance of this object if it is
               not counted by the corresponding instance of
               either the dot3StatsFrameTooLongs object, the
               dot3StatsAlignmentErrors object, or the
               dot3StatsFCSErrors object.
               
               The precise meaning of the count represented by
               an instance of this object is implementation-
               specific.  In particular, an instance of this
               object may represent a count of receive errors
               on a particular interface that are not
               otherwise counted.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCStatsInternalMacReceiveErrors object for
               10 Gb/s or faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.15,
               aFramesLostDueToIntMACRcvError."/>
      </leaf>
      <leaf name="dot3StatsEtherChipSet">
        <type name="yang:object-identifier"/>
        <config value="false"/>
        <status value="deprecated"/>
        <description>
          <text>
            ******** THIS OBJECT IS DEPRECATED ********
               
               This object contains an OBJECT IDENTIFIER
               which identifies the chipset used to
               realize the interface. Ethernet-like
               interfaces are typically built out of
               several different chips. The MIB implementor
               is presented with a decision of which chip
               to identify via this object. The implementor
               should identify the chip which is usually
               called the Medium Access Control chip.
               If no such chip is easily identifiable,
               the implementor should identify the chip
               which actually gathers the transmit
               and receive statistics and error
               indications. This would allow a
               manager station to correlate the
               statistics and the chip generating
               them, giving it the ability to take
               into account any known anomalies
               in the chip.
               
               This object has been deprecated.  Implementation
               feedback indicates that it is of limited use for
               debugging network problems in the field, and
               the administrative overhead involved in
               maintaining a registry of chipset OIDs is not
               justified.
          </text>
        </description>
      </leaf>
      <leaf name="dot3StatsSymbolErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            For an interface operating at 100 Mb/s, the
               number of times there was an invalid data symbol
               when a valid carrier was present.
               
               For an interface operating in half-duplex mode
               at 1000 Mb/s, the number of times the receiving
               media is non-idle (a carrier event) for a period
               of time equal to or greater than slotTime, and
               during which there was at least one occurrence
               of an event that causes the PHY to indicate
               'Data reception error' or 'carrier extend error'
               on the GMII.
               
               For an interface operating in full-duplex mode
               at 1000 Mb/s, the number of times the receiving
               media is non-idle (a carrier event) for a period
               of time equal to or greater than minFrameSize,
               and during which there was at least one
               occurrence of an event that causes the PHY to
               indicate 'Data reception error' on the GMII.
               
               For an interface operating at 10 Gb/s, the
               number of times the receiving media is non-idle
               (a carrier event) for a period of time equal to
               or greater than minFrameSize, and during which
               there was at least one occurrence of an event
               that causes the PHY to indicate 'Receive Error'
               on the XGMII.
               
               The count represented by an instance of this
               object is incremented at most once per carrier
               event, even if multiple symbol errors occur
               during the carrier event.  This count does
               not increment if a collision is present.
               
               This counter does not increment when the
               interface is operating at 10 Mb/s.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCStatsSymbolErrors object for 10 Gb/s
               or faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.2.1.5,
               aSymbolErrorDuringCarrier."/>
      </leaf>
      <leaf name="dot3StatsDuplexStatus">
        <type name="enumeration">
          <enum name="unknown">
            <value value="1"/>
          </enum>
          <enum name="halfDuplex">
            <value value="2"/>
          </enum>
          <enum name="fullDuplex">
            <value value="3"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The current mode of operation of the MAC
               entity.  'unknown' indicates that the current
               duplex mode could not be determined.
               
               Management control of the duplex mode is
               accomplished through the MAU MIB.  When
               an interface does not support autonegotiation,
               or when autonegotiation is not enabled, the
               duplex mode is controlled using
               ifMauDefaultType.  When autonegotiation is
               supported and enabled, duplex mode is controlled
               using ifMauAutoNegAdvertisedBits.  In either
               case, the currently operating duplex mode is
               reflected both in this object and in ifMauType.
               
               Note that this object provides redundant
               information with ifMauType.  Normally, redundant
               objects are discouraged.  However, in this
               instance, it allows a management application to
               determine the duplex status of an interface
               without having to know every possible value of
               ifMauType.  This was felt to be sufficiently
               valuable to justify the redundancy.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.32,
               aDuplexStatus."/>
      </leaf>
      <leaf name="dot3StatsRateControlAbility">
        <type name="smiv2:TruthValue"/>
        <config value="false"/>
        <description>
          <text>
            'true' for interfaces operating at speeds above
               1000 Mb/s that support Rate Control through
               lowering the average data rate of the MAC
               sublayer, with frame granularity, and 'false'
               otherwise.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.33,
               aRateControlAbility."/>
      </leaf>
      <leaf name="dot3StatsRateControlStatus">
        <type name="enumeration">
          <enum name="rateControlOff">
            <value value="1"/>
          </enum>
          <enum name="rateControlOn">
            <value value="2"/>
          </enum>
          <enum name="unknown">
            <value value="3"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The current Rate Control mode of operation of
               the MAC sublayer of this interface.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.34,
               aRateControlStatus."/>
      </leaf>
    </list>
    <list name="dot3CollEntry">
      <key value="ifIndex dot3CollCount"/>
      <description>
        <text>
          A cell in the histogram of per-frame
            collisions for a particular interface.  An
            
            instance of this object represents the
            frequency of individual MAC frames for which
            the transmission (successful or otherwise) on a
            particular interface is accompanied by a
            particular number of media collisions.
        </text>
      </description>
      <leaf name="ifIndex">
        <type name="leafref">
          <path value="/if-mib:interfaces/if-mib:ifEntry/if-mib:ifIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="dot3CollCount">
        <type name="int32">
          <range value="1..16"/>
        </type>
        <description>
          <text>
            The number of per-frame media collisions for
               which a particular collision histogram cell
               represents the frequency on a particular
               interface.
          </text>
        </description>
      </leaf>
      <leaf name="dot3CollFrequencies">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of individual MAC frames for which the
               transmission (successful or otherwise) on a
               particular interface occurs after the
               frame has experienced exactly the number
               of collisions in the associated
               dot3CollCount object.
               
               For example, a frame which is transmitted
               on interface 77 after experiencing
               exactly 4 collisions would be indicated
               by incrementing only dot3CollFrequencies.77.4.
               No other instance of dot3CollFrequencies would
               be incremented in this example.
               
               This counter does not increment when the
               interface is operating in full-duplex mode.
               
               Discontinuities in the value of this counter can
               
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
      </leaf>
    </list>
    <list name="dot3ControlEntry">
      <key value="dot3StatsIndex"/>
      <description>
        <text>
          An entry in the table, containing information
            about the MAC Control sublayer on a single
            ethernet-like interface.
        </text>
      </description>
      <leaf name="dot3StatsIndex">
        <type name="leafref">
          <path value="/etherlike-mib:dot3/etherlike-mib:dot3StatsEntry/etherlike-mib:dot3StatsIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="dot3ControlFunctionsSupported">
        <type name="bits">
          <bit name="pause">
            <position value="0"/>
          </bit>
        </type>
        <config value="false"/>
        <description>
          <text>
            A list of the possible MAC Control functions
               implemented for this interface.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.3.2,
               aMACControlFunctionsSupported."/>
      </leaf>
      <leaf name="dot3ControlInUnknownOpcodes">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of MAC Control frames received on this
               interface that contain an opcode that is not
               supported by this device.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCControlInUnknownOpcodes object for 10 Gb/s
               or faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.3.5,
               aUnsupportedOpcodesReceived"/>
      </leaf>
      <leaf name="dot3HCControlInUnknownOpcodes">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of MAC Control frames received on this
               interface that contain an opcode that is not
               supported by this device.
               
               This counter is a 64 bit version of
               dot3ControlInUnknownOpcodes.  It should be used
               on interfaces operating at 10 Gb/s or faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.3.5,
               aUnsupportedOpcodesReceived"/>
      </leaf>
    </list>
    <list name="dot3PauseEntry">
      <key value="dot3StatsIndex"/>
      <description>
        <text>
          An entry in the table, containing information
            about the MAC Control PAUSE function on a single
            ethernet-like interface.
        </text>
      </description>
      <leaf name="dot3StatsIndex">
        <type name="leafref">
          <path value="/etherlike-mib:dot3/etherlike-mib:dot3StatsEntry/etherlike-mib:dot3StatsIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="dot3PauseAdminMode">
        <type name="enumeration">
          <enum name="disabled">
            <value value="1"/>
          </enum>
          <enum name="enabledXmit">
            <value value="2"/>
          </enum>
          <enum name="enabledRcv">
            <value value="3"/>
          </enum>
          <enum name="enabledXmitAndRcv">
            <value value="4"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            This object is used to configure the default
               administrative PAUSE mode for this interface.
               
               This object represents the
               administratively-configured PAUSE mode for this
               interface.  If auto-negotiation is not enabled
               or is not implemented for the active MAU
               attached to this interface, the value of this
               object determines the operational PAUSE mode
               of the interface whenever it is operating in
               full-duplex mode.  In this case, a set to this
               object will force the interface into the
               specified mode.
               
               If auto-negotiation is implemented and enabled
               for the MAU attached to this interface, the
               PAUSE mode for this interface is determined by
               auto-negotiation, and the value of this object
               denotes the mode to which the interface will
               automatically revert if/when auto-negotiation is
               later disabled.  Note that when auto-negotiation
               is running, administrative control of the PAUSE
               mode may be accomplished using the
               ifMauAutoNegCapAdvertisedBits object in the
               MAU-MIB.
               
               Note that the value of this object is ignored
               when the interface is not operating in
               full-duplex mode.
               
               An attempt to set this object to
               'enabledXmit(2)' or 'enabledRcv(3)' will fail
               on interfaces that do not support operation
               at greater than 100 Mb/s.
          </text>
        </description>
      </leaf>
      <leaf name="dot3PauseOperMode">
        <type name="enumeration">
          <enum name="disabled">
            <value value="1"/>
          </enum>
          <enum name="enabledXmit">
            <value value="2"/>
          </enum>
          <enum name="enabledRcv">
            <value value="3"/>
          </enum>
          <enum name="enabledXmitAndRcv">
            <value value="4"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            This object reflects the PAUSE mode currently
               
               in use on this interface, as determined by
               either (1) the result of the auto-negotiation
               function or (2) if auto-negotiation is not
               enabled or is not implemented for the active MAU
               attached to this interface, by the value of
               dot3PauseAdminMode.  Interfaces operating at
               100 Mb/s or less will never return
               'enabledXmit(2)' or 'enabledRcv(3)'.  Interfaces
               operating in half-duplex mode will always return
               'disabled(1)'.  Interfaces on which
               auto-negotiation is enabled but not yet
               completed should return the value
               'disabled(1)'.
          </text>
        </description>
      </leaf>
      <leaf name="dot3InPauseFrames">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of MAC Control frames received on this
               interface with an opcode indicating the PAUSE
               operation.
               
               This counter does not increment when the
               interface is operating in half-duplex mode.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCInPauseFrames object for 10 Gb/s or
               faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.4.3,
               aPAUSEMACCtrlFramesReceived."/>
      </leaf>
      <leaf name="dot3OutPauseFrames">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            A count of MAC Control frames transmitted on
               this interface with an opcode indicating the
               PAUSE operation.
               
               This counter does not increment when the
               interface is operating in half-duplex mode.
               
               For interfaces operating at 10 Gb/s, this
               counter can roll over in less than 5 minutes if
               it is incrementing at its maximum rate.  Since
               that amount of time could be less than a
               management station's poll cycle time, in order
               to avoid a loss of information, a management
               station is advised to poll the
               dot3HCOutPauseFrames object for 10 Gb/s or
               faster interfaces.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.4.2,
               aPAUSEMACCtrlFramesTransmitted."/>
      </leaf>
      <leaf name="dot3HCInPauseFrames">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of MAC Control frames received on this
               interface with an opcode indicating the PAUSE
               operation.
               
               This counter does not increment when the
               interface is operating in half-duplex mode.
               
               This counter is a 64 bit version of
               dot3InPauseFrames.  It should be used on
               interfaces operating at 10 Gb/s or faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.4.3,
               aPAUSEMACCtrlFramesReceived."/>
      </leaf>
      <leaf name="dot3HCOutPauseFrames">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of MAC Control frames transmitted on
               this interface with an opcode indicating the
               PAUSE operation.
               
               This counter does not increment when the
               interface is operating in half-duplex mode.
               
               This counter is a 64 bit version of
               dot3OutPauseFrames.  It should be used on
               interfaces operating at 10 Gb/s or faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.4.2,
               aPAUSEMACCtrlFramesTransmitted."/>
      </leaf>
    </list>
    <list name="dot3HCStatsEntry">
      <key value="dot3StatsIndex"/>
      <description>
        <text>
          An entry containing 64-bit statistics for a
            single ethernet-like interface.
        </text>
      </description>
      <leaf name="dot3StatsIndex">
        <type name="leafref">
          <path value="/etherlike-mib:dot3/etherlike-mib:dot3StatsEntry/etherlike-mib:dot3StatsIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="dot3HCStatsAlignmentErrors">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames received on a particular
               interface that are not an integral number of
               octets in length and do not pass the FCS check.
               
               The count represented by an instance of this
               object is incremented when the alignmentError
               status is returned by the MAC service to the
               LLC (or other MAC user). Received frames for
               which multiple error conditions pertain are,
               according to the conventions of IEEE 802.3
               Layer Management, counted exclusively according
               to the error status presented to the LLC.
               
               This counter does not increment for group
               encoding schemes greater than 4 bits per group.
               
               This counter is a 64 bit version of
               dot3StatsAlignmentErrors.  It should be used
               on interfaces operating at 10 Gb/s or faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.7,
               aAlignmentErrors"/>
      </leaf>
      <leaf name="dot3HCStatsFCSErrors">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames received on a particular
               interface that are an integral number of octets
               in length but do not pass the FCS check.  This
               count does not include frames received with
               frame-too-long or frame-too-short error.
               
               The count represented by an instance of this
               object is incremented when the frameCheckError
               status is returned by the MAC service to the
               LLC (or other MAC user). Received frames for
               which multiple error conditions pertain are,
               according to the conventions of IEEE 802.3
               Layer Management, counted exclusively according
               to the error status presented to the LLC.
               
               Note:  Coding errors detected by the physical
               layer for speeds above 10 Mb/s will cause the
               frame to fail the FCS check.
               
               This counter is a 64 bit version of
               dot3StatsFCSErrors.  It should be used on
               interfaces operating at 10 Gb/s or faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.6,
               aFrameCheckSequenceErrors."/>
      </leaf>
      <leaf name="dot3HCStatsInternalMacTransmitErrors">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames for which transmission on a
               particular interface fails due to an internal
               MAC sublayer transmit error. A frame is only
               
               counted by an instance of this object if it is
               not counted by the corresponding instance of
               either the dot3StatsLateCollisions object, the
               dot3StatsExcessiveCollisions object, or the
               dot3StatsCarrierSenseErrors object.
               
               The precise meaning of the count represented by
               an instance of this object is implementation-
               specific.  In particular, an instance of this
               object may represent a count of transmission
               errors on a particular interface that are not
               otherwise counted.
               
               This counter is a 64 bit version of
               dot3StatsInternalMacTransmitErrors.  It should
               be used on interfaces operating at 10 Gb/s or
               faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.12,
               aFramesLostDueToIntMACXmitError."/>
      </leaf>
      <leaf name="dot3HCStatsFrameTooLongs">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames received on a particular
               interface that exceed the maximum permitted
               frame size.
               
               The count represented by an instance of this
               object is incremented when the frameTooLong
               status is returned by the MAC service to the
               LLC (or other MAC user). Received frames for
               which multiple error conditions pertain are,
               according to the conventions of IEEE 802.3
               Layer Management, counted exclusively according
               to the error status presented to the LLC.
               
               This counter is a 64 bit version of
               dot3StatsFrameTooLongs.  It should be used on
               interfaces operating at 10 Gb/s or faster.
               
               Discontinuities in the value of this counter can
               
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.25,
               aFrameTooLongErrors."/>
      </leaf>
      <leaf name="dot3HCStatsInternalMacReceiveErrors">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            A count of frames for which reception on a
               particular interface fails due to an internal
               MAC sublayer receive error. A frame is only
               counted by an instance of this object if it is
               not counted by the corresponding instance of
               either the dot3StatsFrameTooLongs object, the
               dot3StatsAlignmentErrors object, or the
               dot3StatsFCSErrors object.
               
               The precise meaning of the count represented by
               an instance of this object is implementation-
               specific.  In particular, an instance of this
               object may represent a count of receive errors
               on a particular interface that are not
               otherwise counted.
               
               This counter is a 64 bit version of
               dot3StatsInternalMacReceiveErrors.  It should be
               used on interfaces operating at 10 Gb/s or
               faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.1.1.15,
               aFramesLostDueToIntMACRcvError."/>
      </leaf>
      <leaf name="dot3HCStatsSymbolErrors">
        <type name="yang:counter64"/>
        <config value="false"/>
        <description>
          <text>
            For an interface operating at 100 Mb/s, the
               number of times there was an invalid data symbol
               when a valid carrier was present.
               
               For an interface operating in half-duplex mode
               at 1000 Mb/s, the number of times the receiving
               media is non-idle (a carrier event) for a period
               of time equal to or greater than slotTime, and
               during which there was at least one occurrence
               of an event that causes the PHY to indicate
               'Data reception error' or 'carrier extend error'
               on the GMII.
               
               For an interface operating in full-duplex mode
               at 1000 Mb/s, the number of times the receiving
               media is non-idle (a carrier event) for a period
               of time equal to or greater than minFrameSize,
               and during which there was at least one
               occurrence of an event that causes the PHY to
               indicate 'Data reception error' on the GMII.
               
               For an interface operating at 10 Gb/s, the
               number of times the receiving media is non-idle
               (a carrier event) for a period of time equal to
               or greater than minFrameSize, and during which
               there was at least one occurrence of an event
               that causes the PHY to indicate 'Receive Error'
               on the XGMII.
               
               The count represented by an instance of this
               object is incremented at most once per carrier
               event, even if multiple symbol errors occur
               during the carrier event.  This count does
               not increment if a collision is present.
               
               This counter is a 64 bit version of
               dot3StatsSymbolErrors.  It should be used on
               interfaces operating at 10 Gb/s or faster.
               
               Discontinuities in the value of this counter can
               occur at re-initialization of the management
               system, and at other times as indicated by the
               value of ifCounterDiscontinuityTime.
          </text>
        </description>
        <reference info="[IEEE 802.3 Std.], 30.3.2.1.5,
               aSymbolErrorDuringCarrier."/>
      </leaf>
    </list>
  </container>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:inet="urn:ietf:params:xml:ns:yang:inet-types"
        name="examples">
  <namespace uri="http://netconfcentral.com/ns/examples"/>
  <prefix value="ex"/>
  <import module="ietf-inet-types">
    <prefix value="inet"/>
  </import>
  <organization>
  <info>
    Netconf Central
    </info>
  </organization>
  <contact>
  <info>
  Andy Bierman
    </info>
  </contact>
  <description>
    <text>
      Some YANG draft examples.
    </text>
  </description>
  <revision date="2008-11-09">
    <description>
      <text>
        Initial version.
      </text>
    </description>
  </revision>
  <container name="system">
    <leaf name="host-name">
      <type name="string"/>
      <description>
        <text>
          Hostname for this system
        </text>
      </description>
    </leaf>
    <leaf-list name="domain-search"/>
      <type name="string"/>
      <description>
        <text>
          List of domain names to search
        </text>
      </description>
    </leaflist>
    <container name="login">
      <leaf name="message">
        <type name="string"/>
        <description>
          <text>
            Message given at start of login session
          </text>
        </description>
      </leaf>
      <list name="user">
        <key value="name"/>
        <leaf name="name">
          <type name="string"/>
        </leaf>
        <leaf name="full-name">
          <type name="string"/>
        </leaf>
        <leaf name="class">
          <type name="string"/>
        </leaf>
      </list>
    </container>
    <container name="services">
      <description>
        <text>
          Configure externally available services
        </text>
      </description>
      <container name="ssh">
        <presence>
          <text>
            presence "Enables SSH";
          </text>
        </presence>
        <description>
          <text>
            SSH service specific configuration
          </text>
        </description>
      </container>
    </container>
    <list name="server">
      <key value="name"/>
      <unique tag="ip port"/>
      <leaf name="name">
        <type name="string"/>
      </leaf>
      <leaf name="ip">
        <type name="inet:ip-address"/>
      </leaf>
      <leaf name="port">
        <type name="inet:port-number"/>
      </leaf>
    </list>
  </container>

  <leaf name="mgmt-interface">
    <type name="leafref">
      <path value="../interfaces/interface/name"/>
    </type>
  </leaf>

  <container name="default-address">
    <leaf name="ifname">
      <type name="leafref">
        <path value="../../interfaces/interface/name"/>
      </type>
    </leaf>
    <leaf name="address">
      <type name="leafref">
        <path value="../../interfaces/interface[name = current()/../ifname]" + "/address/ip"/>
      </type>
    </leaf>
  </container>

  <container name="interfaces">
    <list name="interface">
      <must condition="ifType != 'ethernet' or " + "(ifType = 'ethernet' and ifMTU = 1500)">
          <error-message>
            <text>
              An ethernet MTU must be 1500
            </text>
          </error-message>
      </must>
      <must condition="ifType != 'atm' or " + "(ifType = 'atm' and ifMTU <= 17966 and ifMTU >= 64)">
          <error-message>
            <text>
              An atm MTU must be  64 .. 17966
            </text>
          </error-message>
      </must>
      <key value="name"/>
      <config value="true"/>
      <leaf name="name">
        <type name="string"/>
      </leaf>
      <leaf name="type">
        <type name="string"/>
      </leaf>
      <leaf name="speed">
        <type name="enumeration">
            <enum name="10m"/>
            <enum name="100m"/>
            <enum name="auto"/>
        </type>
      </leaf>
      <leaf name="observed-speed">
        <type name="uint32"/>
        <config value="false"/>
      </leaf>
      <list name="address">
        <key value="ip"/>
        <leaf name="ip">
          <type name="inet:ip-address"/>
        </leaf>
      </list>
      <leaf name="ifType">
        <type name="enumeration">
            <enum name="ethernet"/>
            <enum name="atm"/>
        </type>
      </leaf>
      <leaf name="ifMTU">
        <type name="uint32"/>
      </leaf>
    </list>
  </container>

  <typedef name="percent">
    <type name="uint16">
      <range value="0 .. 100"/>
    </type>
    <description>
      <text>
        Percentage
      </text>
    </description>
  </typedef>

  <leaf name="completed">
    <type name="percent"/>
  </leaf>

  <grouping name="target">
    <leaf name="address">
      <type name="inet:ip-address"/>
      <description>
        <text>
          Target IP address
        </text>
      </description>
    </leaf>
    <leaf name="port">
      <type name="inet:port-number"/>
      <description>
        <text>
          Target port number
        </text>
      </description>
    </leaf>
  </grouping>

  <container name="peer">
    <container name="destination">
      <uses name="target"/>
    </container>
  </container>

  <container name="food">
    <choice name="snack">
      <mandatory value="true"/>
      <case name="sports-arena">
        <leaf name="pretzel">
          <type name="empty"/>
        </leaf>
        <leaf name="beer">
          <type name="empty"/>
        </leaf>
      </case>
      <case name="late-night">
        <leaf name="chocolate">
          <type name="enumeration">
              <enum name="dark"/>
              <enum name="milk"/>
              <enum name="first-available"/>
          </type>
        </leaf>
      </case>
    </choice>
  </container>

  <augment target-node="/system/login/user">
    <when condition="class != 'wheel'"/>
    <leaf name="uid">
      <type name="uint16">
        <range value="1000 .. 30000"/>
      </type>
    </leaf>
  </augment>





  <container name="transfer">
    <choice name="how">
      <default value="interval"/>
      <case name="interval">
        <leaf name="interval">
          <type name="uint16"/>
          <units name ="minutes"/>
          <default value="30"/>
        </leaf>
      </case>
      <case name="daily">
        <leaf name="daily">
          <type name="empty"/>
        </leaf>
        <leaf name="time-of-day">
          <type name="string"/>
          <units name ="24-hour-clock"/>
          <default value="1am"/>
        </leaf>
      </case>
      <case name="manual">
        <leaf name="manual">
          <type name="empty"/>
        </leaf>
      </case>
    </choice>
  </container>

  <container name="protocol">
    <choice name="name">
      <case name="a">
        <leaf name="udp">
          <type name="empty"/>
        </leaf>
      </case>
      <case name="b">
        <leaf name="tcp">
          <type name="empty"/>
        </leaf>
      </case>
    </choice>
  </container>

  <grouping name="address">
    <description>
      <text>
        A reusable address group.
      </text>
    </description>
    <leaf name="ip">
      <type name="inet:ip-address"/>
    </leaf>
    <leaf name="port">
      <type name="inet:port-number"/>
    </leaf>
  </grouping>

  <container name="http-server">
    <leaf name="name">
      <type name="string"/>
    </leaf>
    <uses name="ex:address"/>

    </uses>
  </container>

  <list name="server">
    <key value="ip port"/>
    <leaf name="name">
      <type name="string"/>
    </leaf>
    <uses name="ex:address"/>
  </list>





  <typedef name="ChannelNumber">
    <type name="int32">
      <range value="0..max"/>
    </type>
  </typedef>

  <augment target-node="/ex:interfaces/ex:interface">
    <when condition="ex:type='ds0'"/>
    <leaf name="ds0ChannelNumber">
      <type name="ChannelNumber"/>
    </leaf>
  </augment>




  <leaf name="crypto">
    <type name="identityref">
    </type>
  </leaf>


  <container name="syslog">
    <leaf name="local-storage-limit">
      <type name="uint32"/>
      <units name ="bytes"/>
      <config value="false"/>
      <description>
        <text>
          The amount of local storage that can be
                used to hold syslog messages.
        </text>
      </description>
    </leaf>
  </container>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="HCNUM-TC">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:HCNUM-TC"/>
  <prefix value="hcnum-tc"/>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF OPS Area
    </info>
  </organization>
  <contact>
  <info>
          E-mail: mibs@ops.ietf.org
      Subscribe: majordomo@psg.com
        with msg body: subscribe mibs
      
      Andy Bierman
      Cisco Systems Inc.
      170 West Tasman Drive
      San Jose, CA 95134 USA
      +1 408-527-3711
      abierman@cisco.com
      
      Keith McCloghrie
      Cisco Systems Inc.
      170 West Tasman Drive
      San Jose, CA 95134 USA
      +1 408-526-5260
      kzm@cisco.com
      
      Randy Presuhn
      BMC Software, Inc.
      Office 1-3141
      2141 North First Street
      San Jose,  California 95131 USA
      +1 408 546-1006
      rpresuhn@bmc.com
    </info>
  </contact>
  <description>
    <text>
      A MIB module containing textual conventions
      for high capacity data types. This module
      addresses an immediate need for data types not directly
      supported in the SMIv2. This short-term solution
      is meant to be deprecated as a long-term solution
      is deployed.
    </text>
  </description>
  <revision date="2000-06-08">
    <description>
      <text>
        Initial Version of the High Capacity Numbers
         MIB module, published as RFC 2856.
      </text>
    </description>
  </revision>
  <typedef name="CounterBasedGauge64">
    <type name="yang:counter64"/>
    <description>
      <text>
        The CounterBasedGauge64 type represents a non-negative
         integer, which may increase or decrease, but shall never
         exceed a maximum value, nor fall below a minimum value. The
         maximum value can not be greater than 2^64-1
         (18446744073709551615 decimal), and the minimum value can
         
         not be smaller than 0.  The value of a CounterBasedGauge64
         has its maximum value whenever the information being modeled
         is greater than or equal to its maximum value, and has its
         minimum value whenever the information being modeled is
         smaller than or equal to its minimum value.  If the
         information being modeled subsequently decreases below
         (increases above) the maximum (minimum) value, the
         CounterBasedGauge64 also decreases (increases).
         
         Note that this TC is not strictly supported in SMIv2,
         because the 'always increasing' and 'counter wrap' semantics
         associated with the Counter64 base type are not preserved.
         It is possible that management applications which rely
         solely upon the (Counter64) ASN.1 tag to determine object
         semantics will mistakenly operate upon objects of this type
         as they would for Counter64 objects.
         
         This textual convention represents a limited and short-term
         solution, and may be deprecated as a long term solution is
         defined and deployed to replace it.
      </text>
    </description>
  </typedef>

  <typedef name="ZeroBasedCounter64">
    <type name="yang:counter64"/>
    <description>
      <text>
        This TC describes an object which counts events with the
         following semantics: objects of this type will be set to
         zero(0) on creation and will thereafter count appropriate
         events, wrapping back to zero(0) when the value 2^64 is
         reached.
         
         Provided that an application discovers the new object within
         the minimum time to wrap it can use the initial value as a
         delta since it last polled the table of which this object is
         part.  It is important for a management station to be aware
         of this minimum time and the actual time between polls, and
         to discard data if the actual time is too long or there is
         no defined minimum time.
         
         Typically this TC is used in tables where the INDEX space is
         constantly changing and/or the TimeFilter mechanism is in
         use.
         
         Note that this textual convention does not retain all the
         semantics of the Counter64 base type. Specifically, a
         Counter64 has an arbitrary initial value, but objects
         defined with this TC are required to start at the value
         
         zero.  This behavior is not likely to have any adverse
         effects on management applications which are expecting
         Counter64 semantics.
         
         This textual convention represents a limited and short-term
         solution, and may be deprecated as a long term solution is
         defined and deployed to replace it.
      </text>
    </description>
  </typedef>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:if-mib="urn:ietf:params:xml:ns:yang:smiv2:IF-MIB"
        xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types"
        name="HOST-RESOURCES-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:HOST-RESOURCES-MIB"/>
  <prefix value="host-resources"/>
  <import module="IF-MIB">
    <prefix value="if-mib"/>
  </import>
  <import module="SNMPv2-TC">
    <prefix value="smiv2"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
  </import>
  <organization>
  <info>
    IETF Host Resources MIB Working Group
    </info>
  </organization>
  <contact>
  <info>
  Steve Waldbusser
      Postal: Lucent Technologies, Inc.
              1213 Innsbruck Dr.
              Sunnyvale, CA 94089
              USA
      Phone:  650-318-1251
      Fax:    650-318-1633
      Email:  waldbusser@lucent.com
      
      In addition, the Host Resources MIB mailing list is
      dedicated to discussion of this MIB. To join the
      mailing list, send a request message to
      hostmib-request@andrew.cmu.edu. The mailing list
      address is hostmib@andrew.cmu.edu.
    </info>
  </contact>
  <description>
    <text>
      This MIB is for use in managing host systems. The term
      `host' is construed to mean any computer that communicates
      with other similar computers attached to the internet and
      that is directly used by one or more human beings. Although
      this MIB does not necessarily apply to devices whose primary
      function is communications services (e.g., terminal servers,
      routers, bridges, monitoring equipment), such relevance is
      not explicitly precluded.  This MIB instruments attributes
      common to all internet hosts including, for example, both
      personal computers and systems that run variants of Unix.
    </text>
  </description>
  <revision date="2000-03-06">
    <description>
      <text>
        Clarifications and bug fixes based on implementation
         experience.  This revision was also reformatted in the SMIv2
         format. The revisions made were:
         
         New RFC document standards:
            Added Copyright notice, updated introduction to SNMP
            Framework, updated references section, added reference to
            RFC 2119, and added a meaningful Security Considerations
            section.
         
         New IANA considerations section for registration of new types
         
         Conversion to new SMIv2 syntax for the following types and
         macros:
             Counter32, Integer32, Gauge32, MODULE-IDENTITY,
             OBJECT-TYPE, TEXTUAL-CONVENTION, OBJECT-IDENTITY,
             MODULE-COMPLIANCE, OBJECT-GROUP
         
         Used new Textual Conventions:
             TruthValue, DateAndTime, AutonomousType,
             InterfaceIndexOrZero
         
         Fixed typo in hrPrinterStatus.
         
         Added missing error bits to hrPrinterDetectedErrorState and
         clarified confusion resulting from suggested mappings to
         hrPrinterStatus.
         
         Clarified that size of objects of type
         InternationalDisplayString is number of octets, not number
         of encoded symbols.
         
         Clarified the use of the following objects based on
         implementation experience:
             hrSystemInitialLoadDevice, hrSystemInitialLoadParameters,
             hrMemorySize, hrStorageSize, hrStorageAllocationFailures,
             hrDeviceErrors, hrProcessorLoad, hrNetworkIfIndex,
             hrDiskStorageCapacity, hrSWRunStatus, hrSWRunPerfCPU,
             and hrSWInstalledDate.
         
         Clarified implementation technique for hrSWInstalledTable.
         
         Used new AUGMENTS clause for hrSWRunPerfTable.
         
         Added Internationalization Considerations section.
         
         This revision published as RFC2790.
      </text>
    </description>
  </revision>
  <revision date="1999-10-20">
    <description>
      <text>
        The original version of this MIB, published as
         RFC1514.
      </text>
    </description>
  </revision>
  <typedef name="KBytes">
    <type name="int32">
      <range value="0..2147483647"/>
    </type>
    <description>
      <text>
        Storage size, expressed in units of 1024 bytes.
      </text>
    </description>
  </typedef>

  <typedef name="ProductID">
    <type name="yang:object-identifier"/>
    <description>
      <text>
        This textual convention is intended to identify the
         
         manufacturer, model, and version of a specific
         hardware or software product.  It is suggested that
         these OBJECT IDENTIFIERs are allocated such that all
         products from a particular manufacturer are registered
         under a subtree distinct to that manufacturer.  In
         addition, all versions of a product should be
         registered under a subtree distinct to that product.
         With this strategy, a management station may uniquely
         determine the manufacturer and/or model of a product
         whose productID is unknown to the management station.
         Objects of this type may be useful for inventory
         purposes or for automatically detecting
         incompatibilities or version mismatches between
         various hardware and software components on a system.
         
         For example, the product ID for the ACME 4860 66MHz
         clock doubled processor might be:
         enterprises.acme.acmeProcessors.a4860DX2.MHz66
         
         A software product might be registered as:
         enterprises.acme.acmeOperatingSystems.acmeDOS.six(6).one(1)
      </text>
    </description>
  </typedef>

  <typedef name="InternationalDisplayString">
    <type name="binary"/>
    <description>
      <text>
        This data type is used to model textual information
         in some character set.  A network management station
         should use a local algorithm to determine which
         character set is in use and how it should be
         displayed.  Note that this character set may be
         encoded with more than one octet per symbol, but will
         most often be NVT ASCII. When a size clause is
         specified for an object of this type, the size refers
         to the length in octets, not the number of symbols.
      </text>
    </description>
  </typedef>

  <container name="hrSystem">
    <leaf name="hrSystemUptime">
      <type name="yang:timeticks"/>
      <config value="false"/>
      <description>
        <text>
          The amount of time since this host was last
            initialized.  Note that this is different from
            sysUpTime in the SNMPv2-MIB [RFC1907] because
            sysUpTime is the uptime of the network management
            portion of the system.
        </text>
      </description>
    </leaf>
    <leaf name="hrSystemDate">
      <type name="smiv2:DateAndTime"/>
      <config value="true"/>
      <description>
        <text>
          The host's notion of the local date and time of day.
        </text>
      </description>
    </leaf>
    <leaf name="hrSystemInitialLoadDevice">
      <type name="int32">
        <range value="1..2147483647"/>
      </type>
      <config value="true"/>
      <description>
        <text>
          The index of the hrDeviceEntry for the device from
            which this host is configured to load its initial
            operating system configuration (i.e., which operating
            system code and/or boot parameters).
            
            Note that writing to this object just changes the
            configuration that will be used the next time the
            operating system is loaded and does not actually cause
            the reload to occur.
        </text>
      </description>
    </leaf>
    <leaf name="hrSystemInitialLoadParameters">
      <type name="host-resources:InternationalDisplayString">
        <length value="0..128"/>
      </type>
      <config value="true"/>
      <description>
        <text>
          This object contains the parameters (e.g. a pathname
            and parameter) supplied to the load device when
            requesting the initial operating system configuration
            from that device.
            
            Note that writing to this object just changes the
            configuration that will be used the next time the
            operating system is loaded and does not actually cause
            the reload to occur.
        </text>
      </description>
    </leaf>
    <leaf name="hrSystemNumUsers">
      <type name="yang:gauge32"/>
      <config value="false"/>
      <description>
        <text>
          The number of user sessions for which this host is
            storing state information.  A session is a collection
            of processes requiring a single act of user
            authentication and possibly subject to collective job
            control.
        </text>
      </description>
    </leaf>
    <leaf name="hrSystemProcesses">
      <type name="yang:gauge32"/>
      <config value="false"/>
      <description>
        <text>
          The number of process contexts currently loaded or
            running on this system.
        </text>
      </description>
    </leaf>
    <leaf name="hrSystemMaxProcesses">
      <type name="int32">
        <range value="0..2147483647"/>
      </type>
      <config value="false"/>
      <description>
        <text>
          The maximum number of process contexts this system
            can support.  If there is no fixed maximum, the value
            should be zero.  On systems that have a fixed maximum,
            this object can help diagnose failures that occur when
            this maximum is reached.
        </text>
      </description>
    </leaf>
  </container>

  <container name="hrStorage">
    <leaf name="hrMemorySize">
      <type name="host-resources:KBytes"/>
      <units name ="KBytes"/>
      <config value="false"/>
      <description>
        <text>
          The amount of physical read-write main memory,
            typically RAM, contained by the host.
        </text>
      </description>
    </leaf>
    <list name="hrStorageEntry">
      <key value="hrStorageIndex"/>
      <description>
        <text>
          A (conceptual) entry for one logical storage area on
            the host.  As an example, an instance of the
            hrStorageType object might be named hrStorageType.3
        </text>
      </description>
      <leaf name="hrStorageIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            A unique value for each logical storage area
               contained by the host.
          </text>
        </description>
      </leaf>
      <leaf name="hrStorageType">
        <type name="smiv2:AutonomousType"/>
        <config value="false"/>
        <description>
          <text>
            The type of storage represented by this entry.
          </text>
        </description>
      </leaf>
      <leaf name="hrStorageDescr">
        <type name="smiv2:DisplayString"/>
        <config value="false"/>
        <description>
          <text>
            A description of the type and instance of the storage
               described by this entry.
          </text>
        </description>
      </leaf>
      <leaf name="hrStorageAllocationUnits">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <units name ="Bytes"/>
        <config value="false"/>
        <description>
          <text>
            The size, in bytes, of the data objects allocated
               from this pool.  If this entry is monitoring sectors,
               blocks, buffers, or packets, for example, this number
               will commonly be greater than one.  Otherwise this
               number will typically be one.
          </text>
        </description>
      </leaf>
      <leaf name="hrStorageSize">
        <type name="int32">
          <range value="0..2147483647"/>
        </type>
        <config value="true"/>
        <description>
          <text>
            The size of the storage represented by this entry, in
               units of hrStorageAllocationUnits. This object is
               writable to allow remote configuration of the size of
               the storage area in those cases where such an
               operation makes sense and is possible on the
               underlying system. For example, the amount of main
               memory allocated to a buffer pool might be modified or
               the amount of disk space allocated to virtual memory
               might be modified.
          </text>
        </description>
      </leaf>
      <leaf name="hrStorageUsed">
        <type name="int32">
          <range value="0..2147483647"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The amount of the storage represented by this entry
               that is allocated, in units of
               hrStorageAllocationUnits.
          </text>
        </description>
      </leaf>
      <leaf name="hrStorageAllocationFailures">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            The number of requests for storage represented by
               this entry that could not be honored due to not enough
               storage.  It should be noted that as this object has a
               SYNTAX of Counter32, that it does not have a defined
               initial value.  However, it is recommended that this
               object be initialized to zero, even though management
               stations must not depend on such an initialization.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="hrDevice">
    <list name="hrDeviceEntry">
      <key value="hrDeviceIndex"/>
      <description>
        <text>
          A (conceptual) entry for one device contained by the
            host.  As an example, an instance of the hrDeviceType
            object might be named hrDeviceType.3
        </text>
      </description>
      <leaf name="hrDeviceIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            A unique value for each device contained by the host.
               The value for each device must remain constant at
               least from one re-initialization of the agent to the
               next re-initialization.
          </text>
        </description>
      </leaf>
      <leaf name="hrDeviceType">
        <type name="smiv2:AutonomousType"/>
        <config value="false"/>
        <description>
          <text>
            An indication of the type of device.
               
               If this value is
               `hrDeviceProcessor { hrDeviceTypes 3 }' then an entry
               exists in the hrProcessorTable which corresponds to
               this device.
               
               If this value is
               `hrDeviceNetwork { hrDeviceTypes 4 }', then an entry
               exists in the hrNetworkTable which corresponds to this
               device.
               
               If this value is
               `hrDevicePrinter { hrDeviceTypes 5 }', then an entry
               exists in the hrPrinterTable which corresponds to this
               device.
               
               If this value is
               `hrDeviceDiskStorage { hrDeviceTypes 6 }', then an
               entry exists in the hrDiskStorageTable which
               corresponds to this device.
          </text>
        </description>
      </leaf>
      <leaf name="hrDeviceDescr">
        <type name="smiv2:DisplayString">
          <length value="0..64"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            A textual description of this device, including the
               device's manufacturer and revision, and optionally,
               its serial number.
          </text>
        </description>
      </leaf>
      <leaf name="hrDeviceID">
        <type name="host-resources:ProductID"/>
        <config value="false"/>
        <description>
          <text>
            The product ID for this device.
          </text>
        </description>
      </leaf>
      <leaf name="hrDeviceStatus">
        <type name="enumeration">
          <enum name="unknown">
            <value value="1"/>
          </enum>
          <enum name="running">
            <value value="2"/>
          </enum>
          <enum name="warning">
            <value value="3"/>
          </enum>
          <enum name="testing">
            <value value="4"/>
          </enum>
          <enum name="down">
            <value value="5"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The current operational state of the device described
               by this row of the table.  A value unknown(1)
               indicates that the current state of the device is
               unknown.  running(2) indicates that the device is up
               and running and that no unusual error conditions are
               known.  The warning(3) state indicates that agent has
               been informed of an unusual error condition by the
               operational software (e.g., a disk device driver) but
               that the device is still 'operational'.  An example
               would be a high number of soft errors on a disk.  A
               value of testing(4), indicates that the device is not
               available for use because it is in the testing state.
               The state of down(5) is used only when the agent has
               been informed that the device is not available for any
               use.
          </text>
        </description>
      </leaf>
      <leaf name="hrDeviceErrors">
        <type name="yang:counter32"/>
        <config value="false"/>
        <description>
          <text>
            The number of errors detected on this device.  It
               should be noted that as this object has a SYNTAX of
               Counter32, that it does not have a defined initial
               value.  However, it is recommended that this object be
               initialized to zero, even though management stations
               must not depend on such an initialization.
          </text>
        </description>
      </leaf>
    </list>
    <list name="hrProcessorEntry">
      <key value="hrDeviceIndex"/>
      <description>
        <text>
          A (conceptual) entry for one processor contained by
            the host.  The hrDeviceIndex in the index represents
            the entry in the hrDeviceTable that corresponds to the
            hrProcessorEntry.
            
            As an example of how objects in this table are named,
            an instance of the hrProcessorFrwID object might be
            named hrProcessorFrwID.3
        </text>
      </description>
      <leaf name="hrDeviceIndex">
        <type name="leafref">
          <path value="/host-resources:hrDevice/host-resources:hrDeviceEntry/host-resources:hrDeviceIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="hrProcessorFrwID">
        <type name="host-resources:ProductID"/>
        <config value="false"/>
        <description>
          <text>
            The product ID of the firmware associated with the
               processor.
          </text>
        </description>
      </leaf>
      <leaf name="hrProcessorLoad">
        <type name="int32">
          <range value="0..100"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The average, over the last minute, of the percentage
               of time that this processor was not idle.
               Implementations may approximate this one minute
               smoothing period if necessary.
          </text>
        </description>
      </leaf>
    </list>
    <list name="hrNetworkEntry">
      <key value="hrDeviceIndex"/>
      <description>
        <text>
          A (conceptual) entry for one network device contained
            by the host.  The hrDeviceIndex in the index
            represents the entry in the hrDeviceTable that
            corresponds to the hrNetworkEntry.
            
            As an example of how objects in this table are named,
            an instance of the hrNetworkIfIndex object might be
            named hrNetworkIfIndex.3
        </text>
      </description>
      <leaf name="hrDeviceIndex">
        <type name="leafref">
          <path value="/host-resources:hrDevice/host-resources:hrDeviceEntry/host-resources:hrDeviceIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="hrNetworkIfIndex">
        <type name="if-mib:InterfaceIndexOrZero"/>
        <config value="false"/>
        <description>
          <text>
            The value of ifIndex which corresponds to this
               network device. If this device is not represented in
               the ifTable, then this value shall be zero.
          </text>
        </description>
      </leaf>
    </list>
    <list name="hrPrinterEntry">
      <key value="hrDeviceIndex"/>
      <description>
        <text>
          A (conceptual) entry for one printer local to the
            host.  The hrDeviceIndex in the index represents the
            entry in the hrDeviceTable that corresponds to the
            hrPrinterEntry.
            
            As an example of how objects in this table are named,
            an instance of the hrPrinterStatus object might be
            named hrPrinterStatus.3
        </text>
      </description>
      <leaf name="hrDeviceIndex">
        <type name="leafref">
          <path value="/host-resources:hrDevice/host-resources:hrDeviceEntry/host-resources:hrDeviceIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="hrPrinterStatus">
        <type name="enumeration">
          <enum name="other">
            <value value="1"/>
          </enum>
          <enum name="unknown">
            <value value="2"/>
          </enum>
          <enum name="idle">
            <value value="3"/>
          </enum>
          <enum name="printing">
            <value value="4"/>
          </enum>
          <enum name="warmup">
            <value value="5"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The current status of this printer device.
          </text>
        </description>
      </leaf>
      <leaf name="hrPrinterDetectedErrorState">
        <type name="binary"/>
        <config value="false"/>
        <description>
          <text>
            This object represents any error conditions detected
               by the printer.  The error conditions are encoded as
               bits in an octet string, with the following
               definitions:
               
                    Condition         Bit #
               
                    lowPaper              0
               
                    noPaper               1
                    lowToner              2
                    noToner               3
                    doorOpen              4
                    jammed                5
                    offline               6
                    serviceRequested      7
                    inputTrayMissing      8
                    outputTrayMissing     9
                    markerSupplyMissing  10
                    outputNearFull       11
                    outputFull           12
                    inputTrayEmpty       13
                    overduePreventMaint  14
               
               Bits are numbered starting with the most significant
               bit of the first byte being bit 0, the least
               significant bit of the first byte being bit 7, the
               most significant bit of the second byte being bit 8,
               and so on.  A one bit encodes that the condition was
               detected, while a zero bit encodes that the condition
               was not detected.
               
               This object is useful for alerting an operator to
               specific warning or error conditions that may occur,
               especially those requiring human intervention.
          </text>
        </description>
      </leaf>
    </list>
    <list name="hrDiskStorageEntry">
      <key value="hrDeviceIndex"/>
      <description>
        <text>
          A (conceptual) entry for one long-term storage device
            contained by the host.  The hrDeviceIndex in the index
            represents the entry in the hrDeviceTable that
            corresponds to the hrDiskStorageEntry. As an example,
            an instance of the hrDiskStorageCapacity object might
            be named hrDiskStorageCapacity.3
        </text>
      </description>
      <leaf name="hrDeviceIndex">
        <type name="leafref">
          <path value="/host-resources:hrDevice/host-resources:hrDeviceEntry/host-resources:hrDeviceIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="hrDiskStorageAccess">
        <type name="enumeration">
          <enum name="readWrite">
            <value value="1"/>
          </enum>
          <enum name="readOnly">
            <value value="2"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            An indication if this long-term storage device is
               readable and writable or only readable.  This should
               reflect the media type, any write-protect mechanism,
               and any device configuration that affects the entire
               device.
          </text>
        </description>
      </leaf>
      <leaf name="hrDiskStorageMedia">
        <type name="enumeration">
          <enum name="other">
            <value value="1"/>
          </enum>
          <enum name="unknown">
            <value value="2"/>
          </enum>
          <enum name="hardDisk">
            <value value="3"/>
          </enum>
          <enum name="floppyDisk">
            <value value="4"/>
          </enum>
          <enum name="opticalDiskROM">
            <value value="5"/>
          </enum>
          <enum name="opticalDiskWORM">
            <value value="6"/>
          </enum>
          <enum name="opticalDiskRW">
            <value value="7"/>
          </enum>
          <enum name="ramDisk">
            <value value="8"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            An indication of the type of media used in this long-
               term storage device.
          </text>
        </description>
      </leaf>
      <leaf name="hrDiskStorageRemoveble">
        <type name="smiv2:TruthValue"/>
        <config value="false"/>
        <description>
          <text>
            Denotes whether or not the disk media may be removed
               from the drive.
          </text>
        </description>
      </leaf>
      <leaf name="hrDiskStorageCapacity">
        <type name="host-resources:KBytes"/>
        <units name ="KBytes"/>
        <config value="false"/>
        <description>
          <text>
            The total size for this long-term storage device. If
               the media is removable and is currently removed, this
               value should be zero.
          </text>
        </description>
      </leaf>
    </list>
    <list name="hrPartitionEntry">
      <key value="hrDeviceIndex hrPartitionIndex"/>
      <description>
        <text>
          A (conceptual) entry for one partition.  The
            hrDeviceIndex in the index represents the entry in the
            hrDeviceTable that corresponds to the
            hrPartitionEntry.
            
            As an example of how objects in this table are named,
            an instance of the hrPartitionSize object might be
            named hrPartitionSize.3.1
        </text>
      </description>
      <leaf name="hrDeviceIndex">
        <type name="leafref">
          <path value="/host-resources:hrDevice/host-resources:hrDeviceEntry/host-resources:hrDeviceIndex"/>
        </type>
        <description>
          <text>
            Automagically generated leafref leaf.
          </text>
        </description>
      </leaf>
      <leaf name="hrPartitionIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            A unique value for each partition on this long-term
               storage device.  The value for each long-term storage
               device must remain constant at least from one re-
               initialization of the agent to the next re-
               initialization.
          </text>
        </description>
      </leaf>
      <leaf name="hrPartitionLabel">
        <type name="host-resources:InternationalDisplayString">
          <length value="0..128"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            A textual description of this partition.
          </text>
        </description>
      </leaf>
      <leaf name="hrPartitionID">
        <type name="binary"/>
        <config value="false"/>
        <description>
          <text>
            A descriptor which uniquely represents this partition
               to the responsible operating system.  On some systems,
               this might take on a binary representation.
          </text>
        </description>
      </leaf>
      <leaf name="hrPartitionSize">
        <type name="host-resources:KBytes"/>
        <units name ="KBytes"/>
        <config value="false"/>
        <description>
          <text>
            The size of this partition.
          </text>
        </description>
      </leaf>
      <leaf name="hrPartitionFSIndex">
        <type name="int32">
          <range value="0..2147483647"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The index of the file system mounted on this
               partition.  If no file system is mounted on this
               partition, then this value shall be zero.  Note that
               multiple partitions may point to one file system,
               denoting that that file system resides on those
               partitions.  Multiple file systems may not reside on
               one partition.
          </text>
        </description>
      </leaf>
    </list>
    <list name="hrFSEntry">
      <key value="hrFSIndex"/>
      <description>
        <text>
          A (conceptual) entry for one file system local to
            this host or remotely mounted from a file server.
            File systems that are in only one user's environment
            on a multi-user system will not be included in this
            table.
            
            As an example of how objects in this table are named,
            an instance of the hrFSMountPoint object might be
            named hrFSMountPoint.3
        </text>
      </description>
      <leaf name="hrFSIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            A unique value for each file system local to this
               host.  The value for each file system must remain
               constant at least from one re-initialization of the
               agent to the next re-initialization.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSMountPoint">
        <type name="host-resources:InternationalDisplayString">
          <length value="0..128"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The path name of the root of this file system.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSRemoteMountPoint">
        <type name="host-resources:InternationalDisplayString">
          <length value="0..128"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            A description of the name and/or address of the
               server that this file system is mounted from.  This
               may also include parameters such as the mount point on
               the remote file system.  If this is not a remote file
               system, this string should have a length of zero.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSType">
        <type name="smiv2:AutonomousType"/>
        <config value="false"/>
        <description>
          <text>
            The value of this object identifies the type of this
               file system.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSAccess">
        <type name="enumeration">
          <enum name="readWrite">
            <value value="1"/>
          </enum>
          <enum name="readOnly">
            <value value="2"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            An indication if this file system is logically
               configured by the operating system to be readable and
               writable or only readable.  This does not represent
               any local access-control policy, except one that is
               applied to the file system as a whole.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSBootable">
        <type name="smiv2:TruthValue"/>
        <config value="false"/>
        <description>
          <text>
            A flag indicating whether this file system is
               bootable.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSStorageIndex">
        <type name="int32">
          <range value="0..2147483647"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            The index of the hrStorageEntry that represents
               information about this file system.  If there is no
               such information available, then this value shall be
               zero.  The relevant storage entry will be useful in
               tracking the percent usage of this file system and
               diagnosing errors that may occur when it runs out of
               space.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSLastFullBackupDate">
        <type name="smiv2:DateAndTime"/>
        <config value="true"/>
        <description>
          <text>
            The last date at which this complete file system was
               
               copied to another storage device for backup.  This
               information is useful for ensuring that backups are
               being performed regularly.
               
               If this information is not known, then this variable
               shall have the value corresponding to January 1, year
               0000, 00:00:00.0, which is encoded as
               (hex)'00 00 01 01 00 00 00 00'.
          </text>
        </description>
      </leaf>
      <leaf name="hrFSLastPartialBackupDate">
        <type name="smiv2:DateAndTime"/>
        <config value="true"/>
        <description>
          <text>
            The last date at which a portion of this file system
               was copied to another storage device for backup.  This
               information is useful for ensuring that backups are
               being performed regularly.
               
               If this information is not known, then this variable
               shall have the value corresponding to January 1, year
               0000, 00:00:00.0, which is encoded as
               (hex)'00 00 01 01 00 00 00 00'.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="hrSWRun">
    <leaf name="hrSWOSIndex">
      <type name="int32">
        <range value="1..2147483647"/>
      </type>
      <config value="false"/>
      <description>
        <text>
          The value of the hrSWRunIndex for the hrSWRunEntry
            that represents the primary operating system running
            on this host.  This object is useful for quickly and
            uniquely identifying that primary operating system.
        </text>
      </description>
    </leaf>
    <list name="hrSWRunEntry">
      <key value="hrSWRunIndex"/>
      <description>
        <text>
          A (conceptual) entry for one piece of software
            running on the host Note that because the installed
            software table only contains information for software
            stored locally on this host, not every piece of
            running software will be found in the installed
            software table.  This is true of software that was
            loaded and run from a non-local source, such as a
            network-mounted file system.
            
            As an example of how objects in this table are named,
            an instance of the hrSWRunName object might be named
            hrSWRunName.1287
        </text>
      </description>
      <leaf name="hrSWRunIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            A unique value for each piece of software running on
               the host.  Wherever possible, this should be the
               system's native, unique identification number.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWRunName">
        <type name="host-resources:InternationalDisplayString">
          <length value="0..64"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            A textual description of this running piece of
               software, including the manufacturer, revision,  and
               the name by which it is commonly known.  If this
               software was installed locally, this should be the
               same string as used in the corresponding
               hrSWInstalledName.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWRunID">
        <type name="host-resources:ProductID"/>
        <config value="false"/>
        <description>
          <text>
            The product ID of this running piece of software.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWRunPath">
        <type name="host-resources:InternationalDisplayString">
          <length value="0..128"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            A description of the location on long-term storage
               (e.g. a disk drive) from which this software was
               loaded.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWRunParameters">
        <type name="host-resources:InternationalDisplayString">
          <length value="0..128"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            A description of the parameters supplied to this
               software when it was initially loaded.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWRunType">
        <type name="enumeration">
          <enum name="unknown">
            <value value="1"/>
          </enum>
          <enum name="operatingSystem">
            <value value="2"/>
          </enum>
          <enum name="deviceDriver">
            <value value="3"/>
          </enum>
          <enum name="application">
            <value value="4"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The type of this software.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWRunStatus">
        <type name="enumeration">
          <enum name="running">
            <value value="1"/>
          </enum>
          <enum name="runnable">
            <value value="2"/>
          </enum>
          <enum name="notRunnable">
            <value value="3"/>
          </enum>
          <enum name="invalid">
            <value value="4"/>
          </enum>
        </type>
        <config value="true"/>
        <description>
          <text>
            The status of this running piece of software.
               Setting this value to invalid(4) shall cause this
               software to stop running and to be unloaded. Sets to
               other values are not valid.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <container name="hrSWRunPerf"/>

  <container name="hrSWInstalled">
    <leaf name="hrSWInstalledLastChange">
      <type name="yang:timeticks"/>
      <config value="false"/>
      <description>
        <text>
          The value of sysUpTime when an entry in the
            hrSWInstalledTable was last added, renamed, or
            deleted.  Because this table is likely to contain many
            entries, polling of this object allows a management
            station to determine when re-downloading of the table
            might be useful.
        </text>
      </description>
    </leaf>
    <leaf name="hrSWInstalledLastUpdateTime">
      <type name="yang:timeticks"/>
      <config value="false"/>
      <description>
        <text>
          The value of sysUpTime when the hrSWInstalledTable
            was last completely updated.  Because caching of this
            data will be a popular implementation strategy,
            retrieval of this object allows a management station
            to obtain a guarantee that no data in this table is
            older than the indicated time.
        </text>
      </description>
    </leaf>
    <list name="hrSWInstalledEntry">
      <key value="hrSWInstalledIndex"/>
      <description>
        <text>
          A (conceptual) entry for a piece of software
            installed on this host.
            
            As an example of how objects in this table are named,
            an instance of the hrSWInstalledName object might be
            named hrSWInstalledName.96
        </text>
      </description>
      <leaf name="hrSWInstalledIndex">
        <type name="int32">
          <range value="1..2147483647"/>
        </type>
        <description>
          <text>
            A unique value for each piece of software installed
               on the host.  This value shall be in the range from 1
               to the number of pieces of software installed on the
               host.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWInstalledName">
        <type name="host-resources:InternationalDisplayString">
          <length value="0..64"/>
        </type>
        <config value="false"/>
        <description>
          <text>
            A textual description of this installed piece of
               software, including the manufacturer, revision, the
               name by which it is commonly known, and optionally,
               its serial number.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWInstalledID">
        <type name="host-resources:ProductID"/>
        <config value="false"/>
        <description>
          <text>
            The product ID of this installed piece of software.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWInstalledType">
        <type name="enumeration">
          <enum name="unknown">
            <value value="1"/>
          </enum>
          <enum name="operatingSystem">
            <value value="2"/>
          </enum>
          <enum name="deviceDriver">
            <value value="3"/>
          </enum>
          <enum name="application">
            <value value="4"/>
          </enum>
        </type>
        <config value="false"/>
        <description>
          <text>
            The type of this software.
          </text>
        </description>
      </leaf>
      <leaf name="hrSWInstalledDate">
        <type name="smiv2:DateAndTime"/>
        <config value="false"/>
        <description>
          <text>
            The last-modification date of this application as it
               would appear in a directory listing.
               
               If this information is not known, then this variable
               shall have the value corresponding to January 1, year
               0000, 00:00:00.0, which is encoded as
               (hex)'00 00 01 01 00 00 00 00'.
          </text>
        </description>
      </leaf>
    </list>
  </container>

  <augment target-node="/host-resources:hrSWRun/host-resources:hrSWRunEntry">
    <description>
      <text>
        A (conceptual) entry containing software performance
         metrics.  As an example, an instance of the
         hrSWRunPerfCPU object might be named
         hrSWRunPerfCPU.1287
      </text>
    </description>
    <leaf name="hrSWRunPerfCPU">
      <type name="int32">
        <range value="0..2147483647"/>
      </type>
      <config value="false"/>
      <description>
        <text>
          The number of centi-seconds of the total system's CPU
            resources consumed by this process.  Note that on a
            multi-processor system, this value may increment by
            more than one centi-second in one centi-second of real
            (wall clock) time.
        </text>
      </description>
    </leaf>
    <leaf name="hrSWRunPerfMem">
      <type name="host-resources:KBytes"/>
      <units name ="KBytes"/>
      <config value="false"/>
      <description>
        <text>
          The total amount of real system memory allocated to
            this process.
        </text>
      </description>
    </leaf>
  </augment>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:host-resources="urn:ietf:params:xml:ns:yang:smiv2:HOST-RESOURCES-MIB"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="HOST-RESOURCES-TYPES">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:HOST-RESOURCES-TYPES"/>
  <prefix value="host-resources-types"/>
  <import module="HOST-RESOURCES-MIB">
    <prefix value="host-resources"/>
  </import>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IETF Host Resources MIB Working Group
    </info>
  </organization>
  <contact>
  <info>
  Steve Waldbusser
      Postal: Lucent Technologies, Inc.
              1213 Innsbruck Dr.
              Sunnyvale, CA 94089
              USA
      Phone: 650-318-1251
      Fax:   650-318-1633
      Email: waldbusser@ins.com
      
      In addition, the Host Resources MIB mailing list is dedicated
      to discussion of this MIB. To join the mailing list, send a
      request message to hostmib-request@andrew.cmu.edu. The mailing
      list address is hostmib@andrew.cmu.edu.
    </info>
  </contact>
  <description>
    <text>
      This MIB module registers type definitions for
      storage types, device types, and file system types.
      
      After the initial revision, this module will be
      maintained by IANA.
    </text>
  </description>
  <revision date="2000-03-06">
    <description>
      <text>
        The original version of this module, published as RFC
         2790.
      </text>
    </description>
  </revision>
</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="IANA-ADDRESS-FAMILY-NUMBERS-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:IANA-ADDRESS-FAMILY-NUMBERS-MIB"/>
  <prefix value="iana-address"/>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IANA
    </info>
  </organization>
  <contact>
  <info>
  Postal:    Internet Assigned Numbers Authority
      Internet Corporation for Assigned Names
       and Numbers
      4676 Admiralty Way, Suite 330
      Marina del Rey, CA 90292-6601
      USA
      
      Tel:    +1  310-823-9358
      E-Mail: iana@iana.org
    </info>
  </contact>
  <description>
    <text>
      The MIB module defines the AddressFamilyNumbers
      textual convention.
    </text>
  </description>
  <revision date="2002-03-14">
    <description>
      <text>
        AddressFamilyNumbers assignment 22 to 
         fibreChannelWWPN. AddressFamilyNumbers 
         assignment 23 to fibreChannelWWNN.
         AddressFamilyNumers assignment 24 to gwid.
      </text>
    </description>
  </revision>
  <revision date="2000-09-08">
    <description>
      <text>
        AddressFamilyNumbers assignment 19 to xtpOverIpv4.  
         AddressFamilyNumbers assignment 20 to xtpOverIpv6.  
         AddressFamilyNumbers assignment 21 to xtpNativeModeXTP.
      </text>
    </description>
  </revision>
  <revision date="2000-03-01">
    <description>
      <text>
        AddressFamilyNumbers assignment 17 to distinguishedName. 
         AddressFamilyNumbers assignment 18 to asNumber.
      </text>
    </description>
  </revision>
  <revision date="2000-02-04">
    <description>
      <text>
        AddressFamilyNumbers assignment 16 to dns.
      </text>
    </description>
  </revision>
  <revision date="1999-08-26">
    <description>
      <text>
        Initial version, published as RFC 2677.
      </text>
    </description>
  </revision>
  <typedef name="AddressFamilyNumbers">
    <type name="enumeration">
      <enum name="other">
        <value value="0"/>
      </enum>
      <enum name="ipV4">
        <value value="1"/>
      </enum>
      <enum name="ipV6">
        <value value="2"/>
      </enum>
      <enum name="nsap">
        <value value="3"/>
      </enum>
      <enum name="hdlc">
        <value value="4"/>
      </enum>
      <enum name="bbn1822">
        <value value="5"/>
      </enum>
      <enum name="all802">
        <value value="6"/>
      </enum>
      <enum name="e163">
        <value value="7"/>
      </enum>
      <enum name="e164">
        <value value="8"/>
      </enum>
      <enum name="f69">
        <value value="9"/>
      </enum>
      <enum name="x121">
        <value value="10"/>
      </enum>
      <enum name="ipx">
        <value value="11"/>
      </enum>
      <enum name="appleTalk">
        <value value="12"/>
      </enum>
      <enum name="decnetIV">
        <value value="13"/>
      </enum>
      <enum name="banyanVines">
        <value value="14"/>
      </enum>
      <enum name="e164withNsap">
        <value value="15"/>
      </enum>
      <enum name="dns">
        <value value="16"/>
      </enum>
      <enum name="distinguishedName">
        <value value="17"/>
      </enum>
      <enum name="asNumber">
        <value value="18"/>
      </enum>
      <enum name="xtpOverIpv4">
        <value value="19"/>
      </enum>
      <enum name="xtpOverIpv6">
        <value value="20"/>
      </enum>
      <enum name="xtpNativeModeXTP">
        <value value="21"/>
      </enum>
      <enum name="fibreChannelWWPN">
        <value value="22"/>
      </enum>
      <enum name="fibreChannelWWNN">
        <value value="23"/>
      </enum>
      <enum name="gwid">
        <value value="24"/>
      </enum>
      <enum name="reserved">
        <value value="65535"/>
      </enum>
    </type>
    <description>
      <text>
        The definition of this textual convention with the
         addition of newly assigned values is published
         periodically by the IANA, in either the Assigned
         Numbers RFC, or some derivative of it specific to
         Internet Network Management number assignments.
         (The latest arrangements can be obtained by
         contacting the IANA.)
         
         The enumerations are described as:
         
         other(0),    -- none of the following
         ipV4(1),     -- IP Version 4
         ipV6(2),     -- IP Version 6
         nsap(3),     -- NSAP
         hdlc(4),     -- (8-bit multidrop)
         bbn1822(5),
         all802(6),   -- (includes all 802 media
                      --   plus Ethernet 'canonical format')
         e163(7),
         e164(8),     -- (SMDS, Frame Relay, ATM)
         f69(9),      -- (Telex)
         x121(10),    -- (X.25, Frame Relay)
         ipx(11),     -- IPX (Internet Protocol Exchange)
         appleTalk(12),  -- Apple Talk
         decnetIV(13),   -- DEC Net Phase IV
         banyanVines(14),  -- Banyan Vines
         e164withNsap(15),
                      -- (E.164 with NSAP format subaddress)
         dns(16),     -- (Domain Name System)
         distinguishedName(17), -- (Distinguished Name, per X.500)
         asNumber(18), -- (16-bit quantity, per the AS number space)
         xtpOverIpv4(19),  -- XTP over IP version 4
         xtpOverIpv6(20),  -- XTP over IP version 6
         xtpNativeModeXTP(21),  -- XTP native mode XTP
         fibreChannelWWPN(22),  -- Fibre Channel World-Wide Port Name 
         fibreChannelWWNN(23),  -- Fibre Channel World-Wide Node Name
         gwid(24),    -- Gateway Identifier 
         reserved(65535)
         
         Requests for new values should be made to IANA via
         email (iana@iana.org).
      </text>
    </description>
  </typedef>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="IANAifType-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:IANAifType-MIB"/>
  <prefix value="ianaiftype-mib"/>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IANA
    </info>
  </organization>
  <contact>
  <info>
          Internet Assigned Numbers Authority
      
      Postal: ICANN
              4676 Admiralty Way, Suite 330
              Marina del Rey, CA 90292
      
      Tel:    +1 310 823 9358
      E-Mail: iana@iana.org
    </info>
  </contact>
  <description>
    <text>
      This MIB module defines the IANAifType Textual
      Convention, and thus the enumerated values of
      the ifType object defined in MIB-II's ifTable.
    </text>
  </description>
  <revision date="2005-10-10">
    <description>
      <text>
        Registration of new IANA ifType 230.
      </text>
    </description>
  </revision>
  <revision date="2005-09-09">
    <description>
      <text>
        Registration of new IANA ifType 229.
      </text>
    </description>
  </revision>
  <revision date="2005-05-27">
    <description>
      <text>
        Registration of new IANA ifType 228.
      </text>
    </description>
  </revision>
  <revision date="2005-03-03">
    <description>
      <text>
        Added the IANAtunnelType TC and deprecated
         IANAifType sixToFour (215) per 
         RFC4087.
      </text>
    </description>
  </revision>
  <revision date="2004-11-22">
    <description>
      <text>
        Registration of new IANA ifType 227.
      </text>
    </description>
  </revision>
  <revision date="2004-06-17">
    <description>
      <text>
        Registration of new IANA ifType 226.
      </text>
    </description>
  </revision>
  <revision date="2004-05-12">
    <description>
      <text>
        Added description for IANAifType 6, and 
         changed the descriptions for IANAifTypes
         180, 181, and 182.
      </text>
    </description>
  </revision>
  <revision date="2004-05-07">
    <description>
      <text>
        Registration of new IANAifType 225.
      </text>
    </description>
  </revision>
  <revision date="2003-08-25">
    <description>
      <text>
        Deprecated IANAifTypes 7 and 11. Obsoleted
         IANAifTypes 62, 69, and 117.  ethernetCsmacd (6)
         should be used instead of these values
      </text>
    </description>
  </revision>
  <revision date="2003-08-18">
    <description>
      <text>
        Registration of new IANAifType
         224.
      </text>
    </description>
  </revision>
  <revision date="2003-08-07">
    <description>
      <text>
        Registration of new IANAifTypes
         222 and 223.
      </text>
    </description>
  </revision>
  <revision date="2003-03-18">
    <description>
      <text>
        Registration of new IANAifType
         221.
      </text>
    </description>
  </revision>
  <revision date="2003-01-13">
    <description>
      <text>
        Registration of new IANAifType
         220.
      </text>
    </description>
  </revision>
  <revision date="2002-10-17">
    <description>
      <text>
        Registration of new IANAifType
         219.
      </text>
    </description>
  </revision>
  <revision date="2002-07-16">
    <description>
      <text>
        Registration of new IANAifTypes
         217 and 218.
      </text>
    </description>
  </revision>
  <revision date="2002-07-10">
    <description>
      <text>
        Registration of new IANAifTypes
         215 and 216.
      </text>
    </description>
  </revision>
  <revision date="2002-06-19">
    <description>
      <text>
        Registration of new IANAifType
         214.
      </text>
    </description>
  </revision>
  <revision date="2002-01-04">
    <description>
      <text>
        Registration of new IANAifTypes
         211, 212 and 213.
      </text>
    </description>
  </revision>
  <revision date="2001-12-20">
    <description>
      <text>
        Registration of new IANAifTypes
         209 and 210.
      </text>
    </description>
  </revision>
  <revision date="2001-11-15">
    <description>
      <text>
        Registration of new IANAifTypes
         207 and 208.
      </text>
    </description>
  </revision>
  <revision date="2001-11-06">
    <description>
      <text>
        Registration of new IANAifType
         206.
      </text>
    </description>
  </revision>
  <revision date="2001-11-02">
    <description>
      <text>
        Registration of new IANAifType
         205.
      </text>
    </description>
  </revision>
  <revision date="2001-10-16">
    <description>
      <text>
        Registration of new IANAifTypes
         199, 200, 201, 202, 203, and 204.
      </text>
    </description>
  </revision>
  <revision date="2001-09-19">
    <description>
      <text>
        Registration of new IANAifType
         198.
      </text>
    </description>
  </revision>
  <revision date="2001-05-11">
    <description>
      <text>
        Registration of new IANAifType
         197.
      </text>
    </description>
  </revision>
  <revision date="2001-01-12">
    <description>
      <text>
        Registration of new IANAifTypes
         195 and 196.
      </text>
    </description>
  </revision>
  <revision date="2000-12-19">
    <description>
      <text>
        Registration of new IANAifTypes
         193 and 194.
      </text>
    </description>
  </revision>
  <revision date="2000-12-07">
    <description>
      <text>
        Registration of new IANAifTypes
         191 and 192.
      </text>
    </description>
  </revision>
  <revision date="2000-12-04">
    <description>
      <text>
        Registration of new IANAifType
         190.
      </text>
    </description>
  </revision>
  <revision date="2000-10-17">
    <description>
      <text>
        Registration of new IANAifTypes
         188 and 189.
      </text>
    </description>
  </revision>
  <revision date="2000-10-02">
    <description>
      <text>
        Registration of new IANAifType 187.
      </text>
    </description>
  </revision>
  <revision date="2000-09-01">
    <description>
      <text>
        Registration of new IANAifTypes
         184, 185, and 186.
      </text>
    </description>
  </revision>
  <revision date="2000-08-24">
    <description>
      <text>
        Registration of new IANAifType 183.
      </text>
    </description>
  </revision>
  <revision date="2000-08-23">
    <description>
      <text>
        Registration of new IANAifTypes
         174-182.
      </text>
    </description>
  </revision>
  <revision date="2000-08-22">
    <description>
      <text>
        Registration of new IANAifTypes 170,
         171, 172 and 173.
      </text>
    </description>
  </revision>
  <revision date="2000-04-25">
    <description>
      <text>
        Registration of new IANAifTypes 168 and 169.
      </text>
    </description>
  </revision>
  <revision date="2000-03-06">
    <description>
      <text>
        Fixed a missing semi-colon in the IMPORT.
         Also cleaned up the REVISION log a bit.
         It is not complete, but from now on it will
         be maintained and kept up to date with each
         change to this MIB module.
      </text>
    </description>
  </revision>
  <revision date="1999-10-08">
    <description>
      <text>
        Include new name assignments up to cnr(85).
         This is the first version available via the WWW
         at: ftp://ftp.isi.edu/mib/ianaiftype.mib
      </text>
    </description>
  </revision>
  <revision date="1994-01-31">
    <description>
      <text>
        Initial version of this MIB as published in
         RFC 1573.
      </text>
    </description>
  </revision>
  <typedef name="IANAifType">
    <type name="enumeration">
      <enum name="other">
        <value value="1"/>
      </enum>
      <enum name="regular1822">
        <value value="2"/>
      </enum>
      <enum name="hdh1822">
        <value value="3"/>
      </enum>
      <enum name="ddnX25">
        <value value="4"/>
      </enum>
      <enum name="rfc877x25">
        <value value="5"/>
      </enum>
      <enum name="ethernetCsmacd">
        <value value="6"/>
      </enum>
      <enum name="iso88023Csmacd">
        <value value="7"/>
      </enum>
      <enum name="iso88024TokenBus">
        <value value="8"/>
      </enum>
      <enum name="iso88025TokenRing">
        <value value="9"/>
      </enum>
      <enum name="iso88026Man">
        <value value="10"/>
      </enum>
      <enum name="starLan">
        <value value="11"/>
      </enum>
      <enum name="proteon10Mbit">
        <value value="12"/>
      </enum>
      <enum name="proteon80Mbit">
        <value value="13"/>
      </enum>
      <enum name="hyperchannel">
        <value value="14"/>
      </enum>
      <enum name="fddi">
        <value value="15"/>
      </enum>
      <enum name="lapb">
        <value value="16"/>
      </enum>
      <enum name="sdlc">
        <value value="17"/>
      </enum>
      <enum name="ds1">
        <value value="18"/>
      </enum>
      <enum name="e1">
        <value value="19"/>
      </enum>
      <enum name="basicISDN">
        <value value="20"/>
      </enum>
      <enum name="primaryISDN">
        <value value="21"/>
      </enum>
      <enum name="propPointToPointSerial">
        <value value="22"/>
      </enum>
      <enum name="ppp">
        <value value="23"/>
      </enum>
      <enum name="softwareLoopback">
        <value value="24"/>
      </enum>
      <enum name="eon">
        <value value="25"/>
      </enum>
      <enum name="ethernet3Mbit">
        <value value="26"/>
      </enum>
      <enum name="nsip">
        <value value="27"/>
      </enum>
      <enum name="slip">
        <value value="28"/>
      </enum>
      <enum name="ultra">
        <value value="29"/>
      </enum>
      <enum name="ds3">
        <value value="30"/>
      </enum>
      <enum name="sip">
        <value value="31"/>
      </enum>
      <enum name="frameRelay">
        <value value="32"/>
      </enum>
      <enum name="rs232">
        <value value="33"/>
      </enum>
      <enum name="para">
        <value value="34"/>
      </enum>
      <enum name="arcnet">
        <value value="35"/>
      </enum>
      <enum name="arcnetPlus">
        <value value="36"/>
      </enum>
      <enum name="atm">
        <value value="37"/>
      </enum>
      <enum name="miox25">
        <value value="38"/>
      </enum>
      <enum name="sonet">
        <value value="39"/>
      </enum>
      <enum name="x25ple">
        <value value="40"/>
      </enum>
      <enum name="iso88022llc">
        <value value="41"/>
      </enum>
      <enum name="localTalk">
        <value value="42"/>
      </enum>
      <enum name="smdsDxi">
        <value value="43"/>
      </enum>
      <enum name="frameRelayService">
        <value value="44"/>
      </enum>
      <enum name="v35">
        <value value="45"/>
      </enum>
      <enum name="hssi">
        <value value="46"/>
      </enum>
      <enum name="hippi">
        <value value="47"/>
      </enum>
      <enum name="modem">
        <value value="48"/>
      </enum>
      <enum name="aal5">
        <value value="49"/>
      </enum>
      <enum name="sonetPath">
        <value value="50"/>
      </enum>
      <enum name="sonetVT">
        <value value="51"/>
      </enum>
      <enum name="smdsIcip">
        <value value="52"/>
      </enum>
      <enum name="propVirtual">
        <value value="53"/>
      </enum>
      <enum name="propMultiplexor">
        <value value="54"/>
      </enum>
      <enum name="ieee80212">
        <value value="55"/>
      </enum>
      <enum name="fibreChannel">
        <value value="56"/>
      </enum>
      <enum name="hippiInterface">
        <value value="57"/>
      </enum>
      <enum name="frameRelayInterconnect">
        <value value="58"/>
      </enum>
      <enum name="aflane8023">
        <value value="59"/>
      </enum>
      <enum name="aflane8025">
        <value value="60"/>
      </enum>
      <enum name="cctEmul">
        <value value="61"/>
      </enum>
      <enum name="fastEther">
        <value value="62"/>
      </enum>
      <enum name="isdn">
        <value value="63"/>
      </enum>
      <enum name="v11">
        <value value="64"/>
      </enum>
      <enum name="v36">
        <value value="65"/>
      </enum>
      <enum name="g703at64k">
        <value value="66"/>
      </enum>
      <enum name="g703at2mb">
        <value value="67"/>
      </enum>
      <enum name="qllc">
        <value value="68"/>
      </enum>
      <enum name="fastEtherFX">
        <value value="69"/>
      </enum>
      <enum name="channel">
        <value value="70"/>
      </enum>
      <enum name="ieee80211">
        <value value="71"/>
      </enum>
      <enum name="ibm370parChan">
        <value value="72"/>
      </enum>
      <enum name="escon">
        <value value="73"/>
      </enum>
      <enum name="dlsw">
        <value value="74"/>
      </enum>
      <enum name="isdns">
        <value value="75"/>
      </enum>
      <enum name="isdnu">
        <value value="76"/>
      </enum>
      <enum name="lapd">
        <value value="77"/>
      </enum>
      <enum name="ipSwitch">
        <value value="78"/>
      </enum>
      <enum name="rsrb">
        <value value="79"/>
      </enum>
      <enum name="atmLogical">
        <value value="80"/>
      </enum>
      <enum name="ds0">
        <value value="81"/>
      </enum>
      <enum name="ds0Bundle">
        <value value="82"/>
      </enum>
      <enum name="bsc">
        <value value="83"/>
      </enum>
      <enum name="async">
        <value value="84"/>
      </enum>
      <enum name="cnr">
        <value value="85"/>
      </enum>
      <enum name="iso88025Dtr">
        <value value="86"/>
      </enum>
      <enum name="eplrs">
        <value value="87"/>
      </enum>
      <enum name="arap">
        <value value="88"/>
      </enum>
      <enum name="propCnls">
        <value value="89"/>
      </enum>
      <enum name="hostPad">
        <value value="90"/>
      </enum>
      <enum name="termPad">
        <value value="91"/>
      </enum>
      <enum name="frameRelayMPI">
        <value value="92"/>
      </enum>
      <enum name="x213">
        <value value="93"/>
      </enum>
      <enum name="adsl">
        <value value="94"/>
      </enum>
      <enum name="radsl">
        <value value="95"/>
      </enum>
      <enum name="sdsl">
        <value value="96"/>
      </enum>
      <enum name="vdsl">
        <value value="97"/>
      </enum>
      <enum name="iso88025CRFPInt">
        <value value="98"/>
      </enum>
      <enum name="myrinet">
        <value value="99"/>
      </enum>
      <enum name="voiceEM">
        <value value="100"/>
      </enum>
      <enum name="voiceFXO">
        <value value="101"/>
      </enum>
      <enum name="voiceFXS">
        <value value="102"/>
      </enum>
      <enum name="voiceEncap">
        <value value="103"/>
      </enum>
      <enum name="voiceOverIp">
        <value value="104"/>
      </enum>
      <enum name="atmDxi">
        <value value="105"/>
      </enum>
      <enum name="atmFuni">
        <value value="106"/>
      </enum>
      <enum name="atmIma">
        <value value="107"/>
      </enum>
      <enum name="pppMultilinkBundle">
        <value value="108"/>
      </enum>
      <enum name="ipOverCdlc">
        <value value="109"/>
      </enum>
      <enum name="ipOverClaw">
        <value value="110"/>
      </enum>
      <enum name="stackToStack">
        <value value="111"/>
      </enum>
      <enum name="virtualIpAddress">
        <value value="112"/>
      </enum>
      <enum name="mpc">
        <value value="113"/>
      </enum>
      <enum name="ipOverAtm">
        <value value="114"/>
      </enum>
      <enum name="iso88025Fiber">
        <value value="115"/>
      </enum>
      <enum name="tdlc">
        <value value="116"/>
      </enum>
      <enum name="gigabitEthernet">
        <value value="117"/>
      </enum>
      <enum name="hdlc">
        <value value="118"/>
      </enum>
      <enum name="lapf">
        <value value="119"/>
      </enum>
      <enum name="v37">
        <value value="120"/>
      </enum>
      <enum name="x25mlp">
        <value value="121"/>
      </enum>
      <enum name="x25huntGroup">
        <value value="122"/>
      </enum>
      <enum name="trasnpHdlc">
        <value value="123"/>
      </enum>
      <enum name="interleave">
        <value value="124"/>
      </enum>
      <enum name="fast">
        <value value="125"/>
      </enum>
      <enum name="ip">
        <value value="126"/>
      </enum>
      <enum name="docsCableMaclayer">
        <value value="127"/>
      </enum>
      <enum name="docsCableDownstream">
        <value value="128"/>
      </enum>
      <enum name="docsCableUpstream">
        <value value="129"/>
      </enum>
      <enum name="a12MppSwitch">
        <value value="130"/>
      </enum>
      <enum name="tunnel">
        <value value="131"/>
      </enum>
      <enum name="coffee">
        <value value="132"/>
      </enum>
      <enum name="ces">
        <value value="133"/>
      </enum>
      <enum name="atmSubInterface">
        <value value="134"/>
      </enum>
      <enum name="l2vlan">
        <value value="135"/>
      </enum>
      <enum name="l3ipvlan">
        <value value="136"/>
      </enum>
      <enum name="l3ipxvlan">
        <value value="137"/>
      </enum>
      <enum name="digitalPowerline">
        <value value="138"/>
      </enum>
      <enum name="mediaMailOverIp">
        <value value="139"/>
      </enum>
      <enum name="dtm">
        <value value="140"/>
      </enum>
      <enum name="dcn">
        <value value="141"/>
      </enum>
      <enum name="ipForward">
        <value value="142"/>
      </enum>
      <enum name="msdsl">
        <value value="143"/>
      </enum>
      <enum name="ieee1394">
        <value value="144"/>
      </enum>
      <enum name="if-gsn">
        <value value="145"/>
      </enum>
      <enum name="dvbRccMacLayer">
        <value value="146"/>
      </enum>
      <enum name="dvbRccDownstream">
        <value value="147"/>
      </enum>
      <enum name="dvbRccUpstream">
        <value value="148"/>
      </enum>
      <enum name="atmVirtual">
        <value value="149"/>
      </enum>
      <enum name="mplsTunnel">
        <value value="150"/>
      </enum>
      <enum name="srp">
        <value value="151"/>
      </enum>
      <enum name="voiceOverAtm">
        <value value="152"/>
      </enum>
      <enum name="voiceOverFrameRelay">
        <value value="153"/>
      </enum>
      <enum name="idsl">
        <value value="154"/>
      </enum>
      <enum name="compositeLink">
        <value value="155"/>
      </enum>
      <enum name="ss7SigLink">
        <value value="156"/>
      </enum>
      <enum name="propWirelessP2P">
        <value value="157"/>
      </enum>
      <enum name="frForward">
        <value value="158"/>
      </enum>
      <enum name="rfc1483">
        <value value="159"/>
      </enum>
      <enum name="usb">
        <value value="160"/>
      </enum>
      <enum name="ieee8023adLag">
        <value value="161"/>
      </enum>
      <enum name="bgppolicyaccounting">
        <value value="162"/>
      </enum>
      <enum name="frf16MfrBundle">
        <value value="163"/>
      </enum>
      <enum name="h323Gatekeeper">
        <value value="164"/>
      </enum>
      <enum name="h323Proxy">
        <value value="165"/>
      </enum>
      <enum name="mpls">
        <value value="166"/>
      </enum>
      <enum name="mfSigLink">
        <value value="167"/>
      </enum>
      <enum name="hdsl2">
        <value value="168"/>
      </enum>
      <enum name="shdsl">
        <value value="169"/>
      </enum>
      <enum name="ds1FDL">
        <value value="170"/>
      </enum>
      <enum name="pos">
        <value value="171"/>
      </enum>
      <enum name="dvbAsiIn">
        <value value="172"/>
      </enum>
      <enum name="dvbAsiOut">
        <value value="173"/>
      </enum>
      <enum name="plc">
        <value value="174"/>
      </enum>
      <enum name="nfas">
        <value value="175"/>
      </enum>
      <enum name="tr008">
        <value value="176"/>
      </enum>
      <enum name="gr303RDT">
        <value value="177"/>
      </enum>
      <enum name="gr303IDT">
        <value value="178"/>
      </enum>
      <enum name="isup">
        <value value="179"/>
      </enum>
      <enum name="propDocsWirelessMaclayer">
        <value value="180"/>
      </enum>
      <enum name="propDocsWirelessDownstream">
        <value value="181"/>
      </enum>
      <enum name="propDocsWirelessUpstream">
        <value value="182"/>
      </enum>
      <enum name="hiperlan2">
        <value value="183"/>
      </enum>
      <enum name="propBWAp2Mp">
        <value value="184"/>
      </enum>
      <enum name="sonetOverheadChannel">
        <value value="185"/>
      </enum>
      <enum name="digitalWrapperOverheadChannel">
        <value value="186"/>
      </enum>
      <enum name="aal2">
        <value value="187"/>
      </enum>
      <enum name="radioMAC">
        <value value="188"/>
      </enum>
      <enum name="atmRadio">
        <value value="189"/>
      </enum>
      <enum name="imt">
        <value value="190"/>
      </enum>
      <enum name="mvl">
        <value value="191"/>
      </enum>
      <enum name="reachDSL">
        <value value="192"/>
      </enum>
      <enum name="frDlciEndPt">
        <value value="193"/>
      </enum>
      <enum name="atmVciEndPt">
        <value value="194"/>
      </enum>
      <enum name="opticalChannel">
        <value value="195"/>
      </enum>
      <enum name="opticalTransport">
        <value value="196"/>
      </enum>
      <enum name="propAtm">
        <value value="197"/>
      </enum>
      <enum name="voiceOverCable">
        <value value="198"/>
      </enum>
      <enum name="infiniband">
        <value value="199"/>
      </enum>
      <enum name="teLink">
        <value value="200"/>
      </enum>
      <enum name="q2931">
        <value value="201"/>
      </enum>
      <enum name="virtualTg">
        <value value="202"/>
      </enum>
      <enum name="sipTg">
        <value value="203"/>
      </enum>
      <enum name="sipSig">
        <value value="204"/>
      </enum>
      <enum name="docsCableUpstreamChannel">
        <value value="205"/>
      </enum>
      <enum name="econet">
        <value value="206"/>
      </enum>
      <enum name="pon155">
        <value value="207"/>
      </enum>
      <enum name="pon622">
        <value value="208"/>
      </enum>
      <enum name="bridge">
        <value value="209"/>
      </enum>
      <enum name="linegroup">
        <value value="210"/>
      </enum>
      <enum name="voiceEMFGD">
        <value value="211"/>
      </enum>
      <enum name="voiceFGDEANA">
        <value value="212"/>
      </enum>
      <enum name="voiceDID">
        <value value="213"/>
      </enum>
      <enum name="mpegTransport">
        <value value="214"/>
      </enum>
      <enum name="sixToFour">
        <value value="215"/>
      </enum>
      <enum name="gtp">
        <value value="216"/>
      </enum>
      <enum name="pdnEtherLoop1">
        <value value="217"/>
      </enum>
      <enum name="pdnEtherLoop2">
        <value value="218"/>
      </enum>
      <enum name="opticalChannelGroup">
        <value value="219"/>
      </enum>
      <enum name="homepna">
        <value value="220"/>
      </enum>
      <enum name="gfp">
        <value value="221"/>
      </enum>
      <enum name="ciscoISLvlan">
        <value value="222"/>
      </enum>
      <enum name="actelisMetaLOOP">
        <value value="223"/>
      </enum>
      <enum name="fcipLink">
        <value value="224"/>
      </enum>
      <enum name="rpr">
        <value value="225"/>
      </enum>
      <enum name="qam">
        <value value="226"/>
      </enum>
      <enum name="lmp">
        <value value="227"/>
      </enum>
      <enum name="cblVectaStar">
        <value value="228"/>
      </enum>
      <enum name="docsCableMCmtsDownstream">
        <value value="229"/>
      </enum>
      <enum name="adsl2">
        <value value="230"/>
      </enum>
    </type>
    <description>
      <text>
        This data type is used as the syntax of the ifType
         object in the (updated) definition of MIB-II's
         ifTable.
         
         The definition of this textual convention with the
         addition of newly assigned values is published
         periodically by the IANA, in either the Assigned
         Numbers RFC, or some derivative of it specific to
         Internet Network Management number assignments.  (The
         latest arrangements can be obtained by contacting the
         IANA.)
         
         Requests for new values should be made to IANA via
         email (iana@iana.org).
         
         The relationship between the assignment of ifType
         values and of OIDs to particular media-specific MIBs
         is solely the purview of IANA and is subject to change
         without notice.  Quite often, a media-specific MIB's
         OID-subtree assignment within MIB-II's 'transmission'
         subtree will be the same as its ifType value.
         However, in some circumstances this will not be the
         case, and implementors must not pre-assume any
         specific relationship between ifType values and
         transmission subtree OIDs.
      </text>
    </description>
  </typedef>

  <typedef name="IANAtunnelType">
    <type name="enumeration">
      <enum name="other">
        <value value="1"/>
      </enum>
      <enum name="direct">
        <value value="2"/>
      </enum>
      <enum name="gre">
        <value value="3"/>
      </enum>
      <enum name="minimal">
        <value value="4"/>
      </enum>
      <enum name="l2tp">
        <value value="5"/>
      </enum>
      <enum name="pptp">
        <value value="6"/>
      </enum>
      <enum name="l2f">
        <value value="7"/>
      </enum>
      <enum name="udp">
        <value value="8"/>
      </enum>
      <enum name="atmp">
        <value value="9"/>
      </enum>
      <enum name="msdp">
        <value value="10"/>
      </enum>
      <enum name="sixToFour">
        <value value="11"/>
      </enum>
      <enum name="sixOverFour">
        <value value="12"/>
      </enum>
      <enum name="isatap">
        <value value="13"/>
      </enum>
      <enum name="teredo">
        <value value="14"/>
      </enum>
    </type>
    <description>
      <text>
        The encapsulation method used by a tunnel. The value
         direct indicates that a packet is encapsulated
         directly within a normal IP header, with no
         intermediate header, and unicast to the remote tunnel
         endpoint (e.g., an RFC 2003 IP-in-IP tunnel, or an RFC
         1933 IPv6-in-IPv4 tunnel). The value minimal indicates
         that a Minimal Forwarding Header (RFC 2004) is
         inserted between the outer header and the payload
         packet. The value UDP indicates that the payload
         packet is encapsulated within a normal UDP packet
         (e.g., RFC 1234).
         
         The values sixToFour, sixOverFour, and isatap
         indicates that an IPv6 packet is encapsulated directly
         within an IPv4 header, with no intermediate header,
         and unicast to the destination determined by the 6to4,
         6over4, or ISATAP protocol.
         
         The remaining protocol-specific values indicate that a
         header of the protocol of that name is inserted
         between the outer header and the payload header.
         
         The assignment policy for IANAtunnelType values is
         identical to the policy for assigning IANAifType
         values.
      </text>
    </description>
  </typedef>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="IANA-LANGUAGE-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:IANA-LANGUAGE-MIB"/>
  <prefix value="iana-language"/>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IANA
    </info>
  </organization>
  <contact>
  <info>
  Internet Assigned Numbers Authority (IANA)
      
      Postal: ICANN
              4676 Admiralty Way, Suite 330
              Marina del Rey, CA 90292
      
      Tel:    +1 310 823 9358 x20
      E-Mail: iana@iana.org
    </info>
  </contact>
  <description>
    <text>
      The MIB module registers object identifier values for
      well-known programming and scripting languages. Every
      language registration MUST describe the format used
      when transferring scripts written in this language.
      
      Any additions or changes to the contents of this MIB
      module require Designated Expert Review as defined in
      the Guidelines for Writing IANA Considerations Section
      document. The Designated Expert will be selected by
      the IESG Area Director of the OPS Area.
      
      Note, this module does not have to register all possible
      languages since languages are identified by object
      identifier values. It is therefore possible to registered 
      languages in private OID trees. The references given below are not
      normative with regard to the language version. Other
      references might be better suited to describe some newer 
      versions of this language. The references are only
      provided as `a pointer into the right direction'.
    </text>
  </description>
  <revision date="2000-05-10">
    <description>
      <text>
        Import mib-2 instead of experimental, so that
         this module compiles
      </text>
    </description>
  </revision>
  <revision date="1999-09-09">
    <description>
      <text>
        Initial version as published at time of
         publication of RFC 2591.
      </text>
    </description>
  </revision>
</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
        name="IANA-RTPROTO-MIB">
  <namespace uri="urn:ietf:params:xml:ns:yang:smiv2:IANA-RTPROTO-MIB"/>
  <prefix value="iana-rtproto"/>
  <import module="yang-smi">
    <prefix value="smi"/>
  </import>
  <organization>
  <info>
    IANA
    </info>
  </organization>
  <contact>
  <info>
   Internet Assigned Numbers Authority
      Internet Corporation for Assigned Names and Numbers
      4676 Admiralty Way, Suite 330
      Marina del Rey, CA 90292-6601
      
      Phone: +1 310 823 9358
      EMail: iana@iana.org
    </info>
  </contact>
  <description>
    <text>
      This MIB module defines the IANAipRouteProtocol and
      IANAipMRouteProtocol textual conventions for use in MIBs
      which need to identify unicast or multicast routing
      mechanisms.
      
      Any additions or changes to the contents of this MIB module
      require either publication of an RFC, or Designated Expert
      Review as defined in RFC 2434, Guidelines for Writing an
      IANA Considerations Section in RFCs.  The Designated Expert 
      will be selected by the IESG Area Director(s) of the Routing
      Area.
    </text>
  </description>
  <revision date="2000-09-26">
    <description>
      <text>
        Original version, published in coordination
         with RFC 2932.
      </text>
    </description>
  </revision>
  <typedef name="IANAipRouteProtocol">
    <type name="enumeration">
      <enum name="other">
        <value value="1"/>
      </enum>
      <enum name="local">
        <value value="2"/>
      </enum>
      <enum name="netmgmt">
        <value value="3"/>
      </enum>
      <enum name="icmp">
        <value value="4"/>
      </enum>
      <enum name="egp">
        <value value="5"/>
      </enum>
      <enum name="ggp">
        <value value="6"/>
      </enum>
      <enum name="hello">
        <value value="7"/>
      </enum>
      <enum name="rip">
        <value value="8"/>
      </enum>
      <enum name="isIs">
        <value value="9"/>
      </enum>
      <enum name="esIs">
        <value value="10"/>
      </enum>
      <enum name="ciscoIgrp">
        <value value="11"/>
      </enum>
      <enum name="bbnSpfIgp">
        <value value="12"/>
      </enum>
      <enum name="ospf">
        <value value="13"/>
      </enum>
      <enum name="bgp">
        <value value="14"/>
      </enum>
      <enum name="idpr">
        <value value="15"/>
      </enum>
      <enum name="ciscoEigrp">
        <value value="16"/>
      </enum>
      <enum name="dvmrp">
        <value value="17"/>
      </enum>
    </type>
    <description>
      <text>
        A mechanism for learning routes.  Inclusion of values for
         routing protocols is not intended to imply that those
         protocols need be supported.
      </text>
    </description>
  </typedef>

  <typedef name="IANAipMRouteProtocol">
    <type name="enumeration">
      <enum name="other">
        <value value="1"/>
      </enum>
      <enum name="local">
        <value value="2"/>
      </enum>
      <enum name="netmgmt">
        <value value="3"/>
      </enum>
      <enum name="dvmrp">
        <value value="4"/>
      </enum>
      <enum name="mospf">
        <value value="5"/>
      </enum>
      <enum name="pimSparseDense">
        <value value="6"/>
      </enum>
      <enum name="cbt">
        <value value="7"/>
      </enum>
      <enum name="pimSparseMode">
        <value value="8"/>
      </enum>
      <enum name="pimDenseMode">
        <value value="9"/>
      </enum>
      <enum name="igmpOnly">
        <value value="10"/>
      </enum>
      <enum name="bgmp">
        <value value="11"/>
      </enum>
      <enum name="msdp">
        <value value="12"/>
      </enum>
    </type>
    <description>
      <text>
        The multicast routing protocol.  Inclusion of values for
         multicast routing protocols is not intended to imply that
         those protocols need be supported.
      </text>
    </description>
  </typedef>

</module>
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:ietf:params:xml:ns:yin:1"
        name="ietf-inet-types">
  <namespace uri="urn:ietf:params:xml:ns:yang:inet-types"/>
  <prefix value="inet"/>
  <organization>
  <info>
    IETF NETMOD (NETCONF Data Modeling Language) Working Group
    </info>
  </organization>
  <contact>
  <info>
  WG Web:   <http://tools.ietf.org/wg/netmod/>
     WG List:  <mailto:netmod@ietf.org>

     WG Chair: David Partain
               <mailto:david.partain@ericsson.com>

     WG Chair: David Kessens
               <mailto:david.kessens@nsn.com>

     Editor:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>
    </info>
  </contact>
  <description>
    <text>
      This module contains a collection of generally useful derived
     YANG data types for Internet addresses and related things.

     Copyright (c) 2009 IETF Trust and the persons identified as
     the document authors.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that the
     following conditions are met:

     - Redistributions of source code must retain the above
       copyright notice, this list of conditions and the
       following disclaimer.

     - Redistributions in binary form must reproduce the above
       copyright notice, this list of conditions and the
       following disclaimer in the documentation and/or other
       materials provided with the distribution.

     - Neither the name of Internet Society, IETF or IETF
       Trust, nor the names of specific contributors, may be
       used to endorse or promote products derived from this
       software without specific prior written permission.



     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
     CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED
     WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
     GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
     BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
     OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     POSSIBILITY OF SUCH DAMAGE.

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.
    </text>
  </description>
  <revision date="2009-05-13">
    <description>
      <text>
        Initial revision, published as RFC XXXX.
      </text>
    </description>
  </revision>
  <typedef name="ip-version">
    <type name="enumeration">
      <enum name="unknown">
        <value value="0"/>
        <description>
          <text>
            An unknown or unspecified version of the Internet protocol.
          </text>
        </description>
      </enum>
      <enum name="ipv4">
        <value value="1"/>
        <description>
          <text>
            The IPv4 protocol as defined in RFC 791.
          </text>
        </description>
      </enum>
      <enum name="ipv6">
        <value value="2"/>
        <description>
          <text>
            The IPv6 protocol as defined in RFC 2460.
          </text>
        </description>
      </enum>
    </type>
    <description>
      <text>
        This value represents the version of the IP protocol.


       This type is in the value set and its semantics equivalent
       to the InetVersion textual convention of the SMIv2. However,
       the lexical appearance is different from the InetVersion
       textual convention.
      </text>
    </description>
  </typedef>

  <typedef name="dscp">
    <type name="uint8">
      <range value="0..63"/>
    </type>
    <description>
      <text>
        The dscp type represents a Differentiated Services Code-Point
       that may be used for marking packets in a traffic stream.

       This type is in the value set and its semantics equivalent
       to the Dscp textual convention of the SMIv2.
      </text>
    </description>
  </typedef>

  <typedef name="ipv6-flow-label">
    <type name="uint32">
      <range value="0..1048575"/>
    </type>
    <description>
      <text>
        The flow-label type represents flow identifier or Flow Label
       in an IPv6 packet header that may be used to discriminate
       traffic flows.

       This type is in the value set and its semantics equivalent
       to the IPv6FlowLabel textual convention of the SMIv2.
      </text>
    </description>
  </typedef>

  <typedef name="port-number">
    <type name="uint16">
      <range value="1..65535"/>
    </type>
    <description>
      <text>
        The port-number type represents a 16-bit port number of an
       Internet transport layer protocol such as UDP, TCP, DCCP or
       SCTP. Port numbers are assigned by IANA.  A current list of
       all assignments is available from <http://www.iana.org/>.

       Note that the value zero is not a valid port number. A union
       type might be used in situations where the value zero is
       meaningful.

       This type is in the value set and its semantics equivalent
       to the InetPortNumber textual convention of the SMIv2.
      </text>
    </description>
  </typedef>

  <typedef name="as-number">
    <type name="uint32"/>
    <description>
      <text>
        The as-number type represents autonomous system numbers
        which identify an Autonomous System (AS). An AS is a set
        of routers under a single technical administration, using
        an interior gateway protocol and common metrics to route
        packets within the AS, and using an exterior gateway
        protocol to route packets to other ASs'. IANA maintains
        the AS number space and has delegated large parts to the
        regional registries.

        Autonomous system numbers were originally limited to 16
        bits. BGP extensions have enlarged the autonomous system
        number space to 32 bits. This type therefore uses an uint32
        base type without a range restriction in order to support
        a larger autonomous system number space.

        This type is in the value set and its semantics equivalent
        to the InetAutonomousSystemNumber textual convention of
        the SMIv2.
      </text>
    </description>
  </typedef>

  <typedef name="ip-address">
    <type name="union">
      <type name="inet:ipv4-address"/>
      <type name="inet:ipv6-address"/>
    </type>
    <description>
      <text>
        The ip-address type represents an IP address and is IP
       version neutral. The format of the textual representations
       implies the IP version.
      </text>
    </description>
  </typedef>

  <typedef name="ipv4-address">
    <type name="string">
      <pattern value="'((0' + '|(1[0-9]{0,2})' + '|(2(([0-4][0-9]?)|(5[0-5]?)|([6-9]?)))' + '|([3-9][0-9]?)' + ')' + '\.){3}' + '(0' + '|(1[0-9]{0,2})' + '|(2(([0-4][0-9]?)|(5[0-5]?)|([6-9]?)))' + '|([3-9][0-9]?)' + ')(%[\p{N}\p{L}]+)?'"/>
    </type>
    <description>
      <text>
        The ipv4-address type represents an IPv4 address in
        dotted-quad notation. The IPv4 address may include a zone
        index, separated by a % sign.

        The zone index is used to disambiguate identical address
        values.  For link-local addresses, the zone index will
        typically be the interface index number or the name of an
        interface. If the zone index is not present, the default
        zone of the device will be used.

        The canonical format for the zone index is the numerical
        format
      </text>
    </description>
  </typedef>

  <typedef name="ipv6-address">
    <type name="string">
      <pattern value="'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}' + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|' + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}' + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))' + '(%[\p{N}\p{L}]+)?'"/>
      <pattern value="'(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|' + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)' + '(%.+)?'"/>
    </type>
    <description>
      <text>
        The ipv6-address type represents an IPv6 address in full,
       mixed, shortened and shortened mixed notation.  The IPv6
       address may include a zone index, separated by a % sign.

       The zone index is used to disambiguate identical address
       values.  For link-local addresses, the zone index will
       typically be the interface index number or the name of an
       interface. If the zone index is not present, the default
       zone of the device will be used.

       The canonical format of IPv6 addresses uses the compressed
       format described in RFC 4291 section 2.2 item 2 with the
       following additional rules: The :: substitution must be
       applied to the longest sequence of all-zero 16-bit chunks
       in an IPv6 address. If there is a tie, the first sequence
       of all-zero 16-bit chunks is replaced by ::. Single
       all-zero 16-bit chunks are not compressed. The normalized
       format uses lower-case characters and leading zeros are
       not allowed. The canonical format for the zone index is
       the numerical format as described in RFC 4007 section
       11.2.
      </text>
    </description>
  </typedef>

  <typedef name="ip-prefix">
    <type name="union">
      <type name="inet:ipv4-prefix"/>
      <type name="inet:ipv6-prefix"/>
    </type>
    <description>
      <text>
        The ip-prefix type represents an IP prefix and is IP
       version neutral. The format of the textual representations
       implies the IP version.
      </text>
    </description>
  </typedef>

  <typedef name="ipv4-prefix">
    <type name="string">
      <pattern value="'(([0-1]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-1]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))'"/>
    </type>
    <description>
      <text>
        The ipv4-prefix type represents an IPv4 address prefix.
       The prefix length is given by the number following the
       slash character and must be less than or equal to 32.

       A prefix length value of n corresponds to an IP address
       mask which has n contiguous 1-bits from the most
       significant bit (MSB) and all other bits set to 0.

       The canonical format of an IPv4 prefix has all bits of
       the IPv4 address set to zero that are not part of the
       IPv4 prefix.
      </text>
    </description>
  </typedef>

  <typedef name="ipv6-prefix">
    <type name="string">
      <pattern value="'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}' + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|' + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}' + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))' + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'"/>
      <pattern value="'(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|' + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)' + '(/.+)'"/>
    </type>
    <description>
      <text>
        The ipv6-prefix type represents an IPv6 address prefix.
       The prefix length is given by the number following the
       slash character and must be less than or equal 128.

       A prefix length value of n corresponds to an IP address
       mask which has n contiguous 1-bits from the most
       significant bit (MSB) and all other bits set to 0.

       The IPv6 address should have all bits that do not belong
       to the prefix set to zero.

       The canonical format of an IPv6 prefix has all bits of
       the IPv6 address set to zero that are not part of the
       IPv6 prefix. Furthermore, IPv6 address is represented
       in the compressed format described in RFC 4291 section
       2.2 item 2 with the following additional rules: The ::
       substitution must be applied to the longest sequence of
       all-zero 16-bit chunks in an IPv6 address. If there is
       a tie, the first sequence of all-zero 16-bit chunks is
       replaced by ::. Single all-zero 16-bit chunks are not
       compressed. The normalized format uses lower-case
       characters and leading zeros are not allowed.
      </text>
    </description>
  </typedef>

  <typedef name="domain-name">
    <type name="string">
      <length value="1..253"/>
      <pattern value="'((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*' + '([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)' + '|\.'"/>
    </type>
    <description>
      <text>
        The domain-name type represents a DNS domain name. The
       name SHOULD be fully qualified whenever possible.

       Internet domain names are only loosely specified. Section
       3.5 of RFC 1034 recommends a syntax (modified in section
       2.1 of RFC 1123). The pattern above is intended to allow
       for current practise in domain name use, and some possible
       future expansion. It is designed to hold various types of
       domain names, including names used for A or AAAA records
       (host names) and other records, such as SRV records. Note
       that Internet host names have a stricter syntax (described
       in RFC 952) than the DNS recommendations in RFCs 1034 and
       1123, and that systems that want to store host names in
       objects using the domain-name type are recommended to adhere
       to this stricter standard to ensure interoperability.

       The encoding of DNS names in the DNS protocol is limited
       to 255 characters. Since the encoding consists of labels
       prefixed by a length bytes and there is a trailing NULL
       byte, only 253 characters can appear in the textual dotted
       notation.

       The description clause of objects using the domain-name
       type MUST describe how (and when) these names are
       resolved to IP addresses. Note that the resolution of a
       domain-name value may require to query multiple DNS records
       (e.g., A for IPv4 and AAAA for IPv6). The order of the
       resolution process and which DNS record takes precedence
       depends on the configuration of the resolver.

       The canonical format for domain-name values uses the
       US-ASCII encoding and case-insensitive characters are set
       to lowercase.
      </text>
    </description>
  </typedef>

  <typedef name="host">
    <type name="union">
      <type name="inet:ip-address"/>
      <type name="inet:domain-name"/>
    </type>
    <description>
      <text>
        The host type represents either an IP address or a DNS
       domain name.
      </text>
    </description>
  </typedef>

  <typedef name="uri">
    <type name="string"/>
    <description>
      <text>
        The uri type represents a Uniform Resource Identifier
       (URI) as defined by STD 66.

       Objects using the uri type must be in US-ASCII encoding,
       and MUST be normalized as described by RFC 3986 Sections
       6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
       percent-encoding is removed, and all case-insensitive
       characters are set to lowercase except for hexadecimal
       digits, which are normalized to uppercase as described in
       Section 6.2.2.1.

       The purpose of this normalization is to help provide
       unique URIs.  Note that this normalization is not
       sufficient to provide uniqueness.  Two URIs that are
       textually distinct after this normalization may still be
       equivalent.

       Objects using the uri type may restrict the schemes that
       they permit.  For example, 'data:' and 'urn:' schemes
       might not be appropriate.

       A zero-length URI is not a valid URI.  This can be used to
       express 'URI absent' where required

       This type is in the value set and its semantics equivalent
       to the Uri SMIv2 textual convention defined in RFC 5017.
      </text>
    </description>
  </typedef>

</module>
